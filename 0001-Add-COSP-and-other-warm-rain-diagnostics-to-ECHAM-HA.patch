From 59405f1d83bebaf54826b201fec6edc2ead89abb Mon Sep 17 00:00:00 2001
From: Johannes Muelmenstaedt <b380126@mlogin102.hpc.dkrz.de>
Date: Fri, 27 Mar 2020 21:21:23 +0100
Subject: [PATCH] Add COSP and other warm rain diagnostics to ECHAM-HAM

---
 include/physctl.inc             |   6 +-
 src/Makefile                    | 270 ++++++----
 src/cloud.f90                   |  30 +-
 src/cloud_cdnc_icnc.f90         | 137 ++++-
 src/control.f90                 |   1 +
 src/cosp_lidar_simulator.f90    | 580 ++++++++++++++------
 src/cudtdq.f90                  |   3 +
 src/cuflx.f90                   |  24 +-
 src/initialize.f90              |   2 +-
 src/mo_activ.f90                |  24 +-
 src/mo_cloud.f90                |  15 +-
 src/mo_cloud_optics.f90         |   2 +-
 src/mo_cosp_constants.f90       | 321 ++++++++++-
 src/mo_cosp_lidar.f90           | 134 ++---
 src/mo_cosp_llnl_stats.f90      | 122 ++++-
 src/mo_cosp_lmd_ipsl_stats.f90  | 909 +++++++++++++++++++++++++++-----
 src/mo_cosp_offline.f90         | 201 +++----
 src/mo_cosp_stats.f90           | 461 +++++++++-------
 src/mo_ham_m7.f90               |  49 +-
 src/mo_ham_streams.f90          |  17 +-
 src/mo_machine.f90              |   8 +-
 src/mo_memory_g3b.f90           |  31 +-
 src/mo_memory_gl.f90            |  67 ++-
 src/mo_memory_streams.f90       |   8 +-
 src/mo_param_switches.f90       |   5 +
 src/mo_radiation.f90            | 123 ++++-
 src/mo_radiation_forcing.f90    | 243 ++++++++-
 src/mo_radiation_parameters.f90 |   5 +-
 src/physc.f90                   |  27 +-
 src/radheat.f90                 |   2 +-
 src/scan1.f90                   |  15 +
 src/setphys.f90                 |  35 +-
 src/stepon.f90                  |  22 +-
 33 files changed, 3028 insertions(+), 871 deletions(-)

diff --git a/include/physctl.inc b/include/physctl.inc
index 35b192a..ec465a4 100644
--- a/include/physctl.inc
+++ b/include/physctl.inc
@@ -16,6 +16,7 @@
 !     *LGWDRAG* LOGICAL   *TRUE FOR GRAVITY WAVE DRAG SCHEME  
 !     *LSURF*   LOGICAL   *TRUE FOR SURFACE EXCHANGES.                  
 !     *LICE*    LOGICAL   *TRUE* FOR SEA-ICE TEMPERATURE CALCULATION    
+!     *CCRAUT*  REAL      Autoconversion tunable parameter in mo_cloud (mo_echam_cloud_params)
 !     *ICONV*   INTEGER   SWITCH FOR CONVECTION SCHEME:
 !                         1: Nordeng
 !                         2: Tiedtke
@@ -43,6 +44,9 @@
 !     lorocirrus  logical turn on orographic cirrus clouds
 
 NAMELIST /PHYSCTL/ LPHYS,  LRAD,  LVDIFF, LCOND,   LSURF,                      &
-	           LCOVER, LCONV, LMFPEN, LGWDRAG, LICE, LCONVMASSFIX, ICONV,  &
+	           LCOVER, LCONV, LMFPEN, LGWDRAG, LICE, LCONVMASSFIX, CCRAUT, &
+		   CCAULOC, CRETH, CAUTALPHA, CAUTBETA, ICONV,  &
+                   lcdnc_act_only, &
+ 		   lcdnc_clim, cdnc_clim, &
                    lcdnc_progn, ncd_activ, nic_cirrus, nauto, ncvmicro, lsecprod, &
                    lorocirrus
diff --git a/src/Makefile b/src/Makefile
index 41ff07d..1446c08 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -3,41 +3,50 @@
 PROG =	../bin/echam6
 
 SRCS =	auxhyb.f90 cloud.f90 cloud_cdnc_icnc.f90 clsst.f90 clveg.f90 \
-	collect.f90 conteq.f90 control.f90 cosp_icarus.f90 \
-	cosp_lidar_simulator.f90 cover.f90 cuadjtq.f90 cuadjtqi.f90 cuasc.f90 \
-	cuasct.f90 cubase.f90 cubasmc.f90 cucall.f90 cuddraf.f90 cudlfs.f90 \
-	cudtdq.f90 cududv.f90 cuentr.f90 cuentrt.f90 cuflx.f90 cuini.f90 \
-	cumastr.f90 cumastrh.f90 cumastrt.f90 dyn.f90 ewd.f90 fftd.f90 \
-	ffti.f90 geopot.f90 gpc.f90 helmo.f90 inhysi.f90 inictl.f90 \
-	iniphy.f90 init_decomposition.f90 initemp.f90 initialize.f90 \
-	intaero.f90 ioinitial.f90 ionwp.f90 iorestart.f90 legtri.f90 ltd.f90 \
-	lti.f90 m_alloc_mods.f90 master.f90 maxwind.f90 ml_flux.f90 \
-	ml_ocean.f90 mo_activ.f90 mo_advection.f90 mo_aero_kinne.f90 \
-	mo_aero_tanre.f90 mo_aero_volc.f90 mo_aero_volc_tab.f90 \
-	mo_array_utils.f90 mo_atmosphere.f90 mo_bethy.f90 \
-	mo_bethy_constants.f90 mo_bethy_fapar.f90 mo_bethy_photosyn.f90 \
-	mo_boundary_condition.f90 mo_buffer_fft.f90 mo_call_trans.f90 \
-	mo_canopy.f90 mo_cbal_bethy.f90 mo_cbal_cpools.f90 \
+	collect.f90 conteq.f90 control.f90 cosp_calc_Re.f90 cosp_dsd.f90 \
+	cosp_gases.f90 cosp_icarus_simulator.f90 cosp_lidar_simulator.f90 \
+	cosp_misr_simulator.f90 cosp_radar_simulator.f90 \
+	cosp_radar_simulator_init.f90 \
+	cosp_scops.f90 cosp_zeff.f90 cover.f90 \
+	cuadjtq.f90 cuadjtqi.f90 cuasc.f90 cuasct.f90 cubase.f90 cubasmc.f90 \
+	cucall.f90 cuddraf.f90 cudlfs.f90 cudtdq.f90 cududv.f90 cuentr.f90 \
+	cuentrt.f90 cuflx.f90 cuini.f90 cumastr.f90 cumastrh.f90 cumastrt.f90 \
+	dyn.f90 ewd.f90 fftd.f90 ffti.f90 geopot.f90 gpc.f90 helmo.f90 \
+	inhysi.f90 inictl.f90 iniphy.f90 init_decomposition.f90 initemp.f90 \
+	initialize.f90 intaero.f90 ioinitial.f90 ionwp.f90 iorestart.f90 \
+	legtri.f90 ltd.f90 lti.f90 m_alloc_mods.f90 master.f90 maxwind.f90 \
+	ml_flux.f90 ml_ocean.f90 mo_activ.f90 mo_advection.f90 \
+	mo_aero_kinne.f90 mo_aero_tanre.f90 mo_aero_volc.f90 \
+	mo_aero_volc_tab.f90 mo_array_utils.f90 mo_atmosphere.f90 \
+	mo_bethy.f90 mo_bethy_constants.f90 mo_bethy_fapar.f90 \
+	mo_bethy_photosyn.f90 mo_boundary_condition.f90 mo_buffer_fft.f90 \
+	mo_call_trans.f90 mo_canopy.f90 mo_cbal_bethy.f90 mo_cbal_cpools.f90 \
 	mo_cbal_landcover_change.f90 mo_cbal_parameters.f90 mo_ccnclim.f90 \
 	mo_cirrus.f90 mo_clim.f90 mo_climatology.f90 mo_climbuf.f90 \
 	mo_cloud.f90 mo_cloud_optics.f90 mo_cloud_utils.f90 mo_co2.f90 \
 	mo_column.f90 mo_constants.f90 mo_control.f90 mo_conv.f90 \
-	mo_convect_tables.f90 mo_cosp_constants.f90 \
-	mo_cosp_isccp_simulator.f90 mo_cosp_lidar.f90 mo_cosp_llnl_stats.f90 \
-	mo_cosp_lmd_ipsl_stats.f90 mo_cosp_metoff_cosp.f90 \
-	mo_cosp_metoff_cosp_simulator.f90 mo_cosp_offline.f90 \
-	mo_cosp_simulator.f90 mo_cosp_stats.f90 mo_couple.f90 \
-	mo_cumulus_flux.f90 mo_debugs.f90 mo_decompose_io.f90 \
-	mo_decomposition.f90 mo_diag_amip2.f90 mo_diag_chemistry.f90 \
-	mo_diag_dynamics.f90 mo_diag_tendency.f90 mo_diag_tendency_new.f90 \
-	mo_dynveg.f90 mo_echam5_sw.f90 mo_emi_matrix.f90 mo_essl_dft.f90 \
-	mo_exception.f90 mo_external_field_processor.f90 mo_fft992.f90 \
-	mo_filename.f90 mo_forecast_switches.f90 mo_gaussgrid.f90 \
-	mo_geoloc.f90 mo_geopack.f90 mo_gl1.f90 mo_global_op.f90 \
-	mo_greenhouse_gases.f90 mo_gwspectrum.f90 mo_ham.f90 mo_ham_activ.f90 \
-	mo_ham_chemistry.f90 mo_ham_diag.f90 mo_ham_drydep.f90 \
-	mo_ham_dust.f90 mo_ham_gcrion.f90 mo_ham_init.f90 mo_ham_kappa.f90 \
-	mo_ham_m7.f90 mo_ham_m7_emi_seasalt.f90 mo_ham_m7_emissions.f90 \
+	mo_convect_tables.f90 mo_cosp_array_lib.f90 mo_cosp_atmos_lib.f90 \
+	mo_cosp_constants.f90 mo_cosp_echam.f90 mo_cosp_format_input.f90 \
+	mo_cosp_isccp.f90 mo_cosp_lidar.f90 mo_cosp_llnl_precip.f90 \
+	mo_cosp_llnl_stats.f90 mo_cosp_lmd_ipsl_stats.f90 \
+	mo_cosp_math_lib.f90 mo_cosp_misr.f90 mo_cosp_modis.f90 \
+	mo_cosp_modis_simulator.f90 mo_cosp_mrgrnk.f90 mo_cosp_offline.f90 \
+	mo_cosp_optics_lib.f90 mo_cosp_radar.f90 \
+	mo_cosp_radar_simulator_types.f90 \
+	mo_cosp_scale_LUTs_io.f90 mo_cosp_stats.f90 mo_cosp_types.f90 \
+	mo_cosp_utils.f90 mo_cosp_v1p4_cosp.f90 \
+	mo_cosp_v1p4_cosp_simulator.f90 mo_couple.f90 mo_cumulus_flux.f90 \
+	mo_debugs.f90 mo_decompose_io.f90 mo_decomposition.f90 \
+	mo_diag_amip2.f90 mo_diag_chemistry.f90 mo_diag_dynamics.f90 \
+	mo_diag_tendency.f90 mo_diag_tendency_new.f90 mo_dynveg.f90 \
+	mo_echam5_sw.f90 mo_emi_matrix.f90 mo_essl_dft.f90 mo_exception.f90 \
+	mo_external_field_processor.f90 mo_fft992.f90 mo_filename.f90 \
+	mo_forecast_switches.f90 mo_gaussgrid.f90 mo_geoloc.f90 \
+	mo_geopack.f90 mo_gl1.f90 mo_global_op.f90 mo_greenhouse_gases.f90 \
+	mo_gwspectrum.f90 mo_ham.f90 mo_ham_activ.f90 mo_ham_chemistry.f90 \
+	mo_ham_diag.f90 mo_ham_drydep.f90 mo_ham_dust.f90 mo_ham_gcrion.f90 \
+	mo_ham_init.f90 mo_ham_kappa.f90 mo_ham_m7.f90 \
+	mo_ham_m7_emi_seasalt.f90 mo_ham_m7_emissions.f90 \
 	mo_ham_m7_freezing.f90 mo_ham_m7_species.f90 mo_ham_m7_trac.f90 \
 	mo_ham_m7_wetdep_data.f90 mo_ham_m7ctl.f90 mo_ham_nucl.f90 \
 	mo_ham_nucl_diag.f90 mo_ham_rad.f90 mo_ham_rad_data.f90 \
@@ -58,8 +67,9 @@ SRCS =	auxhyb.f90 cloud.f90 cloud_cdnc_icnc.f90 clsst.f90 clveg.f90 \
 	mo_land_surface.f90 mo_legendre.f90 mo_linked_list.f90 mo_lrtm.f90 \
 	mo_lrtm_coeffs.f90 mo_lrtm_kgs.f90 mo_lrtm_netcdf.f90 \
 	mo_lrtm_rtrnmr.f90 mo_lrtm_setup.f90 mo_lrtm_taumol.f90 \
-	mo_lw_clop.f90 mo_machine.f90 mo_memory_base.f90 mo_memory_cfdiag.f90 \
-	mo_memory_f.f90 mo_memory_g1a.f90 mo_memory_g1b.f90 mo_memory_g2a.f90 \
+	mo_lw_clop.f90 mo_machine.f90 mo_math_constants.f90 \
+	mo_memory_base.f90 mo_memory_cfdiag.f90 mo_memory_f.f90 \
+	mo_memory_g1a.f90 mo_memory_g1b.f90 mo_memory_g2a.f90 \
 	mo_memory_g2b.f90 mo_memory_g3a.f90 mo_memory_g3b.f90 \
 	mo_memory_gl.f90 mo_memory_ls.f90 mo_memory_sp.f90 \
 	mo_memory_streams.f90 mo_methox.f90 mo_midatm.f90 mo_mkl_dft.f90 \
@@ -78,14 +88,14 @@ SRCS =	auxhyb.f90 cloud.f90 cloud_cdnc_icnc.f90 clsst.f90 clveg.f90 \
 	mo_nudging_pattern.f90 mo_nudging_sst.f90 mo_nudging_utils.f90 \
 	mo_o3_lwb.f90 mo_o3clim.f90 mo_orbit.f90 mo_orocirrus.f90 \
 	mo_output.f90 mo_param_switches.f90 mo_parameters.f90 mo_parrrtm.f90 \
-	mo_phenology.f90 mo_physc2.f90 mo_port_test.f90 mo_profile.f90 \
-	mo_rad_forcing_diag.f90 mo_radiation.f90 mo_radiation_forcing.f90 \
-	mo_radiation_parameters.f90 mo_random_numbers.f90 \
-	mo_read_netcdf77.f90 mo_real_timer.f90 mo_relaxation.f90 \
-	mo_rrsw_kgs.f90 mo_rrta_140gp.f90 mo_rrtab.f90 mo_rrtbg2.f90 \
-	mo_rrtftr.f90 mo_rrtrf.f90 mo_rrtwn.f90 mo_scan_buffer.f90 \
-	mo_semi_impl.f90 mo_semi_lagrangian.f90 mo_so4.f90 mo_soil.f90 \
-	mo_solar_irradiance.f90 mo_species.f90 mo_spectral.f90 \
+	mo_phenology.f90 mo_physc2.f90 mo_physical_constants.f90 \
+	mo_port_test.f90 mo_profile.f90 mo_rad_forcing_diag.f90 \
+	mo_radiation.f90 mo_radiation_forcing.f90 mo_radiation_parameters.f90 \
+	mo_random_numbers.f90 mo_random_numbers_cosp.f90 mo_read_netcdf77.f90 \
+	mo_real_timer.f90 mo_relaxation.f90 mo_rrsw_kgs.f90 mo_rrta_140gp.f90 \
+	mo_rrtab.f90 mo_rrtbg2.f90 mo_rrtftr.f90 mo_rrtrf.f90 mo_rrtwn.f90 \
+	mo_scan_buffer.f90 mo_semi_impl.f90 mo_semi_lagrangian.f90 mo_so4.f90 \
+	mo_soil.f90 mo_solar_irradiance.f90 mo_species.f90 mo_spectral.f90 \
 	mo_spitfire.f90 mo_srtm.f90 mo_srtm_config.f90 mo_srtm_taumol.f90 \
 	mo_ssodrag.f90 mo_ssortns.f90 mo_sst.f90 mo_station_diag.f90 \
 	mo_string_utls.f90 mo_sub_echam.f90 mo_sub_nml.f90 mo_submodel.f90 \
@@ -118,11 +128,30 @@ SRCS =	auxhyb.f90 cloud.f90 cloud_cdnc_icnc.f90 clsst.f90 clveg.f90 \
 	vdiff.f90
 
 OBJS := $(SRCS:.f90=.o)
+OBJS := $(OBJS:.c=.o)
+
 
 all: $(PROG)
 
 $(PROG): $(OBJS) ../lib/libsupport.a
-	$(F90) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
+	$(FC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
+
+.PHONY: version.c
+
+version.c:
+	../config/pvcs.pl --srcdir ..
+
+version.o: version.c
+
+install: all
+	$(MKDIR_P) $(bindir)
+	$(INSTALL) -m 755 ../bin/echam6 $(bindir)
+
+distclean:
+	rm -f $(PROG) $(OBJS) *.mod
+
+mostlyclean:
+	rm -f $(PROG) $(OBJS) *.mod
 
 clean:
 	rm -f $(PROG) $(OBJS) *.mod
@@ -130,15 +159,16 @@ clean:
 .SUFFIXES: $(SUFFIXES) .f90
 
 %.o: %.f90
-	$(F90) $(F90FLAGS) -c $<
+	$(FC) $(FCFLAGS) -c $<
 
 auxhyb.o: mo_constants.o mo_control.o mo_hyb.o mo_kind.o
-cloud.o: mo_cloud.o mo_constants.o mo_convect_tables.o mo_cosp_offline.o \
-	mo_kind.o mo_param_switches.o mo_profile.o mo_submodel.o \
+cloud.o: mo_cloud.o mo_constants.o mo_convect_tables.o mo_kind.o \
+	mo_memory_gl.o mo_param_switches.o mo_profile.o mo_submodel.o \
 	mo_submodel_interface.o mo_time_control.o mo_timer.o mo_vphysc.o
 cloud_cdnc_icnc.o: mo_activ.o mo_cirrus.o mo_cloud.o mo_cloud_utils.o \
-	mo_constants.o mo_conv.o mo_convect_tables.o mo_kind.o \
-	mo_memory_g2a.o mo_memory_g3b.o mo_orocirrus.o mo_param_switches.o \
+	mo_constants.o mo_conv.o mo_convect_tables.o mo_cosp_echam.o \
+	mo_cosp_offline.o mo_kind.o mo_memory_g2a.o mo_memory_g3b.o \
+	mo_memory_gl.o mo_orocirrus.o mo_param_switches.o \
 	mo_submodel_interface.o mo_time_control.o mo_vphysc.o
 clsst.o: mo_column.o mo_constants.o mo_control.o mo_decomposition.o \
 	mo_geoloc.o mo_interpo.o mo_kind.o mo_memory_g3b.o mo_physc2.o \
@@ -162,8 +192,20 @@ control.o: m_alloc_mods.o mo_advection.o mo_aero_kinne.o mo_aero_tanre.o \
 	mo_station_diag.o mo_surface.o mo_time_control.o mo_timer.o \
 	mo_tmp_buffer.o mo_tpcore.o mo_tracdef.o mo_truncation.o \
 	mo_util_db_timings.o mo_version.o
-cosp_icarus.o: mo_exception.o mo_kind.o
-cosp_lidar_simulator.o: mo_constants.o mo_kind.o
+cosp_calc_Re.o: mo_cosp_math_lib.o mo_kind.o
+cosp_dsd.o: mo_cosp_array_lib.o mo_cosp_math_lib.o mo_kind.o
+cosp_gases.o: mo_kind.o
+cosp_icarus_simulator.o: mo_kind.o
+cosp_lidar_simulator.o: mo_kind.o mo_math_constants.o
+cosp_misr_simulator.o: mo_kind.o
+cosp_radar_simulator.o: mo_cosp_array_lib.o mo_cosp_math_lib.o \
+	mo_cosp_mrgrnk.o mo_cosp_optics_lib.o mo_cosp_radar_simulator_types.o \
+	mo_cosp_scale_LUTs_io.o mo_kind.o
+cosp_radar_simulator_init.o: mo_cosp_radar_simulator_types.o mo_kind.o
+#cosp_rttov_alloc_prof.o: mo_kind.o
+#cosp_rttov_multprof.o: mo_cosp_rttov_const.o mo_cosp_rttov_types.o mo_kind.o
+cosp_scops.o: mo_kind.o mo_random_numbers_cosp.o
+cosp_zeff.o: mo_cosp_math_lib.o mo_cosp_optics_lib.o mo_kind.o
 cover.o: mo_cloud.o mo_constants.o mo_convect_tables.o mo_kind.o \
 	mo_param_switches.o mo_profile.o
 cuadjtq.o: mo_constants.o mo_convect_tables.o mo_kind.o mo_profile.o
@@ -180,14 +222,14 @@ cucall.o: mo_constants.o mo_convect_tables.o mo_kind.o mo_param_switches.o \
 	mo_time_control.o
 cuddraf.o: mo_constants.o mo_cumulus_flux.o mo_kind.o mo_param_switches.o
 cudlfs.o: mo_constants.o mo_cumulus_flux.o mo_kind.o mo_param_switches.o
-cudtdq.o: mo_constants.o mo_kind.o mo_param_switches.o mo_submodel.o \
-	mo_time_control.o mo_tracdef.o mo_vphysc.o
+cudtdq.o: mo_constants.o mo_kind.o mo_memory_g3b.o mo_param_switches.o \
+	mo_submodel.o mo_time_control.o mo_tracdef.o mo_vphysc.o
 cududv.o: mo_constants.o mo_kind.o
 cuentr.o: mo_constants.o mo_cumulus_flux.o mo_kind.o mo_profile.o
 cuentrt.o: mo_constants.o mo_cumulus_flux.o mo_kind.o
-cuflx.o: mo_constants.o mo_cosp_offline.o mo_geoloc.o mo_kind.o \
-	mo_memory_cfdiag.o mo_param_switches.o mo_physc2.o mo_submodel.o \
-	mo_submodel_interface.o mo_time_control.o
+cuflx.o: mo_constants.o mo_cosp_echam.o mo_cosp_offline.o mo_geoloc.o \
+	mo_kind.o mo_memory_cfdiag.o mo_param_switches.o mo_physc2.o \
+	mo_submodel.o mo_submodel_interface.o mo_time_control.o
 cuini.o: mo_constants.o mo_kind.o mo_param_switches.o
 cumastr.o: mo_constants.o mo_control.o mo_convect_tables.o mo_cumulus_flux.o \
 	mo_kind.o mo_param_switches.o mo_time_control.o mo_tracer_processes.o
@@ -224,7 +266,7 @@ initemp.o: mo_clim.o mo_constants.o mo_control.o mo_decomposition.o \
 	mo_radiation_parameters.o mo_sst.o mo_surface_memory.o \
 	mo_time_control.o
 initialize.o: m_alloc_mods.o mo_advection.o mo_co2.o mo_column.o mo_control.o \
-	mo_cosp_offline.o mo_cosp_simulator.o mo_debugs.o mo_exception.o \
+	mo_cosp_echam.o mo_cosp_offline.o mo_debugs.o mo_exception.o \
 	mo_greenhouse_gases.o mo_io.o mo_jsbach_interface.o \
 	mo_memory_cfdiag.o mo_nudging_init.o mo_radiation.o \
 	mo_radiation_parameters.o mo_station_diag.o mo_submodel.o \
@@ -259,7 +301,7 @@ ml_flux.o: mo_decomposition.o mo_interpo.o mo_kind.o mo_memory_g3b.o mo_sst.o
 ml_ocean.o: mo_constants.o mo_kind.o mo_physc2.o mo_time_control.o
 mo_activ.o: mo_cloud.o mo_constants.o mo_control.o mo_conv.o mo_exception.o \
 	mo_filename.o mo_kind.o mo_linked_list.o mo_memory_base.o \
-	mo_param_switches.o mo_submodel.o mo_tracer.o
+	mo_param_switches.o mo_submodel.o mo_time_event.o mo_tracer.o
 mo_aero_kinne.o: mo_constants.o mo_decomposition.o mo_exception.o \
 	mo_interpo.o mo_kind.o mo_memory_g3b.o mo_mpi.o mo_parrrtm.o \
 	mo_read_netcdf77.o mo_time_control.o mo_time_conversion.o \
@@ -324,8 +366,7 @@ mo_climbuf.o: mo_exception.o mo_io.o mo_io_units.o mo_jsbach.o \
 	mo_time_event.o mo_tr_scatter.o $(INCLUDE)/climbuf_ctl.inc
 mo_cloud.o: mo_constants.o mo_control.o mo_exception.o mo_kind.o \
 	mo_submodel.o
-mo_cloud_optics.o: mo_constants.o mo_cosp_simulator.o mo_exception.o \
-	mo_kind.o
+mo_cloud_optics.o: mo_constants.o mo_exception.o mo_kind.o
 mo_cloud_utils.o: mo_cloud.o mo_constants.o mo_control.o mo_kind.o
 mo_co2.o: mo_constants.o mo_control.o mo_decomposition.o mo_exception.o \
 	mo_filename.o mo_gaussgrid.o mo_geoloc.o mo_kind.o mo_linked_list.o \
@@ -342,26 +383,50 @@ mo_constants.o: mo_kind.o
 mo_control.o: mo_kind.o
 mo_conv.o: mo_filename.o mo_kind.o mo_linked_list.o mo_memory_base.o
 mo_convect_tables.o: mo_cloud.o mo_constants.o mo_exception.o mo_kind.o
+mo_cosp_array_lib.o: mo_cosp_mrgrnk.o mo_kind.o
+mo_cosp_atmos_lib.o: mo_kind.o
 mo_cosp_constants.o: mo_kind.o
-mo_cosp_isccp_simulator.o: mo_cosp_constants.o mo_kind.o
-mo_cosp_lidar.o: mo_cosp_constants.o mo_kind.o
-mo_cosp_llnl_stats.o: mo_kind.o
+mo_cosp_echam.o: mo_cosp_constants.o mo_cosp_types.o mo_cosp_v1p4_cosp.o \
+	mo_exception.o mo_kind.o mo_linked_list.o mo_memory_base.o mo_mpi.o \
+	mo_namelist.o mo_physical_constants.o mo_random_numbers_cosp.o \
+	mo_time_control.o mo_time_event.o mo_tr_omp_decomposition.o
+mo_cosp_format_input.o: mo_cosp_array_lib.o mo_kind.o
+mo_cosp_isccp.o: mo_cosp_constants.o mo_cosp_types.o mo_kind.o
+mo_cosp_lidar.o: mo_cosp_constants.o mo_cosp_types.o mo_kind.o
+mo_cosp_llnl_precip.o: mo_kind.o
+mo_cosp_llnl_stats.o: mo_cosp_constants.o mo_kind.o
 mo_cosp_lmd_ipsl_stats.o: mo_cosp_llnl_stats.o mo_kind.o mo_memory_g3b.o
-mo_cosp_metoff_cosp.o: mo_cosp_constants.o mo_cosp_metoff_cosp_simulator.o \
-	mo_kind.o mo_random_numbers.o
-mo_cosp_metoff_cosp_simulator.o: mo_cosp_isccp_simulator.o mo_cosp_lidar.o \
-	mo_cosp_stats.o mo_kind.o
-mo_cosp_offline.o: mo_control.o mo_cosp_simulator.o mo_decomposition.o \
-	mo_diag_tendency_new.o mo_exception.o mo_filename.o mo_geoloc.o \
-	mo_kind.o mo_linked_list.o mo_memory_base.o mo_memory_cfdiag.o \
-	mo_memory_g1a.o mo_memory_g2a.o mo_memory_g3b.o mo_memory_gl.o \
+mo_cosp_math_lib.o: mo_cosp_array_lib.o mo_cosp_mrgrnk.o mo_kind.o
+mo_cosp_misr.o: mo_cosp_constants.o mo_cosp_types.o
+mo_cosp_modis.o: mo_cosp_constants.o mo_cosp_modis_simulator.o \
+	mo_cosp_types.o mo_kind.o
+mo_cosp_modis_simulator.o: mo_cosp_types.o mo_kind.o
+mo_cosp_mrgrnk.o: mo_kind.o
+mo_cosp_offline.o: mo_control.o mo_cosp_echam.o mo_decomposition.o \
+	mo_exception.o mo_filename.o mo_geoloc.o mo_kind.o mo_linked_list.o \
+	mo_memory_base.o mo_memory_g1a.o mo_memory_g3b.o mo_memory_gl.o \
 	mo_mpi.o mo_namelist.o mo_netcdf.o mo_time_control.o mo_time_event.o
-mo_cosp_simulator.o: mo_constants.o mo_cosp_constants.o mo_cosp_metoff_cosp.o \
-	mo_exception.o mo_kind.o mo_linked_list.o mo_memory_base.o mo_mpi.o \
-	mo_namelist.o mo_time_control.o mo_time_event.o \
-	mo_tr_omp_decomposition.o
+mo_cosp_optics_lib.o: mo_kind.o
+mo_cosp_radar.o: mo_cosp_array_lib.o mo_cosp_atmos_lib.o mo_cosp_constants.o \
+	mo_cosp_format_input.o mo_cosp_math_lib.o mo_cosp_mrgrnk.o \
+	mo_cosp_optics_lib.o mo_cosp_radar_simulator_types.o mo_cosp_types.o \
+	mo_cosp_utils.o mo_kind.o
+mo_cosp_radar_simulator_types.o: mo_kind.o
+# mo_cosp_rttov.o: mo_cosp_constants.o mo_cosp_types.o mo_kind.o
+# mo_cosp_rttov_const.o: mo_kind.o
+# mo_cosp_rttov_types.o: mo_cosp_rttov_const.o mo_kind.o
+mo_cosp_scale_LUTs_io.o: mo_cosp_radar_simulator_types.o
 mo_cosp_stats.o: mo_cosp_constants.o mo_cosp_llnl_stats.o \
-	mo_cosp_lmd_ipsl_stats.o mo_kind.o
+	mo_cosp_lmd_ipsl_stats.o mo_cosp_types.o mo_kind.o
+mo_cosp_types.o: mo_cosp_constants.o mo_cosp_radar_simulator_types.o \
+	mo_cosp_scale_LUTs_io.o mo_cosp_utils.o mo_kind.o
+mo_cosp_utils.o: mo_cosp_constants.o mo_kind.o
+mo_cosp_v1p4_cosp.o: mo_cosp_llnl_precip.o mo_cosp_modis_simulator.o \
+	mo_cosp_types.o mo_cosp_utils.o mo_cosp_v1p4_cosp_simulator.o \
+	mo_kind.o
+mo_cosp_v1p4_cosp_simulator.o: mo_cosp_constants.o mo_cosp_isccp.o \
+	mo_cosp_lidar.o mo_cosp_misr.o mo_cosp_modis.o mo_cosp_radar.o \
+	mo_cosp_stats.o mo_cosp_types.o mo_kind.o
 mo_couple.o: mo_co2.o mo_constants.o mo_control.o mo_decomposition.o \
 	mo_exception.o mo_gaussgrid.o mo_kind.o mo_memory_g3b.o mo_mpi.o \
 	mo_time_control.o mo_time_conversion.o mo_tr_gather.o mo_tr_scatter.o
@@ -493,7 +558,8 @@ mo_ham_species.o: mo_ham.o mo_ham_rad_data.o mo_kind.o mo_species.o \
 	mo_submodel.o mo_tracdef.o
 mo_ham_streams.o: mo_exception.o mo_filename.o mo_ham.o mo_ham_m7ctl.o \
 	mo_ham_rad_data.o mo_kind.o mo_linked_list.o mo_memory_base.o \
-	mo_param_switches.o mo_species.o mo_submodel_diag.o mo_tracer.o
+	mo_param_switches.o mo_species.o mo_submodel_diag.o mo_time_event.o \
+	mo_tracer.o
 mo_ham_tools.o: mo_constants.o mo_control.o mo_decomposition.o mo_exception.o \
 	mo_gaussgrid.o mo_ham_m7.o mo_ham_m7ctl.o mo_ham_streams.o mo_kind.o \
 	mo_radiation_parameters.o mo_test_trans.o mo_time_control.o \
@@ -624,6 +690,7 @@ mo_lrtm_setup.o: mo_kind.o mo_lrtm_coeffs.o mo_lrtm_kgs.o mo_lrtm_netcdf.o \
 mo_lrtm_taumol.o: mo_kind.o mo_lrtm_kgs.o parrrtm.o
 mo_lw_clop.o: mo_kind.o mo_parrrtm.o
 mo_machine.o: mo_exception.o mo_kind.o mo_mpi.o
+mo_math_constants.o: mo_kind.o
 mo_memory_base.o: mo_control.o mo_decomposition.o mo_exception.o \
 	mo_jsbach_comm_to_echam5mods.o mo_kind.o mo_linked_list.o mo_netcdf.o \
 	mo_time_control.o mo_time_event.o
@@ -638,13 +705,14 @@ mo_memory_g1b.o: mo_kind.o mo_linked_list.o mo_memory_base.o
 mo_memory_g2a.o: mo_kind.o mo_linked_list.o mo_memory_base.o mo_netcdf.o
 mo_memory_g2b.o: mo_kind.o mo_linked_list.o mo_memory_base.o
 mo_memory_g3a.o: mo_kind.o mo_memory_g3b.o
-mo_memory_g3b.o: mo_control.o mo_kind.o mo_linked_list.o mo_memory_base.o
+mo_memory_g3b.o: mo_control.o mo_kind.o mo_linked_list.o mo_memory_base.o \
+	mo_time_event.o
 mo_memory_gl.o: mo_filename.o mo_kind.o mo_linked_list.o mo_memory_base.o \
-	mo_netcdf.o mo_tracdef.o
+	mo_netcdf.o mo_time_event.o mo_tracdef.o
 mo_memory_ls.o: mo_kind.o mo_linked_list.o mo_memory_base.o
 mo_memory_sp.o: mo_kind.o mo_linked_list.o mo_memory_base.o
-mo_memory_streams.o: mo_buffer_fft.o mo_co2.o mo_control.o mo_cosp_offline.o \
-	mo_cosp_simulator.o mo_decomposition.o mo_diag_tendency_new.o \
+mo_memory_streams.o: mo_buffer_fft.o mo_co2.o mo_control.o mo_cosp_echam.o \
+	mo_cosp_offline.o mo_decomposition.o mo_diag_tendency_new.o \
 	mo_exception.o mo_filename.o mo_memory_base.o mo_memory_cfdiag.o \
 	mo_memory_f.o mo_memory_g1a.o mo_memory_g1b.o mo_memory_g2a.o \
 	mo_memory_g2b.o mo_memory_g3a.o mo_memory_g3b.o mo_memory_gl.o \
@@ -784,27 +852,31 @@ mo_output.o: mo_constants.o mo_control.o mo_decomposition.o mo_exception.o \
 	mo_linked_list.o mo_memory_base.o mo_mpi.o mo_netcdf.o \
 	mo_time_control.o mo_time_conversion.o mo_tr_gather.o mo_tracdef.o \
 	mo_util_string.o mo_version.o
+mo_param_switches.o: mo_kind.o
 mo_phenology.o: mo_exception.o mo_filename.o mo_jsbach.o mo_jsbach_grid.o \
 	mo_kind.o mo_linked_list.o mo_memory_base.o mo_mpi.o mo_netcdf.o \
 	mo_output.o mo_time_control.o mo_time_event.o mo_util_string.o
 mo_physc2.o: mo_kind.o
+mo_physical_constants.o: mo_kind.o
 mo_port_test.o: mo_linked_list.o mo_memory_base.o mo_time_event.o
 mo_rad_forcing_diag.o: mo_control.o mo_decomposition.o mo_kind.o \
 	mo_linked_list.o mo_memory_base.o mo_netcdf.o mo_parameters.o \
 	mo_time_event.o
 mo_radiation.o: mo_aero_kinne.o mo_aero_tanre.o mo_aero_volc.o \
 	mo_aero_volc_tab.o mo_cloud_optics.o mo_constants.o mo_control.o \
-	mo_convect_tables.o mo_cosp_simulator.o mo_echam5_sw.o mo_exception.o \
-	mo_geoloc.o mo_greenhouse_gases.o mo_hyb.o mo_kind.o mo_lrtm.o \
-	mo_lrtm_setup.o mo_memory_cfdiag.o mo_mpi.o mo_namelist.o \
+	mo_convect_tables.o mo_cosp_echam.o mo_cosp_offline.o mo_echam5_sw.o \
+	mo_exception.o mo_geoloc.o mo_greenhouse_gases.o mo_hyb.o mo_kind.o \
+	mo_lrtm.o mo_lrtm_setup.o mo_memory_cfdiag.o mo_mpi.o mo_namelist.o \
 	mo_newcld_optics.o mo_o3_lwb.o mo_o3clim.o mo_orbit.o \
 	mo_param_switches.o mo_parrrtm.o mo_radiation_forcing.o \
 	mo_radiation_parameters.o mo_solar_irradiance.o mo_srtm.o \
 	mo_srtm_config.o mo_submodel.o mo_submodel_interface.o mo_time_base.o \
 	mo_time_control.o $(INCLUDE)/radctl.inc
 mo_radiation_forcing.o: mo_constants.o mo_kind.o mo_linked_list.o \
-	mo_memory_base.o mo_radiation_parameters.o mo_time_control.o
+	mo_memory_base.o mo_radiation_parameters.o mo_time_control.o \
+	mo_time_event.o
 mo_radiation_parameters.o: mo_constants.o mo_kind.o mo_time_control.o
+mo_random_numbers_cosp.o: mo_kind.o
 mo_read_netcdf77.o: mo_exception.o mo_kind.o mo_netcdf.o
 mo_real_timer.o: mo_exception.o mo_kind.o mo_mpi.o mo_util_db_timings.o \
 	mo_util_string.o
@@ -966,7 +1038,7 @@ mo_zenith.o: mo_exception.o mo_io_units.o mo_jsbach_grid.o mo_kind.o mo_mpi.o \
 parrrtm.o: mo_kind.o
 pgrad.o: mo_control.o mo_hyb.o mo_kind.o
 physc.o: mo_activ.o mo_advection.o mo_cloud.o mo_co2.o mo_column.o \
-	mo_constants.o mo_control.o mo_cosp_offline.o mo_cosp_simulator.o \
+	mo_constants.o mo_control.o mo_cosp_echam.o mo_cosp_offline.o \
 	mo_decomposition.o mo_diag_amip2.o mo_diag_tendency.o \
 	mo_diag_tendency_new.o mo_geoloc.o mo_hyb.o mo_hydrology.o mo_kind.o \
 	mo_memory_cfdiag.o mo_memory_g1a.o mo_memory_g2a.o mo_memory_g3a.o \
@@ -978,7 +1050,7 @@ physc.o: mo_activ.o mo_advection.o mo_cloud.o mo_co2.o mo_column.o \
 	mo_tracdef.o mo_tropopause.o mo_vphysc.o
 pres.o: mo_control.o mo_hyb.o mo_kind.o
 presf.o: mo_control.o mo_kind.o
-radheat.o: mo_constants.o mo_control.o mo_cosp_simulator.o mo_diag_tendency.o \
+radheat.o: mo_constants.o mo_control.o mo_cosp_echam.o mo_diag_tendency.o \
 	mo_diag_tendency_new.o mo_heatingrates.o mo_kind.o mo_profile.o \
 	mo_radiation_forcing.o mo_radiation_parameters.o mo_submodel.o \
 	mo_submodel_interface.o mo_time_control.o mo_vphysc.o
@@ -990,14 +1062,14 @@ rrtm_setcoef_140gp.o: mo_kind.o mo_parrrtm.o mo_rrtrf.o
 rrtm_taumol_140gp.o: mo_kind.o mo_parrrtm.o mo_rrta_140gp.o mo_rrtbg2.o \
 	mo_rrtwn.o
 scan1.o: mo_advection.o mo_call_trans.o mo_co2.o mo_column.o mo_constants.o \
-	mo_control.o mo_decomposition.o mo_diag_amip2.o mo_diag_dynamics.o \
-	mo_diag_tendency.o mo_exception.o mo_geoloc.o mo_global_op.o \
-	mo_greenhouse_gases.o mo_hyb.o mo_kind.o mo_legendre.o \
+	mo_control.o mo_cosp_offline.o mo_decomposition.o mo_diag_amip2.o \
+	mo_diag_dynamics.o mo_diag_tendency.o mo_exception.o mo_geoloc.o \
+	mo_global_op.o mo_greenhouse_gases.o mo_hyb.o mo_kind.o mo_legendre.o \
 	mo_memory_g1a.o mo_memory_g1b.o mo_memory_g2a.o mo_memory_g2b.o \
 	mo_memory_g3b.o mo_memory_gl.o mo_memory_ls.o mo_mpi.o mo_port_test.o \
 	mo_radiation_parameters.o mo_scan_buffer.o mo_semi_lagrangian.o \
-	mo_spitfire.o mo_submodel.o mo_submodel_interface.o mo_test_trans.o \
-	mo_time_control.o mo_timer.o mo_tpcore.o mo_tracdef.o
+	mo_spitfire.o mo_station_diag.o mo_submodel.o mo_submodel_interface.o \
+	mo_test_trans.o mo_time_control.o mo_timer.o mo_tpcore.o mo_tracdef.o
 scan2.o: mo_call_trans.o
 sccd.o: mo_control.o mo_decomposition.o mo_diag_tendency.o mo_kind.o \
 	mo_memory_sp.o mo_tmp_buffer.o
@@ -1037,15 +1109,15 @@ srtm_kgb27.o: mo_kind.o mo_rrsw_kgs.o
 srtm_kgb28.o: mo_kind.o mo_rrsw_kgs.o
 srtm_kgb29.o: mo_kind.o mo_rrsw_kgs.o
 stepon.o: mo_aero_kinne.o mo_aero_volc.o mo_aero_volc_tab.o \
-	mo_boundary_condition.o mo_co2.o mo_control.o mo_cosp_offline.o \
-	mo_couple.o mo_decomposition.o mo_echam5_sw.o mo_exception.o \
-	mo_hdiff.o mo_hyb.o mo_hydrology.o mo_io.o mo_io_server.o \
-	mo_jsbach_interface.o mo_kind.o mo_memory_cfdiag.o mo_memory_f.o \
-	mo_memory_sp.o mo_nmi.o mo_nudging.o mo_nudging_buffer.o \
-	mo_nudging_init.o mo_nudging_sst.o mo_nudging_utils.o mo_o3clim.o \
-	mo_output.o mo_radiation.o mo_radiation_parameters.o mo_srtm_config.o \
-	mo_sst.o mo_station_diag.o mo_submodel.o mo_submodel_interface.o \
-	mo_time_control.o mo_timer.o mo_upper_sponge.o
+	mo_boundary_condition.o mo_co2.o mo_control.o mo_couple.o \
+	mo_decomposition.o mo_echam5_sw.o mo_exception.o mo_hdiff.o mo_hyb.o \
+	mo_hydrology.o mo_io.o mo_io_server.o mo_jsbach_interface.o mo_kind.o \
+	mo_memory_cfdiag.o mo_memory_f.o mo_memory_sp.o mo_nmi.o mo_nudging.o \
+	mo_nudging_buffer.o mo_nudging_init.o mo_nudging_sst.o \
+	mo_nudging_utils.o mo_o3clim.o mo_output.o mo_radiation.o \
+	mo_radiation_parameters.o mo_srtm_config.o mo_sst.o mo_submodel.o \
+	mo_submodel_interface.o mo_time_control.o mo_timer.o \
+	mo_upper_sponge.o
 su_rrtm.o: mo_rrtab.o
 subjob.o: mo_exception.o mo_filename.o mo_memory_base.o mo_mpi.o \
 	mo_time_control.o
diff --git a/src/cloud.f90 b/src/cloud.f90
index b20722a..9c67e41 100644
--- a/src/cloud.f90
+++ b/src/cloud.f90
@@ -164,13 +164,16 @@ USE mo_submodel_interface, ONLY: cloud_subm_2 !SF
 USE mo_submodel,       ONLY : lanysubmodel
 USE mo_vphysc,         ONLY : set_vphysc_var              
 
-USE mo_cosp_offline,   ONLY : locospoffl, cospoffl_lsrain, cospoffl_lssnow
+!USE mo_cosp_offline,   ONLY : locospoffl, cospoffl_lsrain, cospoffl_lssnow
 
 #ifdef _PROFILE
 USE mo_profile,        ONLY : trace_start, trace_stop
 #endif
 
 USE mo_timer,          ONLY : timer_start, timer_stop
+
+USE mo_memory_gl,      ONLY: aprlv, aprlv_na, aprsv, aprsv_na
+
 !
   IMPLICIT NONE
 !
@@ -1563,6 +1566,14 @@ USE mo_timer,          ONLY : timer_start, timer_stop
            
            zrfl(jl)    = zrfl(jl)+zzdrr-zcons2*zdp(jl)*zevp(jl)
            zsfl(jl)    = zsfl(jl)+zzdrs-zcons2*zdp(jl)*zsub(jl)
+           
+           ! accumulated quantities
+           aprlv(jl,jk,krow) = aprlv(jl,jk,krow) + zdtime * zrfl(jl)
+           aprsv(jl,jk,krow) = aprsv(jl,jk,krow) + zdtime * zsfl(jl)
+           ! instantaneous quantities
+           aprlv_na(jl,jk,krow) = zrfl(jl)
+           aprsv_na(jl,jk,krow) = zsfl(jl)
+           
         END DO
 
      ELSE
@@ -1615,6 +1626,11 @@ USE mo_timer,          ONLY : timer_start, timer_stop
 
            zrfl(jl)       = zrfl(jl)+zzdrr-zcons2*zdp(jl)*zevp(jl)
            zsfl(jl)       = zsfl(jl)+zzdrs-zcons2*zdp(jl)*zsub(jl)
+
+           aprlv(jl,jk,krow) = aprlv(jl,jk,krow) + zdtime * zrfl(jl)
+           aprsv(jl,jk,krow) = aprsv(jl,jk,krow) + zdtime * zsfl(jl)
+           aprlv_na(jl,jk,krow) = zrfl(jl)
+           aprsv_na(jl,jk,krow) = zsfl(jl)
         END DO
         
      END IF
@@ -1784,12 +1800,12 @@ USE mo_timer,          ONLY : timer_start, timer_stop
 !
 821  END DO
 !
-        IF ( locospoffl ) THEN 
-          DO jl = 1,kproma    
-            cospoffl_lsrain(jl,jk,krow) = zrfl(jl)
-            cospoffl_lssnow(jl,jk,krow) = zsfl(jl)
-           END DO
-        END IF
+        ! IF ( locospoffl ) THEN 
+        !   DO jl = 1,kproma    
+        !     cospoffl_lsrain(jl,jk,krow) = zrfl(jl)
+        !     cospoffl_lssnow(jl,jk,krow) = zsfl(jl)
+        !    END DO
+        ! END IF
 
 
 #ifdef _PROFILE
diff --git a/src/cloud_cdnc_icnc.f90 b/src/cloud_cdnc_icnc.f90
index 806e588..458985d 100644
--- a/src/cloud_cdnc_icnc.f90
+++ b/src/cloud_cdnc_icnc.f90
@@ -101,27 +101,30 @@ USE mo_constants,      ONLY : cpd, vtmpc2, g, rd, alv, als, rv, api    &
 USE mo_convect_tables, ONLY : lookuperror, lookupoverflow, jptlucu1    &
                             , jptlucu2, tlucua, tlucub, tlucuaw
 USE mo_param_switches, ONLY : lcover, nauto, ncvmicro, &   !++mgs
-                              ncd_activ, nic_cirrus, lorocirrus, lsecprod
+                              lcdnc_act_only, &
+                              lcdnc_clim, cdnc_clim, &
+                              ncd_activ, nic_cirrus, lorocirrus, lsecprod, lconv
 USE mo_cloud,          ONLY : cqtmin, cvtfall, crhosno, cn0s           &
                             , cthomi, ncctop, cvarmin                  &
                             , cbeta_pq, cbeta_pq_max, nbetaq, cbetaqs  &
                             , rbetak, nbetax, tbetai0, tbetai1         &
                             , clmax, clmin, jbmin, jbmax, lonacc       &
-                            , ccraut, ceffmin, ceffmax, crhoi, ccsaut  &
+                            , ccraut, ccauloc, creth, cautalpha, cautbeta &
+                            , ceffmin, ceffmax, crhoi, ccsaut  &
                             , cbeta_cs, ccwmin
 USE mo_kind,           ONLY : dp
 USE mo_time_control,   ONLY : delta_time, time_step_len
 USE mo_vphysc,         ONLY : set_vphysc_var      !++mgs
 USE mo_activ,          ONLY : swat,            &
                               qnuc, qaut, qacc, qfre, qmel,            &
-                              cdnc_acc, lwc_acc, cloud_time, cloud_tm1,&
+                              cdnc_acc, cdnc_inst, lwc_acc, cloud_time, cloud_tm1,&
                               cdnc_burden_acc, reffl_acc, burden_time, &
                               icnc_burden_acc, reffi_acc, icnc_acc,    &
                               cliwc_time, burdic_time, iwc_acc,        &
                               cdnc_burden, icnc_burden, cdnc, icnc,    &
                               sice, reffl_ct, reffl_time, cdnc_ct,     &
                               reffi_tovs, reffi_time, iwp_tovs,        &
-                              idt_cdnc, idt_icnc, nfrzmod, reffl, reffi              
+                              idt_cdnc, idt_icnc, nfrzmod, reffl, reffi, clcaux
 USE mo_conv,           ONLY : cdncact_cv,     &
                               lwc_conv, iwc_conv, conv_time, twc_conv,      &
                               cdnc_conv, icnc_conv, conv_ice_time,          &
@@ -139,8 +142,24 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
    USE mo_memory_g3b,      ONLY: orostd,oromea,orogam,orothe, &
                                  oropic,oroval,orosig
    USE mo_orocirrus,       ONLY: orocirrus_w, orocirrus_cc
-!<<gf
+   !<<gf
+   USE mo_memory_gl,      ONLY: aprlv, aprlv_na, aprsv, aprsv_na, &
+        reffl_pre_na, reffl_post_na, &
+        cdnc_pre_na, cdnc_post_na, &
+        xl_pre_na, xl_post_na, &
+        autoconv_na, acc1_na, acc2_na, &
+        xrl_na, xsl_na
+   USE mo_memory_g3b,     ONLY: aprl_na, aprs_na, xivi_na, xlvi_na, clcpre
+
+! get data to mo_cosp_offline
+   USE mo_cosp_offline,   ONLY : locospoffl, cospoffl_lsrain, cospoffl_lssnow, &
+                                 cospoffl_icnc, cospoffl_cdnc        
+   USE mo_cosp_echam,         ONLY : locosp, cosp_lsrain, cosp_lssnow
 
+
+   
+
+   
   IMPLICIT NONE
 
 !--- Arguments
@@ -579,7 +598,7 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
   g_rcp      = 1._dp / g
   zcons1     = cpd*vtmpc2
   zcons2     = ztmst_rcp * g_rcp
-  zexm1_1    = 2.47_dp-1.0_dp
+  zexm1_1    = cautalpha - 1.0_dp
   zexp_1     = -1._dp / zexm1_1
   zexm1_2    = 4.7_dp-1.0_dp
   zexp_2     = -1._dp / zexm1_2
@@ -818,6 +837,12 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
                          (paclc(1:kproma,:)      >  cloud_tm1(1:kproma,:,jrow)) .OR.        &
                          (zsusatw_2d(1:kproma,:) >  zeps)                     )
 
+  if (lcdnc_act_only) then
+     ! CDNC are not carried from time step to time step, only produced
+     ! by activation (and vanished at the end of the time step)
+     zcdnc(1:kproma,:) = 0._dp
+  end if
+  
   !SF: first computes newly formed cloud droplets at cloud bases:
   ztmp(1:kproma,:)   = zcdncact(1:kproma,:) - zcdnc(1:kproma,:) 
   ztmp(1:kproma,:)   = MAX(0._dp, ztmp(1:kproma,:))
@@ -950,12 +975,19 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 
      DO jk=ktdia,klev
         DO jl=1,kproma
-           jkk = iclbas(jl,jk)
-           jkk = MAX(1, jkk) !SF prevents cases where iclbas=0
-           ztmp2(jl,jk) = zqlnuccvh(jl,jkk) 
+           IF (lconv) THEN
+              jkk = iclbas(jl,jk)
+              jkk = MAX(1, jkk) !SF prevents cases where iclbas=0
+              ! if (jkk /= 1) then
+              !    write(*,*) 'jl = ',  jl, ' jkk = ', jkk
+              ! end if
+              ztmp2(jl,jk) = zqlnuccvh(jl,jkk) 
+           ELSE
+              ztmp2(jl,jk) = 0._dp ! jmu no convective activation if lconv is .false.
+           END IF
         ENDDO
      ENDDO
-
+        
      ztmp(1:kproma,:) = MIN(ztmp1(1:kproma,:),ztmp2(1:kproma,:))
      ztmp(1:kproma,:) = MAX(0._dp,ztmp(1:kproma,:))
 
@@ -2233,7 +2265,7 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 !ham_ps: cdir circumvents bug in sxf90 compiler
 
         zclcstar_1d(1:kproma) = MIN(zclcaux(1:kproma), zclcpre(1:kproma))
-        zauloc_1d(1:kproma)   = 3./5000._dp*zdz_2d(1:kproma,jk)
+        zauloc_1d(1:kproma)   = 3._dp/5000._dp*zdz_2d(1:kproma,jk)
         zauloc_1d(1:kproma)   = MAX(MIN(zauloc_1d(1:kproma), clmax), clmin)
 
         ll1_1d(1:kproma) = (knvb(1:kproma) >= jbmin) .AND. &
@@ -2269,6 +2301,9 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
        zxrp1_1d(1:kproma) = MERGE(ztmp1_1d(1:kproma), 0._dp, ll2_1d(1:kproma))
        zxsp1_1d(1:kproma) = MERGE(ztmp2_1d(1:kproma), 0._dp, ll3_1d(1:kproma))
 
+       xrl_na(1:kproma,jk,jrow) = zxrp1_1d(1:kproma)
+       xsl_na(1:kproma,jk,jrow) = zxsp1_1d(1:kproma)
+
 !
 !       7.1   Warm clouds: Coalescence processes after Beheng (1994):
 !             Autoconversion of cloud droplets and collection of cloud
@@ -2283,7 +2318,13 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
         IF (nauto == 2) THEN
 !          Autoconversion rate from Khairoutdinov and Kogan, 2000
 
-           ztmp1_1d(1:kproma) = ccraut*1350._dp*(1.e-6_dp*zcdnc(1:kproma,jk))**(-1.79_dp)
+           if (lcdnc_clim) then
+              ! with this switch on, the KK2000 autoconversion sees a constant CDNC (cdnc_clim)
+              ztmp1_1d(1:kproma) = ccraut*1350._dp*(1.e-6_dp*cdnc_clim)**(cautbeta)
+           else 
+              ztmp1_1d(1:kproma) = ccraut*1350._dp*(1.e-6_dp*zcdnc(1:kproma,jk))**(cautbeta)
+           end if
+
      
            ztmp1_1d(1:kproma) = zxlb(1:kproma) * (  1._dp &
                                    - (1._dp + ztmst*zexm1_1*ztmp1_1d(1:kproma)*zxlb(1:kproma)**zexm1_1)**zexp_1)
@@ -2291,6 +2332,19 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
            ztmp1_1d(1:kproma) = MIN(zxlb(1:kproma), ztmp1_1d(1:kproma))
            zraut_1d(1:kproma) = MERGE(ztmp1_1d(1:kproma), 0._dp, ll1_1d(1:kproma))
            
+           ! pre-compute reff so we can implement a threshold
+           ztmp1_1d(1:kproma)  = 0.00045e-6_dp*zcdnc(1:kproma,jk) + 1.18_dp !SF zkap
+           zreffl_1d(1:kproma) = 1.E6_dp*ztmp1_1d(1:kproma)                                          &   
+                * ( (3._dp/(4._dp*api*rhoh2o)) * zxlb(1:kproma)                       &
+                * zrho(1:kproma,jk) / zcdnc(1:kproma,jk)           )**(1._dp/3._dp) !SF zreffl
+           ! apply threshold
+           zraut_1d(1:kproma) = MERGE(zraut_1d(1:kproma), 0._dp, &
+                ll1_1d(1:kproma) .AND. (zreffl_1d(1:kproma) > creth))
+           reffl_pre_na(1:kproma,jk,krow) = MERGE(zreffl_1d(1:kproma), 0._dp, &
+                (zxlb(1:kproma)     >  zeps) .AND. (zcdnc(1:kproma,jk) >= zcdnmin))
+
+
+           xl_pre_na(1:kproma,jk,jrow) = zxlb(1:kproma)
            ztmp1_1d(1:kproma) = zxlb(1:kproma) - zraut_1d(1:kproma)
            ztmp2_1d(1:kproma) = zxlb(1:kproma) !SF keeps zxlb for later use
            zxlb(1:kproma)     = MERGE(ztmp1_1d(1:kproma), zxlb(1:kproma), ll1_1d(1:kproma))
@@ -2298,19 +2352,20 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 !--- zrac1 is formed by accretion with rain from above
 !--- zrac2 is formed by accretion with newly formed rain inside the grid box
 
-           ztmp1_1d(1:kproma) = -3.7_dp*ztmst*zxrp1_1d(1:kproma)
+           ztmp1_1d(1:kproma) = -3.7_dp*ztmst*zxrp1_1d(1:kproma) * ccauloc
            ztmp1_1d(1:kproma) = EXP(ztmp1_1d(1:kproma))
            ztmp1_1d(1:kproma) = zxlb(1:kproma)*(1._dp-ztmp1_1d(1:kproma))
-           zrac1_1d(1:kproma) = MERGE(ztmp1_1d(1:kproma), 0._dp, ll1_1d(1:kproma))
+           zrac1_1d(1:kproma) = MERGE(ztmp1_1d(1:kproma), 0._dp, ll1_1d(1:kproma)) 
 
            zxlb(1:kproma) = zxlb(1:kproma) - zrac1_1d(1:kproma)
 
-           ztmp1_1d(1:kproma) = -3.7_dp*ztmst*zauloc_1d(1:kproma)*zrho(1:kproma,jk)*zraut_1d(1:kproma)
+           ztmp1_1d(1:kproma) = -3.7_dp*ztmst*zauloc_1d(1:kproma)*zrho(1:kproma,jk)*zraut_1d(1:kproma) * ccauloc
            ztmp1_1d(1:kproma) = MERGE(ztmp1_1d(1:kproma), 0._dp, ll1_1d(1:kproma))
            ztmp1_1d(1:kproma) = zxlb(1:kproma)*(1._dp-EXP(ztmp1_1d(1:kproma)))
            zrac2_1d(1:kproma) = MERGE(ztmp1_1d(1:kproma), 0._dp, ll1_1d(1:kproma))
 
            zxlb(1:kproma) = zxlb(1:kproma) - zrac2_1d(1:kproma)
+           xl_post_na(1:kproma,jk,krow) = zxlb(1:kproma)
 
            zrpr(1:kproma) = zrpr(1:kproma) + zclcaux(1:kproma)     * (zraut_1d(1:kproma)+zrac2_1d(1:kproma)) &
                              + zclcstar_1d(1:kproma) *  zrac1_1d(1:kproma)
@@ -2337,7 +2392,9 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 
            ztmp1_1d(1:kproma) = zcdnc(1:kproma,jk)-zrprn(1:kproma)
            ztmp1_1d(1:kproma) = MAX(ztmp1_1d(1:kproma), cqtmin)
+           cdnc_pre_na(1:kproma,jk,krow) = zcdnc(1:kproma,jk)
            zcdnc(1:kproma,jk) = MERGE(ztmp1_1d(1:kproma), zcdnc(1:kproma,jk), ll1_1d(1:kproma))
+           cdnc_post_na(1:kproma,jk,krow) = zcdnc(1:kproma,jk)
 
 !--- End included alternative autoconversion parameterisation ----------
 !--- Changed for alternative autoconversion parameterisation -----------
@@ -2357,7 +2414,7 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
                                    - (1._dp + ztmst*zexm1_2*zraut_1d(1:kproma)*zxlb(1:kproma)**zexm1_2)**zexp_2)
 
            zraut_1d(1:kproma) = MIN(zxlb(1:kproma), zraut_1d(1:kproma))
-  
+
 !--- Included for prognostic CDNC/IC scheme ----------------------------
            ztmp1_1d(1:kproma) = 7.7e9_dp * zraut_1d(1:kproma) * zrho(1:kproma,jk)                      !SF zrautn
            ztmp2_1d(1:kproma) = 1.289e10_dp * 1.e-6_dp * ztmst * (zrho(1:kproma,jk)*zxlb(1:kproma))**2 !SF zself (1.e-6 comes
@@ -2372,6 +2429,7 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 
 !--- End included for CDNC/IC scheme -----------------------------------
 
+           xl_pre_na(1:kproma,jk,krow) = zxlb(1:kproma)
            ztmp1_1d(1:kproma) = zxlb(1:kproma) - zraut_1d(1:kproma)
            zxlb(1:kproma)     = MERGE(ztmp1_1d(1:kproma), zxlb(1:kproma), ll1_1d(1:kproma))
 !
@@ -2397,6 +2455,8 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
                                  + zclcstar_1d(1:kproma) * zrac1_1d(1:kproma)
            zrpr(1:kproma)     = MERGE(ztmp1_1d(1:kproma), zrpr(1:kproma), ll1_1d(1:kproma))
 
+           xl_post_na(1:kproma,jk,krow) = zxlb(1:kproma)
+
 !--- for in-cloud scavenging
            ztmp1_1d(1:kproma)    = zraut_1d(1:kproma) + zrac1_1d(1:kproma) + zrac2_1d(1:kproma)
            zmratepr(1:kproma,jk) = MERGE(ztmp1_1d(1:kproma), zmratepr(1:kproma,jk), ll1_1d(1:kproma)) 
@@ -2409,8 +2469,11 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 
            ztmp2_1d(1:kproma) = zcdnc(1:kproma,jk)-ztmp1_1d(1:kproma)
            ztmp2_1d(1:kproma) = MAX(ztmp2_1d(1:kproma), cqtmin)
+           cdnc_pre_na(1:kproma,jk,krow) = zcdnc(1:kproma,jk)
            zcdnc(1:kproma,jk) = MERGE(ztmp2_1d(1:kproma), zcdnc(1:kproma,jk), ll1_1d(1:kproma))
+           cdnc_post_na(1:kproma,jk,krow) = zcdnc(1:kproma,jk)
 
+           
            ztmp2_1d(1:kproma) = zrautself_1d(1:kproma) + ztmp1_1d(1:kproma)
            zrprn(1:kproma)    = MERGE(ztmp2_1d(1:kproma), zrprn(1:kproma), ll1_1d(1:kproma))
 !--- End included for CDNC/IC scheme -----------------------------------
@@ -2760,6 +2823,18 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
         zrfl(1:kproma)       = zrfl(1:kproma)+zzdrr_1d(1:kproma)-zcons2*zdp_2d(1:kproma,jk)*zevp(1:kproma)
         zsfl(1:kproma)       = zsfl(1:kproma)+zzdrs_1d(1:kproma)-zcons2*zdp_2d(1:kproma,jk)*zsub(1:kproma)
 
+        ! accumulated quantities
+        aprlv(1:kproma,jk,krow) = aprlv(1:kproma,jk,krow) + zdtime * zrfl(1:kproma)
+        aprsv(1:kproma,jk,krow) = aprsv(1:kproma,jk,krow) + zdtime * zsfl(1:kproma)
+        ! instantaneous quantities
+        aprlv_na(1:kproma,jk,krow) = zrfl(1:kproma)
+        aprsv_na(1:kproma,jk,krow) = zsfl(1:kproma)
+        ! diagnostoc quantities
+        autoconv_na(1:kproma,jk,krow) = zraut_1d(1:kproma)
+        acc1_na(1:kproma,jk,krow) = zrac1_1d(1:kproma)
+        acc2_na(1:kproma,jk,krow) = zrac2_1d(1:kproma)
+        
+
 !
 !     ------------------------------------------------------------------
 !       8.    Updating tendencies of t, q, xl, xi and final cloud cover
@@ -2915,10 +2990,16 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
         !---- CDNC and burden averaged over cloudy and cloud-free periods
         ztmp1_1d(1:kproma)     = cdnc(1:kproma,jk,jrow) + zdtime*zcdnc(1:kproma,jk)*zclcaux(1:kproma)
         cdnc(1:kproma,jk,jrow) = MERGE(ztmp1_1d(1:kproma), cdnc(1:kproma,jk,jrow), ll1_1d(1:kproma))
+        cdnc_inst(1:kproma,jk,jrow) = MERGE(zcdnc(1:kproma,jk), 0._dp, ll1_1d(1:kproma))
+        clcaux(1:kproma,jk,jrow)    = MERGE(zclcaux(1:kproma), 0._dp, ll1_1d(1:kproma))
 
         ztmp1_1d(1:kproma) = cdnc_burden(1:kproma,jrow) + zdtime*zcdnc(1:kproma,jk)*zdz_2d(1:kproma,jk)*zclcaux(1:kproma)
         cdnc_burden(1:kproma,jrow) = MERGE(ztmp1_1d(1:kproma), cdnc_burden(1:kproma,jrow), ll1_1d(1:kproma))
 
+        IF ( locospoffl ) THEN 
+           cospoffl_cdnc(1:kproma,jk,krow) = MERGE(zcdnc(1:kproma,jk), 0.0_dp, ll1_1d(1:kproma))
+        END IF
+
         !--- In-cloud effective radius [um]:
         ztmp1_1d(1:kproma)  = 0.00045e-6_dp*zcdnc(1:kproma,jk) + 1.18_dp !SF zkap
         zreffl_1d(1:kproma) = 1.E6_dp*ztmp1_1d(1:kproma)                                          &   
@@ -2926,6 +3007,9 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
                               * zrho(1:kproma,jk) / zcdnc(1:kproma,jk)           )**(1._dp/3._dp) !SF zreffl
 
         reffl(1:kproma,jk,jrow) = MERGE(zreffl_1d(1:kproma), 0._dp, ll1_1d(1:kproma)) !SF #217
+        reffl_post_na(1:kproma,jk,jrow) = zreffl_1d(1:kproma)
+        ! seems like a swell thing to have in the rain stream
+        ! reff_na(1:kproma,jk,krow) = reffl(1:kproma,jk,jrow)
 
         ztmp2_1d(1:kproma) = reffl_acc(1:kproma,jk,jrow) + zdtime*zreffl_1d(1:kproma)
         reffl_acc(1:kproma,jk,jrow) = MERGE(ztmp2_1d(1:kproma), reffl_acc(1:kproma,jk,jrow), ll1_1d(1:kproma))
@@ -3011,6 +3095,10 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
         ztmp1_1d(1:kproma)     = icnc(1:kproma,jk,jrow) + zdtime*picnc(1:kproma,jk)*zclcaux(1:kproma)
         icnc(1:kproma,jk,jrow) = MERGE(ztmp1_1d(1:kproma), icnc(1:kproma,jk,jrow), ll2_1d(1:kproma))
 
+        IF ( locospoffl ) THEN 
+           cospoffl_icnc(1:kproma,jk,krow) = MERGE(picnc(1:kproma,jk), 0.0_dp, ll2_1d(1:kproma))
+        END IF
+
         ztmp1_1d(1:kproma) = icnc_burden(1:kproma,jrow) + zdtime*picnc(1:kproma,jk) &
                                                          *zdz_2d(1:kproma,jk)*zclcaux(1:kproma)
         icnc_burden(1:kproma,jrow) = MERGE(ztmp1_1d(1:kproma), icnc_burden(1:kproma,jrow), ll2_1d(1:kproma))  
@@ -3049,6 +3137,16 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
 !SF for scavenging: create a 2d array of clcpre:
         zclcpre_2d(1:kproma,jk) = zclcpre(1:kproma)
 
+        IF ( locospoffl ) THEN 
+           cospoffl_lsrain(1:kproma,jk,krow) = zrfl(1:kproma)
+           cospoffl_lssnow(1:kproma,jk,krow) = zsfl(1:kproma)
+        END IF
+
+        IF ( locosp ) THEN 
+           cosp_lsrain(1:kproma,jk,krow) = zrfl(1:kproma)
+           cosp_lssnow(1:kproma,jk,krow) = zsfl(1:kproma)
+        END IF
+
 831 END DO    ! Vertical loop
 !
 !--- Included for prognostic CDNC/IC scheme ----------------------------
@@ -3106,6 +3204,10 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
    paprl(1:kproma) = paprl(1:kproma) + zdtime*(prsfl(1:kproma)+pssfl(1:kproma))
    paprs(1:kproma) = paprs(1:kproma) + zdtime*pssfl(1:kproma)
 
+   clcpre(1:kproma,krow) = zclcpre(1:kproma)
+   aprl_na(1:kproma,krow) = prsfl(1:kproma)+pssfl(1:kproma)
+   aprs_na(1:kproma,krow) = pssfl(1:kproma)
+
 !--- save stratiform precipitation for dust emissions
    CALL set_vphysc_var(kproma, -1, krow, prflstrat=prsfl, psflstrat=pssfl)
 !
@@ -3140,6 +3242,9 @@ USE mo_submodel_interface, ONLY: cloud_subm_1, cloud_subm_2
     pxlvi(1:kproma) = pxlvi(1:kproma) + zdtime*zxlvi(1:kproma)
     pxivi(1:kproma) = pxivi(1:kproma) + zdtime*zxivi(1:kproma)
 
+    xlvi_na(1:kproma,krow) = zxlvi(1:kproma)
+    xivi_na(1:kproma,krow) = zxivi(1:kproma)
+
 !
   RETURN
 END SUBROUTINE cloud_cdnc_icnc
diff --git a/src/control.f90 b/src/control.f90
index 67060ca..7955389 100644
--- a/src/control.f90
+++ b/src/control.f90
@@ -126,6 +126,7 @@ SUBROUTINE control
 
   USE mo_station_diag,    ONLY: lostation, init_station_diag
   USE mo_cosp_offline,    ONLY: locospoffl, init_cosp_offline
+ 
 
 #ifdef _OPENMP
   USE omp_lib,            ONLY: omp_get_num_threads
diff --git a/src/cosp_lidar_simulator.f90 b/src/cosp_lidar_simulator.f90
index 17b632c..30a07e2 100644
--- a/src/cosp_lidar_simulator.f90
+++ b/src/cosp_lidar_simulator.f90
@@ -1,10 +1,34 @@
-subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
+! Copyright (c) 2009, Centre National de la Recherche Scientifique
+! All rights reserved.
+! $Revision: 88 $, $Date: 2013-11-13 15:08:38 +0100 (Mi, 13. Nov 2013) $
+! $URL: http://cfmip-obs-sim.googlecode.com/svn/stable/v1.4.0/actsim/lidar_simulator.F90 $
+! 
+! Redistribution and use in source and binary forms, with or without modification, are permitted 
+! provided that the following conditions are met:
+! 
+!     * Redistributions of source code must retain the above copyright notice, this list 
+!       of conditions and the following disclaimer.
+!     * Redistributions in binary form must reproduce the above copyright notice, this list
+!       of conditions and the following disclaimer in the documentation and/or other materials 
+!       provided with the distribution.
+!     * Neither the name of the LMD/IPSL/CNRS/UPMC nor the names of its
+!       contributors may be used to endorse or promote products derived from this software without 
+!       specific prior written permission.
+! 
+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
+! IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
+! FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
+! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
+! IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
+! OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  subroutine cosp_lidar_simulator(npoints, nlev, npart, nrefl, undef &
                 , pres, presf, temp &
-                , q_lsliq, q_lsice  &
-                , ls_radliq, ls_radice  &
-!!                , frac_out, ice_type &
-                , ice_type &
-                , pmol, pnorm, tautot, refl ) ! parasol
+                , q_lsliq, q_lsice, q_cvliq, q_cvice  & 
+                , ls_radliq, ls_radice, cv_radliq, cv_radice & 
+                , ice_type, pmol, pnorm, pnorm_perp_tot, tautot, refl)
 
 !---------------------------------------------------------------------------------
 ! Purpose: To compute lidar signal from model-simulated profiles of cloud water
@@ -40,28 +64,53 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
 !      depolarisation diagnostic removed
 !      parasol (polder) reflectances (for 5 different solar zenith angles) added
 !
+! December 2008, S. Bony,  H. Chepfer and J-L. Dufresne : 
+! - Modification of the integration of the lidar equation.
+! - change the cloud detection threshold
+!
+! April 2008, A. Bodas-Salcedo:
+! - Bug fix in computation of pmol and pnorm of upper layer
+!
+! April 2008, J-L. Dufresne
+! - Bug fix in computation of pmol and pnorm, thanks to Masaki Satoh: a factor 2 
+! was missing. This affects the ATB values but not the cloud fraction. 
+!
+! January 2013, G. Cesana and H. Chepfer:
+! - Add the perpendicular component of the backscattered signal (pnorm_perp_tot) in the arguments
+! - Add the temperature for each levels (temp) in the arguments
+! - Add the computation of the perpendicular component of the backscattered lidar signal 
+! Reference: Cesana G. and H. Chepfer (2013): Evaluation of the cloud water phase
+! in a climate model using CALIPSO-GOCCP, J. Geophys. Res., doi: 10.1002/jgrd.50376
+!
+!---------------------------------------------------------------------------------
+!
 ! Inputs:
 !  npoints  : number of horizontal points
 !  nlev : number of vertical levels
 !  npart: numberb of cloud meteors (stratiform_liq, stratiform_ice, conv_liq, conv_ice). 
 !        Currently npart must be 4
-!  nrefl: number of solar zenith angles for parasol reflectances ! parasol
+!  nrefl: number of solar zenith angles for parasol reflectances
 !  pres : pressure in the middle of atmospheric layers (full levels): Pa
 !  presf: pressure in the interface of atmospheric layers (half levels): Pa
 !     presf(..,1) : surface pressure ; presf(..,nlev+1)= TOA pressure
 !  temp : temperature of atmospheric layers: K
 !  q_lsliq: LS sub-column liquid water mixing ratio (kg/kg)
 !  q_lsice: LS sub-column ice water mixing ratio (kg/kg)
+!  q_cvliq: CONV sub-column liquid water mixing ratio (kg/kg)
+!  q_cvice: CONV sub-column ice water mixing ratio (kg/kg)
 !  ls_radliq: effective radius of LS liquid particles (meters)
 !  ls_radice: effective radius of LS ice particles (meters)
-!  frac_out: cloud cover in each sub-column of the gridbox (output from scops)
-!  ice_type : ice particle shape hypothesis (ice_type=0 for spheres, ice_type=1 for non spherical particles)
+!  cv_radliq: effective radius of CONV liquid particles (meters)
+!  cv_radice: effective radius of CONV ice particles (meters)
+!  ice_type : ice particle shape hypothesis (ice_type=0 for spheres, ice_type=1 
+!             for non spherical particles)
 !
 ! Outputs:
 !  pmol : molecular attenuated backscatter lidar signal power (m^-1.sr^-1)
 !  pnorm: total attenuated backscatter lidar signal power (m^-1.sr^-1)
+!  pnorm_perp_tot: perpendicular attenuated backscatter lidar signal power (m^-1.sr^-1)
 !  tautot: optical thickess integrated from top to level z
-!  refl : parasol(polder) reflectance ! parasol
+!  refl : parasol(polder) reflectance
 !
 ! Version 1.0 (June 2007)
 ! Version 1.1 (May 2008)
@@ -70,76 +119,131 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
 ! Version 2.1 (December 2008)
 !---------------------------------------------------------------------------------
 
-   USE mo_constants,    ONLY: g, rd, api       ! Gravitational acceleration, dry air constant, pi
-   USE mo_kind,         ONLY: dp
+   USE mo_math_constants, ONLY: pi       ! pi
+   USE mo_kind,           ONLY: wp
 
       IMPLICIT NONE
+      REAL(wp) :: SRsat
+      PARAMETER (SRsat = 0.01_wp) ! threshold full attenuation 
 
       LOGICAL ok_parasol
       PARAMETER (ok_parasol=.true.)  ! set to .true. if you want to activate parasol reflectances
-                                     ! (caution: routine "parasol" not vectorized for the moment)
 
       INTEGER i, k
       
-      INTEGER INDX_LSLIQ,INDX_LSICE
-      PARAMETER (INDX_LSLIQ=1,INDX_LSICE=2)
+      INTEGER INDX_LSLIQ,INDX_LSICE,INDX_CVLIQ,INDX_CVICE
+      PARAMETER (INDX_LSLIQ=1,INDX_LSICE=2,INDX_CVLIQ=3,INDX_CVICE=4)
+
 ! inputs:
       INTEGER npoints,nlev,npart,ice_type
       INTEGER nrefl ! parasol
-      REAL(dp) ::  pres(npoints,nlev)    ! pressure full levels
-      REAL(dp) ::  presf(npoints,nlev+1) ! pressure half levels
-      REAL(dp) ::  temp(npoints,nlev)
-      REAL(dp) ::  q_lsliq(npoints,nlev), q_lsice(npoints,nlev)
-      REAL(dp) ::  ls_radliq(npoints,nlev), ls_radice(npoints,nlev)
-!!      REAL(dp) ::  frac_out(npoints,nlev)
+      REAL(wp) ::  undef                 ! undefined value ! parasol
+      REAL(wp) ::  pres(npoints,nlev)    ! pressure full levels
+      REAL(wp) ::  presf(npoints,nlev+1) ! pressure half levels
+      REAL(wp) ::  temp(npoints,nlev)
+      REAL(wp) ::  q_lsliq(npoints,nlev), q_lsice(npoints,nlev)
+      REAL(wp) ::  q_cvliq(npoints,nlev), q_cvice(npoints,nlev)
+      REAL(wp) ::  ls_radliq(npoints,nlev), ls_radice(npoints,nlev)
+      REAL(wp) ::  cv_radliq(npoints,nlev), cv_radice(npoints,nlev)
+
 
 ! outputs (for each subcolumn):
 
-      REAL(dp) ::  pmol(npoints,nlev)  ! molecular backscatter signal power (m^-1.sr^-1)
-      REAL(dp) ::  pnorm(npoints,nlev) ! total lidar backscatter signal power (m^-1.sr^-1)
-      REAL(dp) ::  tautot(npoints,nlev)! optical thickess integrated from top
-      REAL(dp) ::  refl(npoints,nrefl)! parasol reflectance ! parasol
+      REAL(wp) ::  pmol(npoints,nlev)  ! molecular backscatter signal power (m^-1.sr^-1)
+      REAL(wp) ::  pnorm(npoints,nlev) ! total lidar backscatter signal power (m^-1.sr^-1)
+      REAL(wp) ::  tautot(npoints,nlev)! optical thickess integrated from top
+      REAL(wp) ::  refl(npoints,nrefl) ! parasol reflectance ! parasol
 
 ! actsim variables:
 
-      REAL(dp) ::  km, rdiffm, Qscat, Cmol
-      PARAMETER (Cmol = 6.2446e-32_dp) ! depends on wavelength
-      PARAMETER (km = 1.38e-23_dp)     ! Boltzmann constant (J/K)
+      REAL(wp) ::  km, rdiffm, Qscat, Cmol
+      PARAMETER (Cmol = 6.2446e-32_wp) ! depends on wavelength
+      PARAMETER (km = 1.38e-23_wp)     ! Boltzmann constant (J/K)
 
-      PARAMETER (rdiffm = 0.7_dp)      ! multiple scattering correction parameter
-      PARAMETER (Qscat = 2.0_dp)       ! particle scattering efficiency at 532 nm
+      PARAMETER (rdiffm = 0.7_wp)      ! multiple scattering correction parameter
+      PARAMETER (Qscat = 2.0_wp)       ! particle scattering efficiency at 532 nm
 
-      REAL(dp) ::  rholiq, rhoice
-      PARAMETER (rholiq=1.0e+03_dp)     ! liquid water (kg/m3)
-      PARAMETER (rhoice=0.5e+03_dp)     ! ice (kg/m3)
+      REAL(wp) ::  rholiq, rhoice
+      PARAMETER (rholiq=1.0e+03_wp)     ! liquid water (kg/m3)
+      PARAMETER (rhoice=0.5e+03_wp)     ! ice (kg/m3)
 
-      REAL(dp) ::  rhopart(npart)
-      REAL(dp) ::  polpart(npart,5)  ! polynomial coefficients derived from Mie theory
+      REAL(wp) ::  rhopart(npart)
+      REAL(wp) ::  polpart(npart,5)  ! polynomial coefficients derived for spherical and non spherical
+                                     ! particules
 
 !   grid-box variables:
-      REAL(dp) ::  rad_part(npoints,nlev,npart)
-      REAL(dp) ::  rhoair(npoints,nlev), zheight(npoints,nlev+1)
-      REAL(dp) ::  beta_mol(npoints,nlev), alpha_mol(npoints,nlev)
-      REAL(dp) ::  kp_part(npoints,nlev,npart)
+      REAL(wp) ::  rad_part(npoints,nlev,npart)
+      REAL(wp) ::  rhoair(npoints,nlev), zheight(npoints,nlev+1)
+      REAL(wp) ::  beta_mol(npoints,nlev), alpha_mol(npoints,nlev)
+      REAL(wp) ::  kp_part(npoints,nlev,npart)
 
 !   sub-column variables:
-!!      REAL(dp) ::  frac_sub(npoints,nlev)
-      REAL(dp) ::  qpart(npoints,nlev,npart) ! mixing ratio particles in each subcolumn
-      REAL(dp) ::  alpha_part(npoints,nlev,npart)
-      REAL(dp) ::  tau_mol_lay(npoints)      ! temporary variable, moL. opt. thickness of layer k
-      REAL(dp) ::  tau_mol(npoints,nlev)     ! optical thickness between TOA and bottom of layer k
-      REAL(dp) ::  tau_part(npoints,nlev,npart)
-      REAL(dp) ::  betatot(npoints,nlev)
-      REAL(dp) ::  tautot_lay(npoints)   ! temporary variable, total opt. thickness of layer k
-      REAL(dp) ::  tautot_S_liq(npoints),tautot_S_ice(npoints)     ! parasol
+      REAL(wp) ::  qpart(npoints,nlev,npart) ! mixing ratio particles in each subcolumn
+      REAL(wp) ::  alpha_part(npoints,nlev,npart)
+      REAL(wp) ::  tau_mol_lay(npoints)      ! temporary variable, moL. opt. thickness of layer k
+      REAL(wp) ::  tau_mol(npoints,nlev)     ! optical thickness between TOA and bottom of layer k
+      REAL(wp) ::  tau_part(npoints,nlev,npart)
+      REAL(wp) ::  betatot(npoints,nlev)
+      REAL(wp) ::  tautot_lay(npoints)   ! temporary variable, total opt. thickness of layer k
+!     Optical thickness from TOA to surface for Parasol
+      REAL(wp) ::  tautot_S_liq(npoints),tautot_S_ice(npoints)     ! for liq and ice clouds
+
 
+! Local variables
+      REAL(wp) :: Alpha, Beta, Gamma  ! Polynomial coefficient for ATBperp computation
+      REAL(wp) :: betatot_ice(npoints,nlev)    ! backscatter coefficient for ice particles
+      REAL(wp) :: beta_perp_ice(npoints,nlev)  ! perpendicular backscatter coefficient for ice
+      REAL(wp) :: betatot_liq(npoints,nlev)    ! backscatter coefficient for liquid particles
+      REAL(wp) :: beta_perp_liq(npoints,nlev)  ! perpendicular backscatter coefficient for liq
+      REAL(wp) :: tautot_ice(npoints,nlev)     ! total optical thickness of ice
+      REAL(wp) :: tautot_liq(npoints,nlev)     ! total optical thickness of liq
+      REAL(wp) :: tautot_lay_ice(npoints)    ! total optical thickness of ice in the layer k
+      REAL(wp) :: tautot_lay_liq(npoints)    ! total optical thickness of liq in the layer k
+      REAL(wp) :: pnorm_liq(npoints,nlev)    ! lidar backscattered signal power for liquid
+      REAL(wp) :: pnorm_ice(npoints,nlev)    ! lidar backscattered signal power for ice
+      REAL(wp) :: pnorm_perp_ice(npoints,nlev) ! perpendicular lidar backscattered signal power for ice
+      REAL(wp) :: pnorm_perp_liq(npoints,nlev) ! perpendicular lidar backscattered signal power for liq
+
+! Output variable
+      REAL(wp) :: pnorm_perp_tot (npoints,nlev) ! perpendicular lidar backscattered signal power
+
+!------------------------------------------------------------
+!---- 0. Initialisation :
+!------------------------------------------------------------
+  betatot_ice(:,:)=0._wp
+  betatot_liq(:,:)=0._wp
+  beta_perp_ice(:,:)=0._wp
+  beta_perp_liq(:,:)=0._wp
+  tautot_ice(:,:)=0._wp
+  tautot_liq(:,:)=0._wp
+  tautot_lay_ice(:)=0._wp;
+  tautot_lay_liq(:)=0._wp;
+  pnorm_liq(:,:)=0._wp
+  pnorm_ice(:,:)=0._wp
+  pnorm_perp_ice(:,:)=0._wp
+  pnorm_perp_liq(:,:)=0._wp
+  pnorm_perp_tot(:,:)=0._wp
+
+
+! Polynomial coefficients (Alpha, Beta, Gamma) which allow to compute the ATBperpendicular
+! as a function of the ATB for ice or liquid cloud particles derived from CALIPSO-GOCCP
+! observations at 120m vertical grid (Cesana and Chepfer, JGR, 2013).
+!
+! Relationship between ATBice and ATBperp,ice for ice particles
+!  ATBperp,ice = Alpha*ATBice 
+         Alpha = 0.2904_wp
+
+! Relationship between ATBice and ATBperp,ice for liquid particles
+!  ATBperp,ice = Beta*ATBice^2 + Gamma*ATBice
+         Beta = 0.4099_wp
+         Gamma = 0.009_wp
 
 !------------------------------------------------------------
 !---- 1. Preliminary definitions and calculations :
 !------------------------------------------------------------
 
-      if ( npart .ne. 2 ) then
-        print *,'Error in lidar_simulator, npart should be 2, not',npart
+      if ( npart .ne. 4 ) then
+        print *,'Error in lidar_simulator, npart should be 4, not',npart
         stop
       endif
 
@@ -150,60 +254,81 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
 
 ! We repeat the same coefficients for LS and CONV cloud to make code more readable
 !*     LS Liquid water coefficients:
-         polpart(INDX_LSLIQ,1) =  2.6980e-8_dp     
-         polpart(INDX_LSLIQ,2) = -3.7701e-6_dp
-         polpart(INDX_LSLIQ,3) =  1.6594e-4_dp
-         polpart(INDX_LSLIQ,4) = -0.0024_dp
-         polpart(INDX_LSLIQ,5) =  0.0626_dp
+         polpart(INDX_LSLIQ,1) =  2.6980e-8_wp     
+         polpart(INDX_LSLIQ,2) = -3.7701e-6_wp
+         polpart(INDX_LSLIQ,3) =  1.6594e-4_wp
+         polpart(INDX_LSLIQ,4) = -0.0024_wp
+         polpart(INDX_LSLIQ,5) =  0.0626_wp
 !*     LS Ice coefficients: 
       if (ice_type.eq.0) then     
-         polpart(INDX_LSICE,1) = -1.0176e-8_dp   
-         polpart(INDX_LSICE,2) =  1.7615e-6_dp
-         polpart(INDX_LSICE,3) = -1.0480e-4_dp
-         polpart(INDX_LSICE,4) =  0.0019_dp
-         polpart(INDX_LSICE,5) =  0.0460_dp
+         polpart(INDX_LSICE,1) = -1.0176e-8_wp   
+         polpart(INDX_LSICE,2) =  1.7615e-6_wp
+         polpart(INDX_LSICE,3) = -1.0480e-4_wp
+         polpart(INDX_LSICE,4) =  0.0019_wp
+         polpart(INDX_LSICE,5) =  0.0460_wp
       endif
 !*     LS Ice NS coefficients: 
       if (ice_type.eq.1) then 
-         polpart(INDX_LSICE,1) = 1.3615e-8_dp  
-         polpart(INDX_LSICE,2) = -2.04206e-6_dp
-         polpart(INDX_LSICE,3) = 7.51799e-5_dp
-         polpart(INDX_LSICE,4) = 0.00078213_dp
-         polpart(INDX_LSICE,5) = 0.0182131_dp
+         polpart(INDX_LSICE,1) = 1.3615e-8_wp  
+         polpart(INDX_LSICE,2) = -2.04206e-6_wp
+         polpart(INDX_LSICE,3) = 7.51799e-5_wp
+         polpart(INDX_LSICE,4) = 0.00078213_wp
+         polpart(INDX_LSICE,5) = 0.0182131_wp
+      endif
+!*     CONV Liquid water coefficients:
+         polpart(INDX_CVLIQ,1) =  2.6980e-8_wp  
+         polpart(INDX_CVLIQ,2) = -3.7701e-6_wp  
+         polpart(INDX_CVLIQ,3) =  1.6594e-4_wp  
+         polpart(INDX_CVLIQ,4) = -0.0024_wp  
+         polpart(INDX_CVLIQ,5) =  0.0626_wp  
+!*     CONV Ice coefficients: 
+      if (ice_type.eq.0) then 
+         polpart(INDX_CVICE,1) = -1.0176e-8_wp  
+         polpart(INDX_CVICE,2) =  1.7615e-6_wp  
+         polpart(INDX_CVICE,3) = -1.0480e-4_wp  
+         polpart(INDX_CVICE,4) =  0.0019_wp  
+         polpart(INDX_CVICE,5) =  0.0460_wp  
+      endif
+      if (ice_type.eq.1) then
+         polpart(INDX_CVICE,1) = 1.3615e-8_wp  
+         polpart(INDX_CVICE,2) = -2.04206e-6_wp  
+         polpart(INDX_CVICE,3) = 7.51799e-5_wp  
+         polpart(INDX_CVICE,4) = 0.00078213_wp  
+         polpart(INDX_CVICE,5) = 0.0182131_wp  
       endif
 
 
 ! density:
 !*    clear-sky air:
-      rhoair = pres/(287.04_dp*temp)
+      rhoair = pres/(287.04_wp*temp)
 
 !*    liquid/ice particules:
       rhopart(INDX_LSLIQ) = rholiq
       rhopart(INDX_LSICE) = rhoice
+      rhopart(INDX_CVLIQ) = rholiq
+      rhopart(INDX_CVICE) = rhoice
 
 ! effective radius particles:
       rad_part(:,:,INDX_LSLIQ) = ls_radliq(:,:)
       rad_part(:,:,INDX_LSICE) = ls_radice(:,:)
-      rad_part(:,:,:)=MAX(rad_part(:,:,:),0._dp)
+      rad_part(:,:,INDX_CVLIQ) = cv_radliq(:,:)
+      rad_part(:,:,INDX_CVICE) = cv_radice(:,:)
+      rad_part(:,:,:)=MAX(rad_part(:,:,:),0._wp)
+      rad_part(:,:,:)=MIN(rad_part(:,:,:),70.0e-6_wp)
       
 ! altitude at half pressure levels:
-      zheight(:,1) = 0.0_dp
+      zheight(:,1) = 0.0_wp
       do k = 2, nlev+1 ! Unvectorized loop : unimportant
         zheight(:,k) = zheight(:,k-1) &
-                  -(presf(:,k)-presf(:,k-1))/(rhoair(:,k-1)*9.81_dp)
+                  -(presf(:,k)-presf(:,k-1))/(rhoair(:,k-1)*9.81_wp)
       enddo
 
-! cloud fraction (0 or 1) in each sub-column:
-! (if frac_out=1or2 -> frac_sub=1; if frac_out=0 -> frac_sub=0)
-!!      frac_sub = MIN( frac_out, 1.0_dp )
-
 !------------------------------------------------------------
 !---- 2. Molecular alpha and beta:
 !------------------------------------------------------------
 
-
       beta_mol = pres/km/temp * Cmol
-      alpha_mol = 8.0_dp*api/3.0_dp * beta_mol
+      alpha_mol = 8.0_wp*pi/3.0_wp * beta_mol
 
 !------------------------------------------------------------
 !---- 3. Particles alpha and beta:
@@ -211,36 +336,37 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
 
 ! polynomes kp_lidar derived from Mie theory:
       do i = 1, npart ! Unvectorized loop : unimportant
-       where ( rad_part(:,:,i).gt.0.0_dp)
+       where ( rad_part(:,:,i).gt.0.0_wp)
          kp_part(:,:,i) = &
-            polpart(i,1)*(rad_part(:,:,i)*1e6_dp)**4 &
-          + polpart(i,2)*(rad_part(:,:,i)*1e6_dp)**3 &
-          + polpart(i,3)*(rad_part(:,:,i)*1e6_dp)**2 &
-          + polpart(i,4)*(rad_part(:,:,i)*1e6_dp) &
+            polpart(i,1)*(rad_part(:,:,i)*1e6_wp)**4 &
+          + polpart(i,2)*(rad_part(:,:,i)*1e6_wp)**3 &
+          + polpart(i,3)*(rad_part(:,:,i)*1e6_wp)**2 &
+          + polpart(i,4)*(rad_part(:,:,i)*1e6_wp) &
           + polpart(i,5)
         elsewhere
-         kp_part(:,:,i) = 0._dp
+         kp_part(:,:,i) = 0._wp
         endwhere
       enddo
       
 ! mixing ratio particules in each subcolumn:
           qpart(:,:,INDX_LSLIQ) = q_lsliq(:,:) ! oct08
           qpart(:,:,INDX_LSICE) = q_lsice(:,:) ! oct08
-
+          qpart(:,:,INDX_CVLIQ) = q_cvliq(:,:) ! oct08
+          qpart(:,:,INDX_CVICE) = q_cvice(:,:) ! oct08
 
 ! alpha of particles in each subcolumn:
       do i = 1, npart ! Unvectorized loop : unimportant
-        where ( rad_part(:,:,i).gt.0.0_dp)
-          alpha_part(:,:,i) = 3.0_dp/4.0_dp * Qscat &
+        where ( rad_part(:,:,i).gt.0.0_wp)
+          alpha_part(:,:,i) = 3.0_wp/4.0_wp * Qscat &
                  * rhoair(:,:) * qpart(:,:,i) &
                  / (rhopart(i) * rad_part(:,:,i) )
         elsewhere
-          alpha_part(:,:,i) = 0._dp
+          alpha_part(:,:,i) = 0._wp
         endwhere
       enddo
 
 !------------------------------------------------------------
-!---- 4. Backscatter signal:
+!---- 4.1 Total Backscatter signal:
 !------------------------------------------------------------
 ! optical thickness (molecular):
 !     opt. thick of each layer
@@ -266,19 +392,20 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
 
 ! molecular signal:
 !      Upper layer 
-       pmol(:,nlev) = beta_mol(:,nlev) / (2._dp*tau_mol(:,nlev)) &
-            & * (1._dp-exp(-2.0_dp*tau_mol(:,nlev)))
+       pmol(:,nlev) = beta_mol(:,nlev) / (2._wp*tau_mol(:,nlev)) &
+            & * (1._wp-exp(-2.0_wp*tau_mol(:,nlev)))
 !      Other layers
        DO k= nlev-1, 1, -1
         tau_mol_lay(:) = tau_mol(:,k)-tau_mol(:,k+1) ! opt. thick. of layer k
-        WHERE (tau_mol_lay(:).GT.0._dp)
-          pmol(:,k) = beta_mol(:,k) * EXP(-2.0_dp*tau_mol(:,k+1)) / (2._dp*tau_mol_lay(:)) &
-            & * (1._dp-exp(-2.0_dp*tau_mol_lay(:)))
+        WHERE (tau_mol_lay(:).GT.0._wp)
+          pmol(:,k) = beta_mol(:,k) * EXP(-2.0_wp*tau_mol(:,k+1)) / (2._wp*tau_mol_lay(:)) &
+            & * (1._wp-exp(-2.0_wp*tau_mol_lay(:)))
         ELSEWHERE
 !         This must never happend, but just in case, to avoid div. by 0
-          pmol(:,k) = beta_mol(:,k) * EXP(-2.0_dp*tau_mol(:,k+1))
+          pmol(:,k) = beta_mol(:,k) * EXP(-2.0_wp*tau_mol(:,k+1))
         END WHERE
       END DO
+
 !
 ! Total signal (molecular + particules):
 !
@@ -294,20 +421,159 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
       ENDDO ! i
 !
 !     Upper layer 
-      pnorm(:,nlev) = betatot(:,nlev) / (2._dp*tautot(:,nlev)) &
-            & * (1._dp-exp(-2.0_dp*tautot(:,nlev)))
+      pnorm(:,nlev) = betatot(:,nlev) / (2._wp*tautot(:,nlev)) &
+            & * (1._wp-exp(-2.0_wp*tautot(:,nlev)))
 !     Other layers
       DO k= nlev-1, 1, -1
         tautot_lay(:) = tautot(:,k)-tautot(:,k+1) ! optical thickness of layer k
-        WHERE (tautot_lay(:).GT.0._dp)
-          pnorm(:,k) = betatot(:,k) * EXP(-2.0_dp*tautot(:,k+1)) / (2._dp*tautot_lay(:)) &
-               & * (1._dp-EXP(-2.0_dp*tautot_lay(:)))
+        WHERE (tautot_lay(:).GT.0._wp)
+          pnorm(:,k) = betatot(:,k) * EXP(-2.0_wp*tautot(:,k+1)) / (2._wp*tautot_lay(:)) &
+               & * (1._wp-EXP(-2.0_wp*tautot_lay(:)))
         ELSEWHERE
 !         This must never happend, but just in case, to avoid div. by 0
-          pnorm(:,k) = betatot(:,k) * EXP(-2.0_dp*tautot(:,k+1))
+          pnorm(:,k) = betatot(:,k) * EXP(-2.0_wp*tautot(:,k+1))
         END WHERE
       END DO
 
+
+!------------------------------------------------------------
+!---- 4.2 Ice/Liq Backscatter signal:
+!------------------------------------------------------------
+
+! Contribution of the molecular to beta
+      betatot_ice(:,:) = beta_mol(:,:)
+      betatot_liq(:,:) = beta_mol(:,:)
+
+      tautot_ice(:,:) = tau_mol(:,:)
+      tautot_liq(:,:) = tau_mol(:,:)
+
+      DO i = 2, npart,2
+           betatot_ice(:,:) = betatot_ice(:,:)+ kp_part(:,:,i)*alpha_part(:,:,i)
+           tautot_ice(:,:) = tautot_ice(:,:)  + tau_part(:,:,i)
+      ENDDO ! i
+      DO i = 1, npart,2
+           betatot_liq(:,:) = betatot_liq(:,:)+ kp_part(:,:,i)*alpha_part(:,:,i)
+           tautot_liq(:,:) = tautot_liq(:,:)  + tau_part(:,:,i)
+      ENDDO ! i
+
+
+! Computation of the ice and liquid lidar backscattered signal (ATBice and ATBliq)
+!     Ice only
+!     Upper layer
+      pnorm_ice(:,nlev) = betatot_ice(:,nlev) / (2._wp*tautot_ice(:,nlev)) &
+            & * (1._wp-exp(-2.0_wp*tautot_ice(:,nlev)))
+
+      DO k= nlev-1, 1, -1
+          tautot_lay_ice(:) = tautot_ice(:,k)-tautot_ice(:,k+1) 
+        WHERE (tautot_lay_ice(:).GT.0.)
+         pnorm_ice(:,k)=betatot_ice(:,k)*EXP(-2.0_wp*tautot_ice(:,k+1))/(2._wp*tautot_lay_ice(:)) &
+               & * (1._wp-EXP(-2.0_wp*tautot_lay_ice(:)))
+        ELSEWHERE
+         pnorm_ice(:,k)=betatot_ice(:,k)*EXP(-2.0_wp*tautot_ice(:,k+1))
+        END WHERE
+      ENDDO
+
+!     Liquid only
+!     Upper layer
+      pnorm_liq(:,nlev) = betatot_liq(:,nlev) / (2._wp*tautot_liq(:,nlev)) &
+            & * (1._wp-exp(-2.0_wp*tautot_liq(:,nlev)))
+
+      DO k= nlev-1, 1, -1
+          tautot_lay_liq(:) = tautot_liq(:,k)-tautot_liq(:,k+1) 
+        WHERE (tautot_lay_liq(:).GT.0._wp)
+          pnorm_liq(:,k)=betatot_liq(:,k)*EXP(-2.0_wp*tautot_liq(:,k+1))/(2._wp*tautot_lay_liq(:)) &
+               & * (1._wp-EXP(-2.0_wp*tautot_lay_liq(:)))
+        ELSEWHERE
+          pnorm_liq(:,k)=betatot_liq(:,k)*EXP(-2.0_wp*tautot_liq(:,k+1))
+        END WHERE
+      ENDDO
+
+
+! Computation of ATBperp,ice/liq from ATBice/liq including the multiple scattering 
+! contribution (Cesana and Chepfer 2013, JGR)
+!  ATBperp,ice = Alpha*ATBice 
+!  ATBperp,liq = Beta*ATBliq^2 + Gamma*ATBliq
+
+      DO k= nlev, 1, -1
+	      pnorm_perp_ice(:,k) = Alpha * pnorm_ice(:,k) ! Ice particles
+	      pnorm_perp_liq(:,k) = 1000*Beta * pnorm_liq(:,k)**2 + Gamma * pnorm_liq(:,k) ! Liquid particles
+      ENDDO
+
+! Computation of beta_perp_ice/liq using the lidar equation
+!     Ice only
+!     Upper layer 
+      beta_perp_ice(:,nlev) = pnorm_perp_ice(:,nlev) * (2._wp*tautot_ice(:,nlev)) &
+            & / (1._wp-exp(-2.0_wp*tautot_ice(:,nlev)))
+
+      DO k= nlev-1, 1, -1
+        tautot_lay_ice(:) = tautot_ice(:,k)-tautot_ice(:,k+1)
+        WHERE (tautot_lay_ice(:).GT.0._wp)
+         beta_perp_ice(:,k) = pnorm_perp_ice(:,k)/ EXP(-2.0_wp*tautot_ice(:,k+1)) * (2._wp*tautot_lay_ice(:)) &
+            & / (1._wp-exp(-2.0_wp*tautot_lay_ice(:)))
+
+        ELSEWHERE
+         beta_perp_ice(:,k)=pnorm_perp_ice(:,k)/EXP(-2.0_wp*tautot_ice(:,k+1))
+        END WHERE
+      ENDDO
+
+!     Liquid only
+!     Upper layer 
+      beta_perp_liq(:,nlev) = pnorm_perp_liq(:,nlev) * (2._wp*tautot_liq(:,nlev)) &
+            & / (1._wp-exp(-2.0_wp*tautot_liq(:,nlev)))
+
+      DO k= nlev-1, 1, -1
+          tautot_lay_liq(:) = tautot_liq(:,k)-tautot_liq(:,k+1) 
+        WHERE (tautot_lay_liq(:).GT.0._wp)
+         beta_perp_liq(:,k) = pnorm_perp_liq(:,k)/ EXP(-2.0_wp*tautot_liq(:,k+1)) * (2._wp*tautot_lay_liq(:)) &
+            & / (1._wp-exp(-2.0_wp*tautot_lay_liq(:)))
+
+        ELSEWHERE
+         beta_perp_liq(:,k)=pnorm_perp_liq(:,k)/EXP(-2.0_wp*tautot_liq(:,k+1))
+        END WHERE
+      ENDDO
+
+
+
+!------------------------------------------------------------
+!---- 4.3 Perpendicular Backscatter signal:
+!------------------------------------------------------------
+
+! Computation of the total perpendicular lidar signal (ATBperp for liq+ice)
+!     Upper layer 
+    WHERE(tautot(:,nlev).GT.0)
+          pnorm_perp_tot(:,nlev) = &
+              (beta_perp_ice(:,nlev)+beta_perp_liq(:,nlev)-(beta_mol(:,nlev)/(1+1/0.0284_wp))) / (2._wp*tautot(:,nlev)) &
+              & * (1._wp-exp(-2.0_wp*tautot(:,nlev)))
+    ELSEWHERE
+    pnorm_perp_tot(:,nlev) = 0._wp
+    ENDWHERE
+
+!     Other layers
+      DO k= nlev-1, 1, -1
+          tautot_lay(:) = tautot(:,k)-tautot(:,k+1) ! optical thickness of layer k
+
+          ! The perpendicular component of the molecular backscattered signal (Betaperp) has been 
+          ! taken into account two times (once for liquid and once for ice). 
+          ! We remove one contribution using 
+          ! Betaperp=beta_mol(:,k)/(1+1/0.0284)) [bodhaine et al. 1999] in the following equations:
+            WHERE (pnorm(:,k).eq.0)
+                  pnorm_perp_tot(:,k)=0._wp
+                  ELSEWHERE
+                    WHERE (tautot_lay(:).GT.0.)
+                      pnorm_perp_tot(:,k) = &
+                          (beta_perp_ice(:,k)+beta_perp_liq(:,k)-(beta_mol(:,k)/(1+1/0.0284_wp))) * &
+                          EXP(-2.0_wp*tautot(:,k+1)) / (2._wp*tautot_lay(:)) &
+                          & * (1._wp-EXP(-2.0_wp*tautot_lay(:)))
+                    ELSEWHERE
+          !         This must never happen, but just in case, to avoid div. by 0
+                      pnorm_perp_tot(:,k) = &
+                           (beta_perp_ice(:,k)+beta_perp_liq(:,k)-(beta_mol(:,k)/(1+1/0.0284_wp))) * &
+                          EXP(-2.0_wp*tautot(:,k+1))
+                    END WHERE
+            ENDWHERE
+
+      END DO
+
 !-------- End computation Lidar --------------------------
 !---------------------------------------------------------
 !  Parasol/Polder module
@@ -317,20 +583,20 @@ subroutine cosp_lidar_simulator(npoints,nlev,npart,nrefl & ! parasol
 ! ---------------------------------------------------------
 
 ! initialization:
-    refl(:,:) = 0.0_dp
+    refl(:,:) = 0.0_wp
 
 ! activate parasol calculations:
     if (ok_parasol) then
 
 !     Optical thickness from TOA to surface
-      tautot_S_liq = 0._dp
-      tautot_S_ice = 0._dp
+      tautot_S_liq = 0._wp
+      tautot_S_ice = 0._wp
       tautot_S_liq(:) = tautot_S_liq(:) &
-         + tau_part(:,1,1)
+         + tau_part(:,1,1)+ tau_part(:,1,3)
       tautot_S_ice(:) = tautot_S_ice(:) &
-         + tau_part(:,1,2)
+         + tau_part(:,1,2)+ tau_part(:,1,4)
 
-      call parasol(npoints,nrefl        &
+      call parasol(npoints,nrefl,undef      &
                  ,tautot_S_liq,tautot_S_ice &
                  ,refl)
 
@@ -340,7 +606,7 @@ END SUBROUTINE cosp_lidar_simulator
 !
 !---------------------------------------------------------------------------------
 !
-SUBROUTINE parasol(npoints,nrefl      &
+SUBROUTINE parasol(npoints,nrefl,undef     &
                        ,tautot_S_liq,tautot_S_ice  &
                        ,refl)
 !---------------------------------------------------------------------------------
@@ -355,8 +621,8 @@ SUBROUTINE parasol(npoints,nrefl      &
 ! Version 2.0 (October 2008)
 ! Version 2.1 (December 2008)
 !---------------------------------------------------------------------------------
-    USE mo_kind,                ONLY: dp
-    USE mo_constants,           ONLY: api !pi 
+    USE mo_kind,                ONLY: wp
+    USE mo_math_constants,      ONLY: pi !pi 
 
     IMPLICIT NONE
 
@@ -364,15 +630,16 @@ SUBROUTINE parasol(npoints,nrefl      &
     INTEGER npoints              ! Number of horizontal gridpoints
     INTEGER nrefl                ! Number of angles for which the reflectance 
                                  ! is computed. Can not be greater then ntetas
-    REAL(dp)  tautot_S_liq(npoints)   ! liquid water cloud optical thickness, 
+    REAL(wp)  undef                   ! Undefined value. Currently not used
+    REAL(wp)  tautot_S_liq(npoints)   ! liquid water cloud optical thickness, 
                                    ! integrated from TOA to surface
-    REAL(dp)  tautot_S_ice(npoints)   ! same for ice water clouds only
+    REAL(wp)  tautot_S_ice(npoints)   ! same for ice water clouds only
 ! outputs
-    REAL(dp)  refl(npoints,nrefl)     ! Parasol reflectances
+    REAL(wp)  refl(npoints,nrefl)     ! Parasol reflectances
 !
 ! Local variables
-    REAL(dp)  tautot_S(npoints)       ! cloud optical thickness, from TOA to surface
-    REAL(dp)  frac_taucol_liq(npoints), frac_taucol_ice(npoints)
+    REAL(wp)  tautot_S(npoints)       ! cloud optical thickness, from TOA to surface
+    REAL(wp)  frac_taucol_liq(npoints), frac_taucol_ice(npoints)
 
 
 !   look up table variables:
@@ -380,44 +647,44 @@ SUBROUTINE parasol(npoints,nrefl      &
     INTEGER ntetas, nbtau        ! number of angle and of optical thickness
                                    ! of the look-up table
     PARAMETER (ntetas=5, nbtau=7)
-    REAL(dp)  aa(ntetas,nbtau-1), ab(ntetas,nbtau-1)
-    REAL(dp)  ba(ntetas,nbtau-1), bb(ntetas,nbtau-1)  
-    REAL(dp)  tetas(ntetas),optau(nbtau)                        
-    REAL(dp)  r_norm(ntetas)
-    REAL(dp)  rlumA(ntetas,nbtau), rlumB(ntetas,nbtau)       
-    REAL(dp)  rlumA_mod(npoints,5), rlumB_mod(npoints,5) 
-
-    DATA optau   /0._dp, 1._dp, 5._dp, 10._dp, 20._dp, 50._dp, 100._dp/
-    DATA tetas /0._dp, 20._dp, 40._dp, 60._dp, 80._dp/
+    REAL(wp)  aa(ntetas,nbtau-1), ab(ntetas,nbtau-1)
+    REAL(wp)  ba(ntetas,nbtau-1), bb(ntetas,nbtau-1)  
+    REAL(wp)  tetas(ntetas),tau(nbtau)                        
+    REAL(wp)  r_norm(ntetas)
+    REAL(wp)  rlumA(ntetas,nbtau), rlumB(ntetas,nbtau)       
+    REAL(wp)  rlumA_mod(npoints,5), rlumB_mod(npoints,5) 
+
+    DATA tau   /0._wp, 1._wp, 5._wp, 10._wp, 20._wp, 50._wp, 100._wp/
+    DATA tetas /0._wp, 20._wp, 40._wp, 60._wp, 80._wp/
     
 ! Look-up table for spherical liquid particles:
-    DATA (rlumA(1,ny),ny=1,nbtau) /0.03_dp, 0.090886_dp, 0.283965_dp, &
-     0.480587_dp, 0.695235_dp, 0.908229_dp, 1.0_dp /
-    DATA (rlumA(2,ny),ny=1,nbtau) /0.03_dp, 0.072185_dp, 0.252596_dp, &
-      0.436401_dp,  0.631352_dp, 0.823924_dp, 0.909013_dp /
-    DATA (rlumA(3,ny),ny=1,nbtau) /0.03_dp, 0.058410_dp, 0.224707_dp, &
-      0.367451_dp,  0.509180_dp, 0.648152_dp, 0.709554_dp /
-    DATA (rlumA(4,ny),ny=1,nbtau) /0.03_dp, 0.052498_dp, 0.175844_dp, &
-      0.252916_dp,  0.326551_dp, 0.398581_dp, 0.430405_dp /
-    DATA (rlumA(5,ny),ny=1,nbtau) /0.03_dp, 0.034730_dp, 0.064488_dp, &
-      0.081667_dp,  0.098215_dp, 0.114411_dp, 0.121567_dp /
+    DATA (rlumA(1,ny),ny=1,nbtau) /0.03_wp, 0.090886_wp, 0.283965_wp, &
+     0.480587_wp, 0.695235_wp, 0.908229_wp, 1.0_wp /
+    DATA (rlumA(2,ny),ny=1,nbtau) /0.03_wp, 0.072185_wp, 0.252596_wp, &
+      0.436401_wp,  0.631352_wp, 0.823924_wp, 0.909013_wp /
+    DATA (rlumA(3,ny),ny=1,nbtau) /0.03_wp, 0.058410_wp, 0.224707_wp, &
+      0.367451_wp,  0.509180_wp, 0.648152_wp, 0.709554_wp /
+    DATA (rlumA(4,ny),ny=1,nbtau) /0.03_wp, 0.052498_wp, 0.175844_wp, &
+      0.252916_wp,  0.326551_wp, 0.398581_wp, 0.430405_wp /
+    DATA (rlumA(5,ny),ny=1,nbtau) /0.03_wp, 0.034730_wp, 0.064488_wp, &
+      0.081667_wp,  0.098215_wp, 0.114411_wp, 0.121567_wp /
 
 ! Look-up table for ice particles:
-    DATA (rlumB(1,ny),ny=1,nbtau) /0.03_dp, 0.092170_dp, 0.311941_dp, &
-       0.511298_dp, 0.712079_dp , 0.898243_dp , 0.976646_dp  /
-    DATA (rlumB(2,ny),ny=1,nbtau) /0.03_dp, 0.087082_dp, 0.304293_dp, &
-       0.490879_dp,  0.673565_dp, 0.842026_dp, 0.912966_dp /
-    DATA (rlumB(3,ny),ny=1,nbtau) /0.03_dp, 0.083325_dp, 0.285193_dp, &
-      0.430266_dp,  0.563747_dp, 0.685773_dp,  0.737154_dp /
-    DATA (rlumB(4,ny),ny=1,nbtau) /0.03_dp, 0.084935_dp, 0.233450_dp, &
-      0.312280_dp, 0.382376_dp, 0.446371_dp, 0.473317_dp /
-    DATA (rlumB(5,ny),ny=1,nbtau) /0.03_dp, 0.054157_dp, 0.089911_dp, &
-      0.107854_dp, 0.124127_dp, 0.139004_dp, 0.145269_dp /
+    DATA (rlumB(1,ny),ny=1,nbtau) /0.03_wp, 0.092170_wp, 0.311941_wp, &
+       0.511298_wp, 0.712079_wp , 0.898243_wp , 0.976646_wp  /
+    DATA (rlumB(2,ny),ny=1,nbtau) /0.03_wp, 0.087082_wp, 0.304293_wp, &
+       0.490879_wp,  0.673565_wp, 0.842026_wp, 0.912966_wp /
+    DATA (rlumB(3,ny),ny=1,nbtau) /0.03_wp, 0.083325_wp, 0.285193_wp, &
+      0.430266_wp,  0.563747_wp, 0.685773_wp,  0.737154_wp /
+    DATA (rlumB(4,ny),ny=1,nbtau) /0.03_wp, 0.084935_wp, 0.233450_wp, &
+      0.312280_wp, 0.382376_wp, 0.446371_wp, 0.473317_wp /
+    DATA (rlumB(5,ny),ny=1,nbtau) /0.03_wp, 0.054157_wp, 0.089911_wp, &
+      0.107854_wp, 0.124127_wp, 0.139004_wp, 0.145269_wp /
 
 !--------------------------------------------------------------------------------
 ! Lum_norm=f(tetaS,tau_cloud) derived from adding-doubling calculations
 !        valid ONLY ABOVE OCEAN (albedo_sfce=5%)
-!        valid only in one viewing direction (theta_v=30 G @, phi_s-phi_v=320 G @)
+!        valid only in one viewing direction (theta_v=30, phi_s-phi_v=320)
 !        based on adding-doubling radiative transfer computation
 !        for tau values (0 to 100) and for tetas values (0 to 80)
 !        for 2 scattering phase functions: liquid spherical, ice non spherical
@@ -427,40 +694,40 @@ SUBROUTINE parasol(npoints,nrefl      &
         STOP
     ENDIF
 
-    rlumA_mod=0._dp
-    rlumB_mod=0._dp
+    rlumA_mod=0._wp
+    rlumB_mod=0._wp
 !
    
-    r_norm(:)=1._dp/ COS(api/180._dp*tetas(:))
+    r_norm(:)=1._wp/ COS(pi/180._wp*tetas(:))
 !
-    tautot_S_liq(:)=MAX(tautot_S_liq(:),optau(1))
-    tautot_S_ice(:)=MAX(tautot_S_ice(:),optau(1))
+    tautot_S_liq(:)=MAX(tautot_S_liq(:),tau(1))
+    tautot_S_ice(:)=MAX(tautot_S_ice(:),tau(1))
     tautot_S(:) = tautot_S_ice(:) + tautot_S_liq(:)
 !
 ! relative fraction of the opt. thick due to liquid or ice clouds
-    WHERE (tautot_S(:) .GT. 0._dp)
+    WHERE (tautot_S(:) .GT. 0._wp)
         frac_taucol_liq(:) = tautot_S_liq(:) / tautot_S(:)
         frac_taucol_ice(:) = tautot_S_ice(:) / tautot_S(:)
     ELSEWHERE
-        frac_taucol_liq(:) = 1._dp
-        frac_taucol_ice(:) = 0._dp
+        frac_taucol_liq(:) = 1._wp
+        frac_taucol_ice(:) = 0._wp
     END WHERE
-    tautot_S(:)=MIN(tautot_S(:),optau(nbtau))
+    tautot_S(:)=MIN(tautot_S(:),tau(nbtau))
 !
 ! Linear interpolation :
 
     DO ny=1,nbtau-1
 ! microphysics A (liquid clouds) 
-      aA(:,ny) = (rlumA(:,ny+1)-rlumA(:,ny))/(optau(ny+1)-optau(ny))
-      bA(:,ny) = rlumA(:,ny) - aA(:,ny)*optau(ny)
+      aA(:,ny) = (rlumA(:,ny+1)-rlumA(:,ny))/(tau(ny+1)-tau(ny))
+      bA(:,ny) = rlumA(:,ny) - aA(:,ny)*tau(ny)
 ! microphysics B (ice clouds)
-      aB(:,ny) = (rlumB(:,ny+1)-rlumB(:,ny))/(optau(ny+1)-optau(ny))
-      bB(:,ny) = rlumB(:,ny) - aB(:,ny)*optau(ny)
+      aB(:,ny) = (rlumB(:,ny+1)-rlumB(:,ny))/(tau(ny+1)-tau(ny))
+      bB(:,ny) = rlumB(:,ny) - aB(:,ny)*tau(ny)
     ENDDO
 !
     DO it=1,ntetas
       DO ny=1,nbtau-1
-        WHERE (tautot_S(:).GE.optau(ny).AND.tautot_S(:).LE.optau(ny+1))
+        WHERE (tautot_S(:).GE.tau(ny).AND.tautot_S(:).LE.tau(ny+1))
             rlumA_mod(:,it) = aA(it,ny)*tautot_S(:) + bA(it,ny)
             rlumB_mod(:,it) = aB(it,ny)*tautot_S(:) + bB(it,ny)
         END WHERE
@@ -471,7 +738,6 @@ SUBROUTINE parasol(npoints,nrefl      &
       refl(:,it) = frac_taucol_liq(:) * rlumA_mod(:,it) &
          + frac_taucol_ice(:) * rlumB_mod(:,it)
 ! normalized radiance -> reflectance: 
-      refl(:,it) = refl(:,it) * r_norm(it)
     ENDDO
 
     RETURN
diff --git a/src/cudtdq.f90 b/src/cudtdq.f90
index 788b1fe..8050b6a 100644
--- a/src/cudtdq.f90
+++ b/src/cudtdq.f90
@@ -34,6 +34,7 @@ USE mo_param_switches,         ONLY: ncvmicro
 !--- End Included for dust emissions in ---------------------------------
 USE mo_submodel,     ONLY: lanysubmodel
 USE mo_vphysc,       ONLY: set_vphysc_var
+USE mo_memory_g3b,       ONLY: aprc_na, aprcs_na
 !
 IMPLICIT NONE
 !
@@ -257,6 +258,8 @@ REAL(dp) :: zdiagt, zalv, zdtdt, zdqdt, zdxtdt
      pssfc(jl)=psfl(jl)
      paprc(jl)=paprc(jl)+zdiagt*(prfl(jl)+psfl(jl))
      paprs(jl)=paprs(jl)+zdiagt*psfl(jl)
+     aprc_na(jl,krow) = prfl(jl)+psfl(jl)
+     aprcs_na(jl,krow) = psfl(jl)
 310 END DO
 !
 ! calculate and store convective accumulated precipitation (mm)
diff --git a/src/cuflx.f90 b/src/cuflx.f90
index db2dcf9..79bc2d5 100644
--- a/src/cuflx.f90
+++ b/src/cuflx.f90
@@ -47,7 +47,8 @@ USE mo_submodel_interface, ONLY: cuflx_subm
 USE mo_memory_cfdiag, ONLY : locfdiag, mc, mcu, mcd, imc, smc, dmc
 USE mo_geoloc,        ONLY : gboxarea
 USE mo_time_control,  ONLY : delta_time
-USE mo_cosp_offline, ONLY: locospoffl, cospoffl_ccrain, cospoffl_ccsnow
+USE mo_cosp_echam,    ONLY : locosp, cosp_ccrain, cosp_ccsnow
+USE mo_cosp_offline,  ONLY : locospoffl, cospoffl_ccrain, cospoffl_ccsnow
 !--
 !---Included for scavenging in xtwetdep (Philip Stier, 28/03/01):-------
 USE mo_constants,    ONLY : rd
@@ -456,22 +457,37 @@ END IF
      END DO
   END IF ! locfdiag
 
+  IF ( locosp ) THEN
+     DO jk=ktopm2,klev
+        DO jl=1,kproma
+           IF(ldcum(jl)) THEN
+              IF(pten(jl,jk).GT.tmelt) THEN
+                 cosp_ccrain(jl,jk,krow) = pdmfup(jl,jk)+pdmfdp(jl,jk)
+                 cosp_ccsnow(jl,jk,krow) = 0.0_dp
+              ELSE
+                 cosp_ccsnow(jl,jk,krow) = pdmfup(jl,jk)+pdmfdp(jl,jk)
+                 cosp_ccrain(jl,jk,krow) = 0.0_dp
+              END IF
+           END IF
+        END DO
+     END DO
+  ENDIF !locosp
+
   IF ( locospoffl ) THEN
      DO jk=ktopm2,klev
         DO jl=1,kproma
            IF(ldcum(jl)) THEN
               IF(pten(jl,jk).GT.tmelt) THEN
                  cospoffl_ccrain(jl,jk,krow) = pdmfup(jl,jk)+pdmfdp(jl,jk)
-                 cospoffl_ccsnow(jl,jk,krow) = 0._dp
+                 cospoffl_ccsnow(jl,jk,krow) = 0.0_dp
               ELSE
                  cospoffl_ccsnow(jl,jk,krow) = pdmfup(jl,jk)+pdmfdp(jl,jk)
-                 cospoffl_ccrain(jl,jk,krow) = 0._dp
+                 cospoffl_ccrain(jl,jk,krow) = 0.0_dp
               END IF
            END IF
         END DO
      END DO
   ENDIF !locospoffl
 
-
   RETURN
 END SUBROUTINE cuflx
diff --git a/src/initialize.f90 b/src/initialize.f90
index a776663..4aa07a2 100644
--- a/src/initialize.f90
+++ b/src/initialize.f90
@@ -37,9 +37,9 @@ SUBROUTINE initialize
   USE mo_debugs,             ONLY: init_debugs
   USE mo_jsbach_interface,   ONLY: jsbach_init
   USE mo_co2,                ONLY: init_co2
-  USE mo_cosp_simulator,     ONLY: cosp_initialize
   USE mo_station_diag,       ONLY: station_diag_nml
   USE mo_memory_cfdiag,      ONLY: setup_cfdiag
+  USE mo_cosp_echam,         ONLY: cosp_initialize
   USE mo_cosp_offline,       ONLY: cosp_offline_nml
 !++mgs
   USE mo_submodel,           ONLY: setsubmodel, lanysubmodel
diff --git a/src/mo_activ.f90 b/src/mo_activ.f90
index caf4022..c7e3876 100644
--- a/src/mo_activ.f90
+++ b/src/mo_activ.f90
@@ -34,6 +34,8 @@ MODULE mo_activ
   REAL(dp),        PUBLIC, POINTER :: qmel(:,:,:)
   REAL(dp),        PUBLIC, POINTER :: cdnc_acc(:,:,:)
   REAL(dp),        PUBLIC, POINTER :: cdnc(:,:,:)
+  REAL(dp),        PUBLIC, POINTER :: cdnc_inst(:,:,:)
+  REAL(dp),        PUBLIC, POINTER :: clcaux(:,:,:)
   REAL(dp),        PUBLIC, POINTER :: icnc_acc(:,:,:)
   REAL(dp),        PUBLIC, POINTER :: icnc(:,:,:)
   REAL(dp),        PUBLIC, POINTER :: icnc_instantan(:,:,:) ! Ice crystal number concentration (ICNC), actual instantaneous value [1/m3]
@@ -227,7 +229,7 @@ CONTAINS
     USE mo_exception,    ONLY: message, em_param
     USE mo_submodel,     ONLY: print_value, lham, lhammoz, lccnclim
     USE mo_control,      ONLY: lipcc
-    USE mo_cloud,        ONLY: ccsaut, ccraut
+    USE mo_cloud,        ONLY: ccsaut, ccraut, ccraut_override
     USE mo_param_switches, ONLY : lcover, nauto, ncvmicro, &          !++mgs
                                   ncd_activ, nic_cirrus, lcdnc_progn !SF
     USE mo_tracer,       ONLY: get_tracer
@@ -302,6 +304,9 @@ CONTAINS
        !<<SF
     ENDIF
 
+    ! if a ccraut was requested in the namelist, we will honor that request
+    if (ccraut_override /= -999.0) ccraut = ccraut_override
+
 !>>SF
     !-- Define the cdnc and icnc tracer index to point to the correct tracer:
     CALL get_tracer('CDNC',idx=idt_cdnc)
@@ -344,18 +349,25 @@ CONTAINS
     ! Philip Stier, MPI-MET                       2004
     !
 
-  USE mo_memory_base,    ONLY: new_stream, add_stream_element, AUTO,  &
+  USE mo_memory_base,    ONLY: new_stream, add_stream_element, set_stream, AUTO,  &
                                default_stream_setting, add_stream_reference
   USE mo_filename,       ONLY: trac_filetype
   USE mo_linked_list,    ONLY: HYBRID
   USE mo_param_switches, ONLY: ncd_activ, nic_cirrus !SF
-
+  USE mo_time_event,  ONLY: io_time_event
+  
   IMPLICIT NONE
 
+  TYPE(io_time_event), SAVE     :: putactiv
 
   !--- Create new stream:
 
   CALL new_stream (activ ,'activ',filetype=trac_filetype)
+  putactiv%counter      = 3
+  putactiv%unit         = 'hours'
+  putactiv%adjustment   = 'first'
+  putactiv%offset       = 0
+  call set_stream(activ, interval = putactiv)
 
 
   !--- Add standard fields for post-processing:
@@ -441,6 +453,12 @@ CONTAINS
   CALL add_stream_element (activ,   'CDNC_BURDEN',cdnc_burden,                            &
                            longname='CDNC burden',                        units='m-2'     )
 
+  CALL add_stream_element (activ,   'CDNC_INST',       cdnc_inst,  laccu = .FALSE.,       &
+                           longname='instantaneous gridbox-mean CDNC',units='m-3'         )
+
+  CALL add_stream_element (activ,   'CLCAUX',       clcaux,        laccu = .FALSE.,       &
+                           longname='instantaneous cloud fraction',units='1'              )
+
   CALL add_stream_element (activ,   'BURDEN_TIME',burden_time,                            &
                            longname='acc. cdnc burden occ.time fraction', units='1'       )
 
diff --git a/src/mo_cloud.f90 b/src/mo_cloud.f90
index 7bce50e..090373a 100644
--- a/src/mo_cloud.f90
+++ b/src/mo_cloud.f90
@@ -37,7 +37,10 @@ MODULE mo_cloud
   REAL(dp), PUBLIC :: csatsc
   REAL(dp), PUBLIC :: ceffmin
   REAL(dp), PUBLIC :: csecfrl
-  REAL(dp), PUBLIC :: ccraut,ccsacl,ccracl,cauloc
+  REAL(dp), PUBLIC :: ccraut, & ! usual meaning
+       ccraut_override, & ! ccraut if specified in namelist (overrides default tuning)
+       ccauloc, & ! factor that multiplies cauloc for the large scale
+       ccsacl,ccracl,cauloc, creth, cautalpha, cautbeta
   REAL(dp), PUBLIC :: cvtfall
   REAL(dp), PUBLIC :: ccwmin
 !
@@ -94,7 +97,9 @@ MODULE mo_cloud
 !
 CONTAINS
 
-SUBROUTINE sucloud
+  SUBROUTINE sucloud
+    !(pccraut)
+    ! REAL(dp), INTENT(in), OPTIONAL :: pccraut
 
   ! Description:
   !
@@ -142,7 +147,11 @@ SUBROUTINE sucloud
     ceffmin = 10.0_dp    ! min eff.radius for ice cloud
     ccwmin  = 1.e-7_dp  ! cloud water limit for cover>0
     csatsc  = 1.0_dp
-  ENDIF
+ ENDIF
+
+ ! override ccraut if a different one is given
+ ! if (present(pccraut)) ccraut = pccraut
+ 
 !
 !                19 Level, no middle atmosphere
 !
diff --git a/src/mo_cloud_optics.f90 b/src/mo_cloud_optics.f90
index b6f88cc..81908a5 100644
--- a/src/mo_cloud_optics.f90
+++ b/src/mo_cloud_optics.f90
@@ -44,7 +44,7 @@ MODULE mo_cloud_optics
   USE mo_constants,      ONLY: api,rhoh2o
   USE mo_exception,      ONLY: finish
 
-  USE mo_cosp_simulator, ONLY: cosp_reffl, cosp_reffi, locosp
+!  USE mo_cosp_simulator, ONLY: cosp_reffl, cosp_reffi, locosp
 
   IMPLICIT NONE
   PRIVATE
diff --git a/src/mo_cosp_constants.f90 b/src/mo_cosp_constants.f90
index 6adb0da..539ca9c 100644
--- a/src/mo_cosp_constants.f90
+++ b/src/mo_cosp_constants.f90
@@ -1,45 +1,320 @@
-! (c) COPYRIGHT British Crown / Met Office 2008  
-! Please refer to Met_Office_license.txt for details.
+!>
+!! @par Copyright
+!! This code is subject to the MPI-M-Software - License - Agreement in it's most recent form.
+!! Please see URL http://www.mpimet.mpg.de/en/science/models/model-distribution.html and the
+!! file COPYING in the root of the source tree for this code.
+!! Where software is supplied by third parties, it is indicated in the headers of the routines.
+!!
+! (c) British Crown Copyright 2008, the Met Office.
+! All rights reserved.
+! 
+! Redistribution and use in source and binary forms, with or without modification, are permitted 
+! provided that the following conditions are met:
+! 
+!     * Redistributions of source code must retain the above copyright notice, this list 
+!       of conditions and the following disclaimer.
+!     * Redistributions in binary form must reproduce the above copyright notice, this list
+!       of conditions and the following disclaimer in the documentation and/or other materials 
+!       provided with the distribution.
+!     * Neither the name of the Met Office nor the names of its contributors may be used 
+!       to endorse or promote products derived from this software without specific prior written 
+!       permission.
+! 
+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
+! IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
+! FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
+! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
+! IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
+! OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+!
 !
 ! History:
 ! Jul 2007 - A. Bodas-Salcedo - Initial version
 ! Jul 2008 - A. Bodas-Salcedo - Added definitions of ISCCP axes
 ! Oct 2008 - H. Chepfer       - Added PARASOL_NREFL
+! Jun 2010 - R. Marchand      - Modified to support quickbeam V3, added ifdef for hydrometeor definitions
+! 
+
 
 MODULE mo_cosp_constants
 
-    USE mo_kind,  ONLY: dp
+    USE mo_kind,  ONLY: wp
 
     IMPLICIT NONE
     
+!CNam: #include "cosp_defs.h"
+
+    character(len=32) :: COSP_VERSION='COSP v1.4'
+
     ! Indices to address arrays of LS and CONV hydrometeors
-    INTEGER, PARAMETER :: I_LSCLIQ = 1
-    INTEGER, PARAMETER :: I_LSCICE = 2
-    
+    integer,parameter :: I_LSCLIQ = 1
+    integer,parameter :: I_LSCICE = 2
+    integer,parameter :: I_LSRAIN = 3
+    integer,parameter :: I_LSSNOW = 4
+    integer,parameter :: I_CVCLIQ = 5
+    integer,parameter :: I_CVCICE = 6
+    integer,parameter :: I_CVRAIN = 7
+    integer,parameter :: I_CVSNOW = 8
+    integer,parameter :: I_LSGRPL = 9
+
     ! Missing value
-    REAL(dp), PARAMETER :: R_UNDEF =   -1.0E30_dp
+    real(wp),parameter :: R_UNDEF = -1.0E30_wp
+
     ! Number of possible output variables
-    INTEGER, PARAMETER :: N_OUT_LIST = 27
+    integer,parameter :: N_OUT_LIST = 63
+    integer,parameter :: N3D = 8
+    integer,parameter :: N2D = 14
+    integer,parameter :: N1D = 40
+
     ! Value for forward model result from a level that is under the ground
-    REAL(dp), PARAMETER :: R_GROUND = -1.0E20_dp
+    real(wp),parameter :: R_GROUND = -1.0E20_wp
+
+    ! Stratiform and convective clouds in frac_out
+    integer, parameter :: I_LSC = 1, & ! Large-scale clouds
+                          I_CVC = 2    ! Convective clouds
+
+    ! Timing of different simulators, including statistics module
+    integer, parameter :: N_SIMULATORS = 7
+    integer,parameter :: I_RADAR = 1
+    integer,parameter :: I_LIDAR = 2
+    integer,parameter :: I_ISCCP = 3
+    integer,parameter :: I_MISR  = 4
+    integer,parameter :: I_MODIS = 5
+    integer,parameter :: I_RTTOV = 6
+    integer,parameter :: I_STATS = 7
+    character*32, dimension(N_SIMULATORS) :: SIM_NAME = (/'Radar','Lidar','ISCCP','MISR ','MODIS','RTTOV','Stats'/)
+    integer,dimension(N_SIMULATORS) :: tsim
+    data tsim/N_SIMULATORS*0.0_wp/
+
+    !--- Radar constants
+    ! CFAD constants
+    integer,parameter :: DBZE_BINS     =   15   ! Number of dBZe bins in histogram (cfad)
+    real(wp),parameter    :: DBZE_MIN      = -100.0_wp ! Minimum value for radar reflectivity
+    real(wp),parameter    :: DBZE_MAX      =   80.0_wp ! Maximum value for radar reflectivity
+    real(wp),parameter    :: CFAD_ZE_MIN   =  -50.0_wp ! Lower value of the first CFAD Ze bin
+    real(wp),parameter    :: CFAD_ZE_WIDTH =    5.0_wp ! Bin width (dBZe)
+
 
-!--- Lidar constants
+    !--- Lidar constants
     ! CFAD constants
-    INTEGER, PARAMETER :: SR_BINS       =   15
-    INTEGER, PARAMETER :: DPOL_BINS     =   6
-    REAL(dp), PARAMETER    :: LIDAR_UNDEF   =   999.999_dp
+    integer,parameter :: SR_BINS       =   15
+    integer,parameter :: DPOL_BINS     =   6
+    real(wp),parameter    :: LIDAR_UNDEF   =   999.999_wp
+
     ! Other constants
-    INTEGER, PARAMETER :: LIDAR_NCAT    =   4
-    INTEGER, PARAMETER :: PARASOL_NREFL =   5 ! parasol
-    REAL(dp), PARAMETER, DIMENSION(PARASOL_NREFL) :: PARASOL_SZA = (/0.0_dp, 20.0_dp, 40.0_dp, 60.0_dp, 80.0_dp/)
-    REAL(dp), PARAMETER :: DEFAULT_LIDAR_REFF = 30.0e-6_dp ! Default lidar effective radius
-    
-    !  number of hydrometeor classes
-    INTEGER, PARAMETER :: N_HYDRO = 2
+    integer,parameter :: LIDAR_NCAT    =   4
+    integer,parameter :: PARASOL_NREFL =   5 ! parasol
+    real(wp),parameter,dimension(PARASOL_NREFL) :: PARASOL_SZA = (/0.0_wp, 20.0_wp, 40.0_wp, 60.0_wp, 80.0_wp/)
+    real(wp),parameter    :: DEFAULT_LIDAR_REFF = 30.0e-6_wp ! Default lidar effective radius
+
+    integer,parameter :: LIDAR_NTEMP = 40
+    real(wp),parameter,dimension(LIDAR_NTEMP) :: LIDAR_PHASE_TEMP=(/-91.5_wp,-88.5_wp,-85.5_wp, &
+                   -82.5_wp,-79.5_wp,-76.5_wp,-73.5_wp,-70.5_wp,-67.5_wp,-64.5_wp, &
+                   -61.5_wp,-58.5_wp,-55.5_wp,-52.5_wp,-49.5_wp,-46.5_wp,-43.5_wp, &
+                   -40.5_wp,-37.5_wp,-34.5_wp,-31.5_wp,-28.5_wp,-25.5_wp,-22.5_wp, &
+                   -19.5_wp,-16.5_wp,-13.5_wp,-10.5_wp, -7.5_wp, -4.5_wp, -1.5_wp, &
+                     1.5_wp,  4.5_wp,  7.5_wp, 10.5_wp, 13.5_wp, 16.5_wp, 19.5_wp, 22.5_wp, 25.5_wp/)
+    real(wp),parameter,dimension(2,LIDAR_NTEMP) :: LIDAR_PHASE_TEMP_BNDS=reshape(source= (/ &
+		-273.15_wp,-90._wp,-90._wp,-87._wp,-87._wp,-84._wp,-84._wp,-81._wp,-81._wp,-78._wp, &
+                   -78._wp,-75._wp,-75._wp,-72._wp,-72._wp,-69._wp,-69._wp,-66._wp,-66._wp,-63._wp, &
+                   -63._wp,-60._wp,-60._wp,-57._wp,-57._wp,-54._wp,-54._wp,-51._wp,-51._wp,-48._wp, &
+                   -48._wp,-45._wp,-45._wp,-42._wp,-42._wp,-39._wp,-39._wp,-36._wp,-36._wp,-33._wp, &
+                   -33._wp,-30._wp,-30._wp,-27._wp,-27._wp,-24._wp,-24._wp,-21._wp,-21._wp,-18._wp, &
+                   -18._wp,-15._wp,-15._wp,-12._wp,-12._wp, -9._wp, -9._wp, -6._wp, -6._wp, -3._wp, &
+                    -3._wp,  0._wp,  0._wp,  3._wp,  3._wp,  6._wp,  6._wp,  9._wp,  9._wp, 12._wp, &
+                    12._wp, 15._wp, 15._wp, 18._wp, 18._wp, 21._wp, 21._wp, 24._wp, 24._wp,100._wp/),shape=(/2,40/)) 
+
+    !--- MISR constants
+    integer,parameter :: MISR_N_CTH = 16
+
+    !--- RTTOV constants
+    integer,parameter :: RTTOV_MAX_CHANNELS = 20
+
+    ! ISCCP tau-Pc axes
+    real(wp),parameter,dimension(7) :: ISCCP_TAU = (/0.15_wp, 0.80_wp, 2.45_wp, 6.5_wp, 16.2_wp, 41.5_wp, 100.0_wp/)
+    real(wp),parameter,dimension(2,7) :: ISCCP_TAU_BNDS = reshape(source=(/0.0_wp,0.3_wp,0.3_wp,1.30_wp,1.30_wp,3.6_wp, &
+                                                      3.6_wp,9.4_wp,9.4_wp,23.0_wp,23.0_wp,60.0_wp,60.0_wp,100000.0_wp/), &
+                                                      shape=(/2,7/))
+
+    real(wp),parameter,dimension(7) :: ISCCP_PC = (/90000._wp, 74000._wp, 62000._wp, 50000._wp, 37500._wp, 24500._wp, 9000._wp/)
+    real(wp),parameter,dimension(2,7) :: ISCCP_PC_BNDS = reshape(source=(/100000.0_wp,80000.0_wp,80000.0_wp,68000.0_wp, &
+                                                     68000.0_wp,56000.0_wp,56000.0_wp,44000.0_wp,44000.0_wp,31000.0_wp, &
+                                                     31000.0_wp,18000.0_wp,18000.0_wp,0.0_wp/), shape=(/2,7/))
+
+    real(wp),parameter,dimension(MISR_N_CTH) :: MISR_CTH = 1000.0*(/0._wp,0.25_wp,0.75_wp,1.25_wp,1.75_wp,2.25_wp,2.75_wp, 3.5_wp, &
+                                            4.5_wp, 6._wp, 8._wp, 10._wp, 12._wp, 14.5_wp, 16._wp, 18._wp/)
+    real(wp),parameter,dimension(2,MISR_N_CTH) :: MISR_CTH_BNDS = 1000.0*reshape(source=(/ &
+                                            -99.0_wp,  0.0_wp,  0.0_wp,  0.5_wp,  0.5_wp,  1.0_wp, 1.0_wp,  1.5_wp, &
+                                              1.5_wp,  2.0_wp,  2.0_wp,  2.5_wp,  2.5_wp,  3.0_wp, 3.0_wp,  4.0_wp, &
+                                              4.0_wp,  5.0_wp,  5.0_wp,  7.0_wp,  7.0_wp,  9.0_wp, 9.0_wp, 11.0_wp, &
+                                             11.0_wp, 13.0_wp, 13.0_wp, 15.0_wp, 15.0_wp, 17.0_wp,17.0_wp, 99.0_wp/), &
+                                             shape=(/2,MISR_N_CTH/))
+
+
+    !
+    ! The following code was modifed by Roj with implementation of quickbeam V3
+    !   (1) use ifdef to support more than one microphyscis scheme 
+    !   (2) added constants  microphysic_scheme_name, LOAD_scale_LUTs, and SAVE_scale_LUTs 
+    !
+
+    ! directory where LUTs will be stored
+    character*120 :: RADAR_SIM_LUT_DIRECTORY = './'
+
+!CNam: Only MMF_V3_SINGLE_MOMENT; not MMF_V3p5_TWO_MOMENT
+#define MMF_V3_SINGLE_MOMENT 1    
+#ifdef MMF_V3_SINGLE_MOMENT
+
+    !        
+    !  Table hclass for quickbeam to support one-moment (bulk) microphysics scheme used by MMF V3.0 & V3.5
+    !
+
+    !
+    ! NOTE:  if ANY value in this section of code is changed, the existing LUT 
+    !        (i.e., the associated *.dat file) MUST be deleted so that a NEW
+    !        LUT will be created !!!
+    !
+    character*120 :: RADAR_SIM_MICROPHYSICS_SCHEME_NAME = 'MMF_v3_single_moment'
+
+    logical :: RADAR_SIM_LOAD_scale_LUTs_flag   = .false.
+    logical :: RADAR_SIM_UPDATE_scale_LUTs_flag = .false.
+    integer,parameter :: N_HYDRO = 9
+
+    integer :: HCLASS_TYPE(N_HYDRO),HCLASS_PHASE(N_HYDRO)
+
+    real(wp) :: HCLASS_DMIN(N_HYDRO),HCLASS_DMAX(N_HYDRO), &
+            HCLASS_APM(N_HYDRO),HCLASS_BPM(N_HYDRO),HCLASS_RHO(N_HYDRO), &
+            HCLASS_P1(N_HYDRO),HCLASS_P2(N_HYDRO),HCLASS_P3(N_HYDRO)
+
+    ! HCLASS_CP is not used in the version of Quickbeam included in COSP
+    !                   LSL    LSI      LSR     LSS   CVL    CVI   CVR     CVS   LSG
+    data HCLASS_TYPE/    5,      1,      2,      2,     5,     1,   2,      2,    2/
+    data HCLASS_PHASE/   0,      1,      0,      1,     0,     1,   0,      1,    1/
+    data HCLASS_DMIN/   -1,     -1,     -1,     -1,    -1,    -1,   -1,    -1,   -1/
+    data HCLASS_DMAX/   -1,     -1,     -1,     -1,    -1,    -1,   -1,    -1,   -1/
+    data HCLASS_APM/   524,  110.8,    524,     -1,   524, 110.8,  524,    -1,   -1/
+    data HCLASS_BPM/     3,   2.91,      3,     -1,     3,  2.91,    3,    -1,   -1/
+    data HCLASS_RHO/    -1,     -1,     -1,    100,    -1,    -1,   -1,   100,  400/
+    data HCLASS_P1/     -1,     -1,   8.e6,   3.e6,    -1,    -1, 8.e6,  3.e6, 4.e6/
+    data HCLASS_P2/      6,     40,     -1,      -1,    6,    40,   -1,    -1,   -1/
+    data HCLASS_P3/    0.3,      2,     -1,      -1,  0.3,     2,   -1,    -1,   -1/
+
+    ! NOTES on HCLASS variables
+    !
+    ! TYPE - Set to
+    ! 1 for modified gamma distribution,
+    ! 2 for exponential distribution,
+    ! 3 for power law distribution,
+    ! 4 for monodisperse distribution,
+    ! 5 for lognormal distribution.
+
+    ! PHASE - Set to 0 for liquid, 1 for ice.
+
+    ! DMIN - The minimum drop size for this class (micron), ignored for monodisperse.
+    ! DMAX - The maximum drop size for this class (micron), ignored for monodisperse.
+    ! Important note: The settings for DMIN and DMAX are
+    ! ignored in the current version for all distributions except for power
+    ! law. Except when the power law distribution is used, particle size
+    ! is fixed to vary from zero to infinity, a restriction that is expected
+    ! to be lifted in future versions. A placeholder must still be specified
+    ! for each.
+
+    ! Density of particles is given by apm*D^bpm or a fixed value rho. ONLY specify ONE of these two!!
+    ! APM - The alpha_m coefficient in equation (1) (kg m**-beta_m )
+    ! BPM - The beta_m coefficient in equation (1), see section 4.1.
+
+    ! RHO - Hydrometeor density (kg m-3 ).
+
+    ! P1, P2, P3 - are default distribution parameters that depend on the type
+    ! of distribution (see quickmbeam documentation for more information)
+    !
+    ! Modified Gamma (must set P3 and one of P1 or P2)
+    ! P1 - Set to the total particle number concentration Nt /rho_a (kg-1 ), where
+    ! rho_a is the density of air in the radar volume.
+    ! P2 - Set to the particle mean diameter D (micron).
+    ! P3 - Set to the distribution width nu.
+    !
+    ! Exponetial (set one of)
+    ! P1 - Set to a constant intercept parameter N0 (m-4).
+    ! P2 - Set to a constant lambda (micron-1).
+    !
+    ! Power Law
+    ! P1 - Set this to the value of a constant power law parameter br
+    !
+    ! Monodisperse
+    ! P1 - Set to a constant diameter D0 (micron) = Re.
+    !
+    ! Log-normal (must set P3 and one of P1 or P2)
+    ! P1 - Set to the total particle number concentration Nt /rho_a (kg-1 )
+    ! P2 - Set to the geometric mean particle radius rg (micron).
+    ! P3 - Set to the natural logarithm of the geometric standard deviation.
+    !
+
+
+    real(wp),dimension(N_HYDRO) :: N_ax,N_bx,alpha_x,c_x,d_x,g_x,a_x,b_x,gamma_1,gamma_2,gamma_3,gamma_4
+
+    ! Microphysical settings for the precipitation flux to mixing ratio conversion
+    !                LSL    LSI       LSR       LSS   CVL    CVI       CVR       CVS      LSG
+    data N_ax/       -1._wp, -1._wp,   8.e6_wp,   3.e6_wp,-1._wp, -1._wp,   8.e6_wp,   3.e6_wp,   4.e6_wp/
+    data N_bx/       -1._wp, -1._wp,    0.0_wp,    0.0_wp,-1._wp, -1._wp,    0.0_wp,    0.0_wp,    0.0_wp/
+    data alpha_x/    -1._wp, -1._wp,    0.0_wp,    0.0_wp,-1._wp, -1._wp,    0.0_wp,    0.0_wp,    0.0_wp/
+    data c_x/        -1._wp, -1._wp,  842.0_wp,   4.84_wp,-1._wp, -1._wp,  842.0_wp,   4.84_wp,   94.5_wp/
+    data d_x/        -1._wp, -1._wp,    0.8_wp,   0.25_wp,-1._wp, -1._wp,    0.8_wp,   0.25_wp,    0.5_wp/
+    data g_x/        -1._wp, -1._wp,    0.5_wp,    0.5_wp,-1._wp, -1._wp,    0.5_wp,    0.5_wp,    0.5_wp/
+    data a_x/        -1._wp, -1._wp,  524.0_wp,  52.36_wp,-1._wp, -1._wp,  524.0_wp,  52.36_wp, 209.44_wp/
+    data b_x/        -1._wp, -1._wp,    3.0_wp,    3.0_wp,-1._wp, -1._wp,    3.0_wp,    3.0_wp,    3.0_wp/
+    data gamma_1/    -1._wp, -1._wp, 17.83725_wp, 8.284701_wp,-1._wp, -1._wp, 17.83725_wp, 8.284701_wp, 11.63230_wp/
+    data gamma_2/    -1._wp, -1._wp,    6.0_wp,    6.0_wp,-1._wp, -1._wp,    6.0_wp,    6.0_wp,    6.0_wp/
+    data gamma_3/    -1._wp, -1._wp,    2.0_wp,    2.0_wp,-1._wp, -1._wp,    2.0_wp,    2.0_wp,    2.0_wp/
+    data gamma_4/    -1._wp, -1._wp,    6.0_wp,    6.0_wp,-1._wp, -1._wp,    6.0_wp,    6.0_wp,    6.0_wp/
+
+
+
+#endif
+
+
+#ifdef MMF_V3p5_TWO_MOMENT
+
+    !
+    !  Table hclass for quickbeam to support two-moment "morrison" microphysics scheme used by V3.5 (SAM 6.8)
+    !
+    !  This Number concentriation Np in [1/kg] MUST be input to COSP/radar simulator
+    !
+    !  NOTE:  Be sure to check that the ice-density (rho) set it this tables matches what you used
+    !
+
+    !
+    ! NOTE:  if ANY value in this section of code is changed, the existing LUT 
+    !        (i.e., the associated *.dat file) MUST be deleted so that a NEW
+    !        LUT will be created !!!
+    !
+    character*120 :: RADAR_SIM_MICROPHYSICS_SCHEME_NAME = 'MMF_v3.5_two_moment'
+
+    logical :: RADAR_SIM_LOAD_scale_LUTs_flag   = .false.
+    logical :: RADAR_SIM_UPDATE_scale_LUTs_flag = .false.
+
+    integer,parameter :: N_HYDRO = 9
+
+    integer :: HCLASS_TYPE(N_HYDRO),HCLASS_PHASE(N_HYDRO) 
 
-    !levels for vgrid
-    INTEGER :: Nlr = 40
+    real(wp) :: HCLASS_DMIN(N_HYDRO),HCLASS_DMAX(N_HYDRO), &           
+            HCLASS_APM(N_HYDRO),HCLASS_BPM(N_HYDRO),HCLASS_RHO(N_HYDRO), &
+            HCLASS_P1(N_HYDRO),HCLASS_P2(N_HYDRO),HCLASS_P3(N_HYDRO)
 
-    LOGICAL :: use_vgrid = .TRUE. ! DON'T CHANGE output on 40 level satellite grid?
+    ! HCLASS_CP is not used in the version of Quickbeam included in COSP
+    !                   LSL    LSI      LSR     LSS   CVL    CVI   CVR     CVS   LSG
+    data HCLASS_TYPE/    1,      1,      1,      1,     1,     1,    1,      1,    1/
+    data HCLASS_PHASE/   0,      1,      0,      1,     0,     1,    0,      1,    1/
+    data HCLASS_DMIN/   -1,     -1,     -1,     -1,    -1,    -1,   -1,     -1,   -1/
+    data HCLASS_DMAX/   -1,     -1,     -1,     -1,    -1,    -1,   -1,     -1,   -1/
+    data HCLASS_APM/   524,     -1,    524,     -1,   524,    -1,  524,     -1,   -1/
+    data HCLASS_BPM/     3,     -1,      3,     -1,     3,    -1,    3,     -1,   -1/
+    data HCLASS_RHO/    -1,    500,     -1,    100,    -1,   500,   -1,    100,  900/
+    data HCLASS_P1/     -1,     -1,     -1,     -1,    -1,    -1,   -1,     -1,   -1/
+    data HCLASS_P2/     -1,     -1,     -1,     -1,    -1,    -1,   -1,     -1,   -1/
+    data HCLASS_P3/     -2,      1,      1,      1,    -2,     1,    1,      1,    1/
+    ! Note: value of "-2" for HCLASS_P3 uses martin 1994 parameteriztion of gamma function width with Number concentration
+#endif
 
 END MODULE mo_cosp_constants
diff --git a/src/mo_cosp_lidar.f90 b/src/mo_cosp_lidar.f90
index d326fb5..8a45407 100644
--- a/src/mo_cosp_lidar.f90
+++ b/src/mo_cosp_lidar.f90
@@ -1,88 +1,92 @@
-! (c) COPYRIGHT British Crown / Met Office 2008  
-! Please refer to Met_Office_license.txt for details.
+! (c) British Crown Copyright 2008, the Met Office.
+! All rights reserved.
+! $Revision: 88 $, $Date: 2013-11-13 15:08:38 +0100 (Mi, 13. Nov 2013) $
+! $URL: http://cfmip-obs-sim.googlecode.com/svn/stable/v1.4.0/cosp_lidar.F90 $
+! 
+! Redistribution and use in source and binary forms, with or without modification, are permitted 
+! provided that the following conditions are met:
+! 
+!     * Redistributions of source code must retain the above copyright notice, this list 
+!       of conditions and the following disclaimer.
+!     * Redistributions in binary form must reproduce the above copyright notice, this list
+!       of conditions and the following disclaimer in the documentation and/or other materials 
+!       provided with the distribution.
+!     * Neither the name of the Met Office nor the names of its contributors may be used 
+!       to endorse or promote products derived from this software without specific prior written 
+!       permission.
+! 
+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
+! IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
+! FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
+! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
+! IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
+! OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 !
 ! History:
 ! Jul 2007 - A. Bodas-Salcedo - Initial version
 ! Oct 2008 - S. Bony          - Instructions "Call for large-scale cloud" removed  -> sgx%frac_out is used instead.
 !                               Call lidar_simulator changed (lsca, gbx%cca and depol removed; 
 !                               frac_out changed in sgx%frac_out)
+! Jun 2011 - G. Cesana        - Added betaperp_tot argument
 !
-! 
-MODULE mo_cosp_lidar
-
-  USE mo_cosp_constants
-  USE mo_kind,          ONLY: dp
-
+ 
+MODULE MO_COSP_LIDAR
+  USE MO_COSP_CONSTANTS
+  USE MO_COSP_TYPES
+  USE MO_KIND,		ONLY: wp
   IMPLICIT NONE
 
 CONTAINS
 
+
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 !------------------- SUBROUTINE COSP_LIDAR ------------------------
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-SUBROUTINE cosp_lidar( kbdim,Ncolumns,klev,            &
-!gbx
-                      lidar_ice_type, Reff,            &
-                      ph, tca, mr_hydro, p, T,         &
-!sgx, sglidar                       
-                      frac_out,                        &
-                      beta_mol, beta_tot, tau_tot, refl )
+SUBROUTINE COSP_LIDAR(gbx,sgx,sghydro,y)
   
   ! Arguments
-   INTEGER, INTENT(IN) :: kbdim,Ncolumns,klev
- 
-!gbx
-   INTEGER, INTENT(IN) :: lidar_ice_type
-   REAL(dp), INTENT(INOUT) :: Reff(kbdim,klev,N_hydro)
-   REAL(dp), INTENT(INOUT) :: p(kbdim,klev)
-   REAL(dp), INTENT(INOUT) :: ph(kbdim,klev)
-   REAL(dp), INTENT(INOUT) :: tca(kbdim,klev)
-   REAL(dp), INTENT(INOUT) :: T(kbdim,klev) 
-
-   REAL(dp), INTENT(IN) :: mr_hydro(kbdim,Ncolumns,klev,N_hydro) !sghydro?
-
-!sglidar
-   REAL(dp) :: beta_tot(kbdim,Ncolumns,klev)
-   REAL(dp) :: tau_tot(kbdim,Ncolumns,klev)
-   REAL(dp) :: refl(kbdim,Ncolumns,PARASOL_NREFL)
-   REAL(dp) :: beta_mol(kbdim,klev)
-
-! subgrid sgx
-   REAL(dp) :: frac_out(kbdim,Ncolumns,klev)
-
+  type(cosp_gridbox),intent(in) :: gbx  ! Gridbox info
+  type(cosp_subgrid),intent(in) :: sgx  ! Subgrid info
+  type(cosp_sghydro),intent(in) :: sghydro  ! Subgrid info for hydrometeors
+  type(cosp_sglidar),intent(inout) :: y ! Subgrid output
+  
   ! Local variables 
-  INTEGER :: i
-  REAL(dp) :: presf(kbdim, klev + 1)
-  REAL(dp), DIMENSION(kbdim, klev) :: lsca,mr_ll,mr_li
-  REAL(dp), DIMENSION(kbdim, klev) :: beta_tot_l,tau_tot_l
-  REAL(dp), DIMENSION(kbdim, PARASOL_NREFL)  :: refle_l
- 
-  presf(:,1:klev) = ph
-  presf(:,klev + 1) = 0.0_dp
-  lsca = tca
- 
-   beta_tot_l=0._dp
-   tau_tot_l=0._dp
-   refle_l=0._dp
+  integer :: i
+  real(wp), dimension(sgx%Npoints, sgx%Nlevels+1) :: presf
+  real(wp), dimension(sgx%Npoints, sgx%Nlevels) :: lsca,mr_ll,mr_li,mr_cl,mr_ci
+  real(wp), dimension(sgx%Npoints, sgx%Nlevels) :: beta_tot,tau_tot
+  real(wp), dimension(sgx%Npoints, sgx%Nlevels) :: betaperp_tot
+  real(wp), dimension(sgx%Npoints, PARASOL_NREFL)  :: refle
 
+  presf(:,1:sgx%Nlevels+1) = gbx%ph !CNam: orig presf(:,1:sgx%Nlevels)
+!  presf(:,sgx%Nlevels+1) = 0.0_wp  CNam
 
-  DO i=1,Ncolumns
+  lsca = gbx%tca-gbx%cca
+  
+  do i=1,sgx%Ncolumns
       ! Temporary arrays for simulator call
-      mr_ll(:,:) = mr_hydro(:,i,:,I_LSCLIQ)
-      mr_li(:,:) = mr_hydro(:,i,:,I_LSCICE)
-      CALL cosp_lidar_simulator(kbdim, klev, 2 ,PARASOL_NREFL  &
-                 , p, presf, T & 
-                 , mr_ll, mr_li &
-                 , Reff(:,:,I_LSCLIQ), Reff(:,:,I_LSCICE) &
-!!                 , frac_out, lidar_ice_type, beta_mol, beta_tot_l, tau_tot_l  &
-                 , lidar_ice_type, beta_mol, beta_tot_l, tau_tot_l  &
-                 , refle_l ) ! reflectance
+      mr_ll(:,:) = sghydro%mr_hydro(:,i,:,I_LSCLIQ)
+      mr_li(:,:) = sghydro%mr_hydro(:,i,:,I_LSCICE)
+      mr_cl(:,:) = sghydro%mr_hydro(:,i,:,I_CVCLIQ)
+      mr_ci(:,:) = sghydro%mr_hydro(:,i,:,I_CVCICE)
+!            PRINT *, 'mr_ll ',mr_ll
+      call cosp_lidar_simulator(sgx%Npoints, sgx%Nlevels, 4 ,PARASOL_NREFL, LIDAR_UNDEF  &
+                 , gbx%p, presf, gbx%T & 
+                 , mr_ll, mr_li, mr_cl, mr_ci &
+                 , gbx%Reff(:,:,I_LSCLIQ), gbx%Reff(:,:,I_LSCICE) & 
+                 , gbx%Reff(:,:,I_CVCLIQ), gbx%Reff(:,:,I_CVCICE) &
+                 , gbx%lidar_ice_type, y%beta_mol, beta_tot &
+                 , betaperp_tot, tau_tot, refle )
       
-      beta_tot(:,i,:) = beta_tot_l(:,:)
-      tau_tot(:,i,:)  = tau_tot_l(:,:)
-      refl(:,i,:)     = refle_l(:,:)
-  ENDDO
+      y%betaperp_tot(:,i,:) = betaperp_tot(:,:)
+      y%beta_tot(:,i,:) = beta_tot(:,:)
+      y%tau_tot(:,i,:)  = tau_tot(:,:)
+      y%refl(:,i,:)     = refle(:,:)
+  enddo
   
-END SUBROUTINE cosp_lidar
+END SUBROUTINE COSP_LIDAR
 
-END MODULE mo_cosp_lidar
+END MODULE MO_COSP_LIDAR
diff --git a/src/mo_cosp_llnl_stats.f90 b/src/mo_cosp_llnl_stats.f90
index 596be94..88c93b9 100644
--- a/src/mo_cosp_llnl_stats.f90
+++ b/src/mo_cosp_llnl_stats.f90
@@ -1,6 +1,38 @@
+! (c) 2008, Lawrence Livermore National Security Limited Liability Corporation.
+! All rights reserved.
+! $Revision: 88 $, $Date: 2013-11-13 15:08:38 +0100 (Mi, 13. Nov 2013) $
+! $URL: http://cfmip-obs-sim.googlecode.com/svn/stable/v1.4.0/llnl/llnl_stats.F90 $
+! 
+! Redistribution and use in source and binary forms, with or without modification, are permitted 
+! provided that the following conditions are met:
+! 
+!     * Redistributions of source code must retain the above copyright notice, this list 
+!       of conditions and the following disclaimer.
+!     * Redistributions in binary form must reproduce the above copyright notice, this list 
+!       of conditions and the following disclaimer in the documentation and/or other materials 
+!       provided with the distribution.
+!     * Neither the name of the Lawrence Livermore National Security Limited Liability Corporation 
+!       nor the names of its contributors may be used to endorse or promote products derived from 
+!       this software without specific prior written permission.
+! 
+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
+! IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
+! FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
+! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
+! IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
+! OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+!
+! History
+!
+! Jan 2013 - G. Cesana        - Added betaperp_tot and temp_tot arguments 
+!
+
 MODULE mo_cosp_llnl_stats
 
-  USE mo_kind, ONLY: dp
+  USE mo_kind, ONLY: wp
+  USE mo_cosp_constants
 
   IMPLICIT NONE
 
@@ -11,12 +43,14 @@ CONTAINS
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 FUNCTION cosp_cfad(Npoints,Ncolumns,Nlevels,Nbins,x,xmin,xmax,bmin,bwidth)
 
-   INTEGER, INTENT(in) :: Npoints,Ncolumns,Nlevels,Nbins
-   real(dp), DIMENSION(Npoints,Nbins,Nlevels) :: cosp_cfad
    ! Input arguments
-   REAL(dp), DIMENSION(Npoints,Ncolumns,Nlevels), INTENT(in) :: x
-   REAL(dp), INTENT(in) :: xmin,xmax 
-   REAL(dp), INTENT(in) :: bmin,bwidth
+   INTEGER, INTENT(in) :: Npoints,Ncolumns,Nlevels,Nbins
+   REAL(wp), INTENT(in) :: x(Npoints,Ncolumns,Nlevels)
+   REAL(wp), INTENT(in) :: xmin,xmax 
+   REAL(wp), INTENT(in) :: bmin,bwidth
+
+   REAL(wp) :: cosp_cfad(Npoints,Nbins,Nlevels)
+   REAL(wp) :: dbbval_ext(0:Nbins)
    ! Local variables
    INTEGER :: i, j, k
    INTEGER :: ibin
@@ -34,7 +68,7 @@ FUNCTION cosp_cfad(Npoints,Ncolumns,Nlevels,Nbins,x,xmin,xmax,bmin,bwidth)
    !
    ! Output: 2D histogram on each horizontal point (Npoints,Nbins,Nlevels)
 
-   cosp_cfad = 0.0_dp
+   cosp_cfad(:,:,:) = 0.0_wp
    ! bwidth intervals in the range [bmin,bmax=bmin+Nbins*hwidth]
    ! Valid x values smaller than bmin and larger than bmax are set 
    ! into the smallest bin and largest bin, respectively.
@@ -42,18 +76,78 @@ FUNCTION cosp_cfad(Npoints,Ncolumns,Nlevels,Nbins,x,xmin,xmax,bmin,bwidth)
    DO j = 1, Nlevels, 1
       DO k = 1, Ncolumns, 1
          DO i = 1, Npoints, 1 
-            IF ((x(i,k,j) >= xmin) .and. (x(i,k,j) <= xmax)) THEN 
-               ibin = ceiling((x(i,k,j) - bmin)/bwidth)
-               IF (ibin > Nbins) ibin = Nbins
-               IF (ibin < 1)     ibin = 1
-               cosp_cfad(i,ibin,j) = cosp_cfad(i,ibin,j) + 1.0_dp 
-            ENDIF
+            IF ((x(i,k,j) >= xmin) .and. (x(i,k,j) <= xmax)) THEN !CNam switched order
+                  ibin = ceiling((x(i,k,j) - bmin)/bwidth)
+                  IF (ibin > Nbins) ibin = Nbins
+                  IF (ibin < 1)     ibin = 1
+                  cosp_cfad(i,ibin,j) = cosp_cfad(i,ibin,j) + 1.0_wp 
+            ELSEIF (x(i,k,j) == R_GROUND) THEN
+                  cosp_cfad(i,:,j) = R_UNDEF
+            ENDIF ! 
          ENDDO  !i
       ENDDO  !k
    ENDDO  !j
 
-   cosp_cfad = cosp_cfad / REAL(Ncolumns,dp)
+   !CNam: was   cosp_cfad = cosp_cfad / REAL(Ncolumns,wp)
+   where ((cosp_cfad /= R_UNDEF).and.(cosp_cfad /= 0.0_wp)) cosp_cfad = cosp_cfad / REAL(Ncolumns,wp)
 
 END FUNCTION cosp_cfad
 
+
+!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+!------------- SUBROUTINE COSP_LIDAR_ONLY_CLOUD -----------------
+!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+SUBROUTINE cosp_lidar_only_cloud(Npoints,Ncolumns,Nlevels,temp_tot,beta_tot, &
+                   betaperp_tot,beta_mol,Ze_tot,lidar_only_freq_cloud,tcc)
+
+   USE mo_kind,           ONLY: wp
+
+   implicit none
+
+   ! Input arguments
+   INTEGER,intent(in) :: Npoints,Ncolumns,Nlevels
+   REAL(wp), dimension(Npoints,Nlevels),intent(in) :: beta_mol   ! Molecular backscatter
+   REAL(wp), dimension(Npoints,Ncolumns,Nlevels),intent(in) :: beta_tot   ! Total backscattered signal
+   REAL(wp), dimension(Npoints,Ncolumns,Nlevels),intent(in) :: temp_tot   ! Total backscattered signal
+   REAL(wp), dimension(Npoints,Ncolumns,Nlevels),intent(in) :: betaperp_tot   ! perpendicular Total backscattered signal
+   REAL(wp), dimension(Npoints,Ncolumns,Nlevels),intent(in) :: Ze_tot     ! Radar reflectivity
+   ! Output arguments
+   REAL(wp), dimension(Npoints,Nlevels),intent(out) :: lidar_only_freq_cloud
+   REAL(wp), dimension(Npoints),intent(out) :: tcc
+
+   ! local variables
+   REAL(wp) :: sc_ratio
+   REAL(wp) :: s_cld, s_att
+   parameter (S_cld = 5.0_wp)
+   parameter (s_att = 0.01_wp)
+   INTEGER :: flag_sat !first saturated level encountered from top
+   INTEGER :: flag_cld !cloudy column
+   INTEGER :: pr,i,j
+
+   lidar_only_freq_cloud = 0.0_wp
+   tcc = 0.0_wp
+   do pr=1,Npoints
+     do i=1,Ncolumns
+       flag_sat = 0
+       flag_cld = 0
+       do j=Nlevels,1,-1 !top->surf
+        sc_ratio = beta_tot(pr,i,j)/beta_mol(pr,j)
+        if ((sc_ratio .le. s_att) .and. (flag_sat .eq. 0)) flag_sat = j
+        if (Ze_tot(pr,i,j) .lt. -30._wp) then  !radar can't detect cloud
+         if ( (sc_ratio .gt. s_cld) .or. (flag_sat .eq. j) ) then  !lidar sense cloud
+            lidar_only_freq_cloud(pr,j)=lidar_only_freq_cloud(pr,j)+1._wp !top->surf
+            flag_cld=1
+         endif
+        else  !radar sense cloud (z%Ze_tot(pr,i,j) .ge. -30.)
+           flag_cld=1
+        endif
+       enddo !levels
+       if (flag_cld .eq. 1) tcc(pr)=tcc(pr)+1._wp
+     enddo !columns
+   enddo !points
+   lidar_only_freq_cloud=lidar_only_freq_cloud/Ncolumns
+   tcc=tcc/Ncolumns
+
+END SUBROUTINE COSP_LIDAR_ONLY_CLOUD
+
 END MODULE mo_cosp_llnl_stats
diff --git a/src/mo_cosp_lmd_ipsl_stats.f90 b/src/mo_cosp_lmd_ipsl_stats.f90
index b85df88..ce13ae0 100644
--- a/src/mo_cosp_lmd_ipsl_stats.f90
+++ b/src/mo_cosp_lmd_ipsl_stats.f90
@@ -1,106 +1,152 @@
+!>
+!! @par Copyright
+!! This code is subject to the MPI-M-Software - License - Agreement in it's most recent form.
+!! Please see URL http://www.mpimet.mpg.de/en/science/models/model-distribution.html and the
+!! file COPYING in the root of the source tree for this code.
+!! Where software is supplied by third parties, it is indicated in the headers of the routines.
+!!
+! Copyright (c) 2009, Centre National de la Recherche Scientifique
+! All rights reserved.
+! $Revision: 88 $, $Date: 2013-11-13 15:08:38 +0100 (Mi, 13. Nov 2013) $
+! $URL: http://cfmip-obs-sim.googlecode.com/svn/stable/v1.4.0/actsim/lmd_ipsl_stats.F90 $
+!
+! Redistribution and use in source and binary forms, with or without modification, are permitted
+! provided that the following conditions are met:
+!
+!     * Redistributions of source code must retain the above copyright notice, this list
+!       of conditions and the following disclaimer.
+!     * Redistributions in binary form must reproduce the above copyright notice, this list
+!       of conditions and the following disclaimer in the documentation and/or other materials
+!       provided with the distribution.
+!     * Neither the name of the LMD/IPSL/CNRS/UPMC nor the names of its
+!       contributors may be used to endorse or promote products derived from this software without
+!       specific prior written permission.
+!
+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+! IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+! FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+! IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+! OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 !------------------------------------------------------------------------------------
 ! Authors: Sandrine Bony and Helene Chepfer (LMD/IPSL, CNRS, UPMC, France).
 !------------------------------------------------------------------------------------
 MODULE mo_cosp_lmd_ipsl_stats
 
   USE mo_cosp_llnl_stats
-  USE mo_kind,        ONLY: dp
+  USE mo_kind,        ONLY: wp
   USE mo_memory_g3b,  ONLY: slm
 
   IMPLICIT NONE
 
 CONTAINS
 
-      SUBROUTINE diag_lidar(npoints,ncol,llm,max_bin,nrefl & ! parasol
-                  ,pnorm,pmol,refl,land,pplay,undef,ok_lidar_cfad & !parasol,
-                  ,cfad2,srbval,ncat,lidarcld,cldlayer,parasolrefl) ! parasol
+      SUBROUTINE diag_lidar(npoints,ncol,llm,max_bin,nrefl &
+                  ,tmp,pnorm,pnorm_perp,pmol,refl,land,pplay,undef,ok_lidar_cfad &
+                  ,cfad2,srbval,ncat,lidarcld,lidarcldphase,cldlayer,cldlayerphase &
+                  ,lidarcldtmp,parasolrefl)
 
-! c-----------------------------------------------------------------------------------
+! -----------------------------------------------------------------------------------
 ! Lidar outputs :
-! 
-! Diagnose cloud fraction (3D cloud fraction + low/middle/high/total cloud fraction
-! from the lidar signals (ATB and molecular ATB) computed from model outputs
+!
+! Diagnose cloud fraction (3D cloud fraction + low/middle/high/total cloud fraction)
+! and phase cloud fraction (3D, low/mid/high/total and 3D temperature)
+! from the lidar signals (ATB, ATBperp and molecular ATB) computed from model outputs
 !      +
 ! Compute CFADs of lidar scattering ratio SR and of depolarization index
-! 
+!
 ! Authors: Sandrine Bony and Helene Chepfer (LMD/IPSL, CNRS, UPMC, France).
 !
-! December 2008, S. Bony,  H. Chepfer and J-L. Dufresne : 
+! December 2008, S. Bony,  H. Chepfer and J-L. Dufresne :
 ! - change of the cloud detection threshold S_cld from 3 to 5, for better
 ! with both day and night observations. The optical thinest clouds are missed.
 ! - remove of the detection of the first fully attenuated layer encountered from above.
 ! December 2008, A. Bodas-Salcedo:
 ! - Dimensions of pmol reduced to (npoints,llm)
+! August 2009, A. Bodas-Salcedo:
+! - Warning message regarding PARASOL being valid only over ocean deleted.
+! February 2010, A. Bodas-Salcedo:
+! - Undef passed into cosp_cfad_sr
+! June 2010, T. Yokohata, T. Nishimura and K. Ogochi
+! Optimisation of COSP_CFAD_SR
 !
-! Version 1.0 (June 2007)
-! Version 1.1 (May 2008)
-! Version 1.2 (June 2008)
-! Version 2.0 (October 2008)
-! Version 2.1 (December 2008)
-! c------------------------------------------------------------------------------------
+! January 2013, G. Cesana, H. Chepfer:
+! - Add the perpendicular component of the backscattered signal (pnorm_perp) in the arguments
+! - Add the temperature (tmp) in the arguments
+! - Add the 3D Phase cloud fraction (lidarcldphase) in the arguments
+! - Add the Phase low mid high cloud fraction (cldlayerphase) in the arguments
+! - Add the 3D Phase cloud fraction as a function of temperature (lidarcldtmp) in the arguments
+! - Modification of the phase diagnosis within the COSP_CLDFRAC routine to integrate the phase
+!   diagnosis (3D, low/mid/high, 3D temperature)
+! Reference: Cesana G. and H. Chepfer (2013): Evaluation of the cloud water phase
+! in a climate model using CALIPSO-GOCCP, J. Geophys. Res., doi: 10.1002/jgrd.50376
+!
+! ------------------------------------------------------------------------------------
+
 ! c inputs :
       INTEGER :: npoints
       INTEGER :: ncol
-      INTEGER :: llm
+      INTEGER :: llm                   ! CNam: Nlr vs. Nlevels
       INTEGER :: max_bin               ! nb of bins for SR CFADs
       INTEGER :: ncat                  ! nb of cloud layer types (low,mid,high,total)
       INTEGER :: nrefl                 ! nb of solar zenith angles for parasol reflectances ! parasol
 
-      REAL(dp) :: undef                    ! undefined value
-      REAL(dp) :: pnorm(npoints,ncol,llm)  ! lidar ATB 
-      REAL(dp) :: pmol(npoints,llm)   ! molecular ATB
-      REAL(dp) :: land(npoints)            ! Land-Sea mask [0:Ocean 1:Land]
-      REAL(dp) :: pplay(npoints,llm)       ! pressure on model levels (Pa)
-      LOGICAL ::  ok_lidar_cfad         ! true if lidar CFAD diagnostics need to be computed
-      REAL(dp) :: refl(npoints,ncol,nrefl) ! subgrid parasol reflectance ! parasol
+      REAL(wp) :: undef                    ! undefined value
+      REAL(wp) :: pnorm(npoints,ncol,llm)  ! lidar ATB 
+      REAL(wp) :: pmol(npoints,llm)        ! molecular ATB
+      REAL(wp) :: land(npoints)            ! Land-Sea mask [0:Ocean 1:Land]
+      REAL(wp) :: pplay(npoints,llm)       ! pressure on model levels (Pa)
+      LOGICAL ::  ok_lidar_cfad            ! true if lidar CFAD diagnostics need to be computed
+      REAL(wp) :: refl(npoints,ncol,nrefl) ! subgrid parasol reflectance ! parasol
+      REAL(wp) :: tmp(npoints,llm)         ! temp at each levels
+      REAL(wp) :: pnorm_perp(npoints,ncol,llm)  ! lidar perpendicular ATB
 
 ! c outputs :
-      REAL(dp) :: lidarcld(npoints,llm)     ! 3D "lidar" cloud fraction 
-      REAL(dp) :: cldlayer(npoints,ncat)    ! "lidar" cloud fraction (low, mid, high, total)
-      REAL(dp) :: cfad2(npoints,max_bin,llm) ! CFADs of SR  
-      REAL(dp) :: srbval(max_bin)           ! SR bins in CFADs  
-      REAL(dp) :: parasolrefl(npoints,nrefl)! grid-averaged parasol reflectance ! parasol
+      REAL(wp) :: lidarcld(npoints,llm)     ! 3D "lidar" cloud fraction 
+      REAL(wp) :: sub(npoints,llm)          ! 3D "lidar" indice
+      REAL(wp) :: cldlayer(npoints,ncat)    ! "lidar" cloud_layer fraction (low, mid, high, total)
+
+      REAL(wp) :: cfad2(npoints,max_bin,llm)! CFADs of SR  
+      REAL(wp) :: srbval(max_bin)           ! SR bins in CFADs  
+      REAL(wp) :: parasolrefl(npoints,nrefl)! grid-averaged parasol reflectance ! parasol
 
 
 ! c threshold for cloud detection :
-      REAL(dp), PARAMETER :: S_clr = 1.2_dp 
-      REAL(dp), PARAMETER :: S_cld = 5.0_dp !Threshold for cloud detection (Dec 2008)
-!      parameter (S_cld = 3.0_dp)
-      REAL(dp), PARAMETER :: S_att = 0.01_dp
+      REAL(wp), PARAMETER :: S_clr = 1.2_wp 
+      REAL(wp), PARAMETER :: S_cld = 5.0_wp !Threshold for cloud detection (Dec 2008)
+      REAL(wp), PARAMETER :: S_att = 0.01_wp
 
 ! c local variables :
-      INTEGER :: ic,k
-      REAL(dp) :: x3d(npoints,ncol,llm)
-      REAL(dp) :: x3d_c(npoints,llm),pnorm_c(npoints,llm)
-      REAL(dp) :: xmax
-!
+      INTEGER :: ic,k,i,j
+      REAL(wp) :: x3d(npoints,ncol,llm)
+      REAL(wp) :: x3d_c(npoints,llm),pnorm_c(npoints,llm)
+      REAL(wp) :: xmax
+
+! Output variables
+      INTEGER,PARAMETER :: nphase = 6 ! nb of cloud layer phase types (ice,liquid,undefined,false ice,false liquid,Percent of ice)
+      REAL(wp) :: lidarcldphase(npoints,llm,nphase)   ! 3D "lidar" phase cloud fraction
+      REAL(wp) :: lidarcldtmp(npoints,llm,5)          ! 3D "lidar" phase cloud fraction as a function of temp
+      REAL(wp) :: cldlayerphase(npoints,ncat,nphase)  ! "lidar" phase low mid high cloud fraction 
+
+! SR detection threshold
+      REAL(wp),PARAMETER  ::  S_cld_att = 30._wp ! New threshold for undefine cloud phase detection	
+
+
+
 ! c -------------------------------------------------------
 ! c 0- Initializations
 ! c -------------------------------------------------------
 !
-! Parasol reflectance algorithm is not valid over land. Write
-! a warning if there is no land. Landmask [0 - Ocean, 1 - Land] 
-!CNam:      IF ( MAXVAL(land(:)) .EQ. 0.0_dp) THEN
-!      IF ( MAXVAL(land(:)) .GT. 0.0_dp) THEN
-!          WRITE (*,*) 'WARNING. PARASOL reflectance is not valid over land' &
-!            & ,' and there is only land'
-!      END IF
-
-      xmax=undef-1.0_dp
+      xmax=undef-1.0_wp
 
 ! c -------------------------------------------------------
 ! c 1- Lidar scattering ratio :
 ! c -------------------------------------------------------
-!
-!       where ((pnorm.lt.xmax) .and. (pmol.lt.xmax) .and. (pmol.gt. 0.0 )) 
-!          x3d = pnorm/pmol
-!       elsewhere
-!           x3d = undef
-!       end where
-! A.B-S: pmol reduced to 2D (npoints,llm) (Dec 08)
       DO ic = 1, ncol
         pnorm_c = pnorm(:,ic,:)
-        WHERE ((pnorm_c.lt.xmax) .and. (pmol.lt.xmax) .and. (pmol.gt. 0.0_dp )) 
+        WHERE ((pnorm_c.lt.xmax) .and. (pmol.lt.xmax) .and. (pmol.gt. 0.0_wp )) 
             x3d_c = pnorm_c/pmol
         ELSEWHERE
             x3d_c = undef
@@ -112,16 +158,15 @@ CONTAINS
 ! c 2- Diagnose cloud fractions (3D, low, middle, high, total)
 ! c from subgrid-scale lidar scattering ratios :
 ! c -------------------------------------------------------
-
-      CALL cosp_cldfrac(npoints,ncol,llm,ncat,  &
-              x3d,pplay,S_att,S_cld,undef,lidarcld, &
-              cldlayer)
+      CALL cosp_cldfrac(npoints,ncol,llm,ncat,nphase, &
+              tmp,x3d,pnorm,pnorm_perp,pplay,S_att,S_cld,S_cld_att,undef,lidarcld, &
+              cldlayer,lidarcldphase,sub,cldlayerphase,lidarcldtmp)
 
 ! c -------------------------------------------------------
 ! c 3- CFADs 
 ! c -------------------------------------------------------
       IF (ok_lidar_cfad) THEN
-!
+
 ! c CFADs of subgrid-scale lidar scattering ratios :
 ! c -------------------------------------------------------
       CALL cosp_cfad_sr(npoints,ncol,llm,max_bin,undef, &
@@ -132,7 +177,7 @@ CONTAINS
 ! c -------------------------------------------------------
 ! c 4- Compute grid-box averaged Parasol reflectances
 ! c -------------------------------------------------------
-      parasolrefl(:,:) = 0.0_dp
+      parasolrefl(:,:) = 0.0_wp
 
       DO k = 1, nrefl
        DO ic = 1, ncol
@@ -141,13 +186,14 @@ CONTAINS
       ENDDO
 
       DO k = 1, nrefl
-        parasolrefl(:,k) = parasolrefl(:,k) / REAL(ncol,dp)
+        parasolrefl(:,k) = parasolrefl(:,k) / REAL(ncol,wp) !cms
 ! if land=1 -> parasolrefl=undef
 ! if land=0 -> parasolrefl=parasolrefl
-        parasolrefl(:,k) = parasolrefl(:,k) * MAX(1.0_dp-land(:),0.0_dp) &
-                           + (1.0_dp - MAX(1.0_dp-land(:),0.0_dp))*undef 
+        parasolrefl(:,k) = parasolrefl(:,k) * MAX(1.0_wp-land(:),0.0_wp) &
+                           + (1.0_wp - MAX(1.0_wp-land(:),0.0_wp))*undef 
       ENDDO
 
+      RETURN
       END SUBROUTINE diag_lidar
 
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -177,15 +223,15 @@ CONTAINS
 
 ! Input arguments
       INTEGER :: Npoints,Ncolumns,Nlevels,Nbins
-      REAL(dp) :: xmax,S_att,S_clr,undef 
+      REAL(wp) :: xmax,S_att,S_clr,undef 
 ! Input-outout arguments
-      REAL(dp) :: x(Npoints,Ncolumns,Nlevels)
+      REAL(wp) :: x(Npoints,Ncolumns,Nlevels)
 ! Output :
-      REAL(dp) :: cfad(Npoints,Nbins,Nlevels)
-      REAL(dp) :: srbval(Nbins)
+      REAL(wp) :: cfad(Npoints,Nbins,Nlevels)
+      REAL(wp) :: srbval(Nbins)
 ! Local variables
       INTEGER :: i, j, k, ib
-      REAL(dp) :: srbval_ext(0:Nbins)
+      REAL(wp) :: srbval_ext(0:Nbins)
 
 ! c -------------------------------------------------------
 ! c 0- Initializations
@@ -194,19 +240,19 @@ CONTAINS
 
       srbval(1) =  S_att
       srbval(2) =  S_clr
-      srbval(3) =  3.0_dp
-      srbval(4) =  5.0_dp
-      srbval(5) =  7.0_dp
-      srbval(6) = 10.0_dp
+      srbval(3) =  3.0_wp
+      srbval(4) =  5.0_wp
+      srbval(5) =  7.0_wp
+      srbval(6) = 10.0_wp
       DO i = 7, MIN(10,Nbins)
-       srbval(i) = srbval(i-1) + 5.0_dp
+       srbval(i) = srbval(i-1) + 5.0_wp
       ENDDO
       DO i = 11, MIN(13,Nbins)
-       srbval(i) = srbval(i-1) + 10.0_dp
+       srbval(i) = srbval(i-1) + 10.0_wp
       ENDDO
-      srbval(MIN(14,Nbins)) = 80.0_dp
+      srbval(MIN(14,Nbins)) = 80.0_wp
       srbval(Nbins) = xmax
-      cfad(:,:,:) = 0.0_dp
+      cfad(:,:,:) = 0.0_wp
 
 ! c -------------------------------------------------------
 ! c c- Compute CFAD
@@ -214,105 +260,181 @@ CONTAINS
 
 !cms++ replace from v1.3:
       srbval_ext(1:Nbins) = srbval
-      srbval_ext(0) = -1.0_dp
-
+      srbval_ext(0) = -1.0_wp
+!cms--
       DO j = 1, Nlevels
          DO ib = 1, Nbins
             DO k = 1, Ncolumns
                DO i = 1, Npoints
                   IF (x(i,k,j) /= undef) THEN
                      IF ((x(i,k,j).gt.srbval_ext(ib-1)).and.(x(i,k,j).le.srbval_ext(ib))) &
-                          cfad(i,ib,j) = cfad(i,ib,j) + 1.0_dp
+                         cfad(i,ib,j) = cfad(i,ib,j) + 1.0_wp
                   ELSE 
-                     cfad(i,ib,j) = undef
+                         cfad(i,ib,j) = undef
                   ENDIF
                ENDDO
             ENDDO
          ENDDO
       ENDDO
 
-      WHERE (cfad .ne. undef)  cfad = cfad / REAL(Ncolumns,dp)
-
-!!$
-!!$        do j = Nlevels, 1, -1 
-!!$          do k = 1, Ncolumns
-!!$              where ( x(:,k,j).le.srbval(1) ) &
-!!$                        cfad(:,1,j) = cfad(:,1,j) + 1.0_dp
-!!$          enddo  !k
-!!$        enddo  !j
-!!$
-!!$      do ib = 2, Nbins
-!!$        do j = Nlevels, 1, -1 
-!!$          do k = 1, Ncolumns
-!!$              where ( ( x(:,k,j).gt.srbval(ib-1) ) .and. ( x(:,k,j).le.srbval(ib) ) ) &
-!!$                        cfad(:,ib,j) = cfad(:,ib,j) + 1.0_dp
-!!$          enddo  !k
-!!$        enddo  !j
-!!$      enddo  !ib
-!!$
-!!$      cfad(:,:,:) = cfad(:,:,:) / REAL(Ncolumns,dp)
-!cms --
-! c -------------------------------------------------------
+      WHERE (cfad .ne. undef)  cfad = cfad / REAL(Ncolumns,wp)  !cms
 
+! c -------------------------------------------------------
+      RETURN
       END SUBROUTINE cosp_cfad_sr
 
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 !-------------------- SUBROUTINE COSP_CLDFRAC -------------------
 ! c Purpose: Cloud fraction diagnosed from lidar measurements 
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-      SUBROUTINE cosp_cldfrac(Npoints,Ncolumns,Nlevels,Ncat, &
-                  x,pplay,S_att,S_cld,undef,lidarcld, &
-                  cldlayer)
+      SUBROUTINE cosp_cldfrac( Npoints,Ncolumns,Nlevels,Ncat,NPhase, &
+                  tmp_input,x_input,ATB_input,ATBperp_input,pplay_input,S_att,S_cld,S_cld_att,undef,&
+                  lidarcld_output,cldlayer,lidarcldphase_output,nsub,cldlayerphase,lidarcldtemp )
+
       IMPLICIT NONE
 ! Input arguments
-      INTEGER :: Npoints,Ncolumns,Nlevels,Ncat
-      REAL(dp) :: x(Npoints,Ncolumns,Nlevels)
-      REAL(dp) :: pplay(Npoints,Nlevels)
-      REAL(dp) :: S_att,S_cld
-      REAL(dp) :: undef
-! Output :
-      REAL(dp) :: lidarcld(Npoints,Nlevels) ! 3D cloud fraction
-      REAL(dp) :: cldlayer(Npoints,Ncat)    ! low, middle, high, total cloud fractions
+      INTEGER :: Npoints, Ncolumns, Nlevels, Ncat
+      REAL(wp) :: x(Npoints,Ncolumns,Nlevels)
+      REAL(wp) :: tmp(Npoints,Nlevels)		! temperature
+      REAL(wp) :: ATB(Npoints,Ncolumns,Nlevels) ! 3D Attenuated backscatter
+      REAL(wp) :: ATBperp(Npoints,Ncolumns,Nlevels) ! 3D perpendicular attenuated backscatter
+      REAL(wp) :: pplay(Npoints,Nlevels)
+      REAL(wp) :: S_att,S_cld
+      REAL(wp) :: undef
+      !CNam/Gustavo: vertical flip (phase/temp related)
+      REAL(wp) :: x_input(Npoints,Ncolumns,Nlevels)  ! echam order
+      REAL(wp) :: tmp_input(Npoints,Nlevels)         ! temperature, echam order
+      REAL(wp) :: ATB_input(Npoints,Ncolumns,Nlevels)     ! 3D Attenuated backscatter,echam order
+      REAL(wp) :: ATBperp_input(Npoints,Ncolumns,Nlevels) ! 3D perp. attenuated backscatter, echam order
+      REAL(wp) :: pplay_input(Npoints,Nlevels)       ! echam order
+
+
+
 ! Local variables
-      INTEGER :: ip, k, iz, ic
-      REAL(dp) :: p1
-      REAL(dp) :: cldy(Npoints,Ncolumns,Nlevels)
-      REAL(dp) :: srok(Npoints,Ncolumns,Nlevels)
-      REAL(dp) :: cldlay(Npoints,Ncolumns,Ncat)
-      REAL(dp) :: nsublay(Npoints,Ncolumns,Ncat), nsublayer(Npoints,Ncat)
-      REAL(dp) :: nsub(Npoints,Nlevels)
+      INTEGER :: ip, k, iz, ic, ncol, nlev, i, itemp  ! loop indice
+
+      INTEGER :: nphase ! nb of cloud layer phase types 
+                                      ! (ice,liquid,undefined,false ice,false liquid,Percent of ice)
+      INTEGER,PARAMETER  ::  Ntemp = 40 ! indice of the temperature vector !CNam: Ntemp not model Nlevels. See cosp_constants.
+      REAL(wp) :: S_cld_att ! New threshold for undefine cloud phase detection (SR=30)
+      INTEGER  :: toplvlsat  ! level of the first cloud with SR>30
+      REAL(wp) :: alpha50, beta50, gamma50, delta50, epsilon50, zeta50 ! Polynomial Coef of the phase
+                                                              ! discrimination line   
+
+      REAL(wp) :: tmpi(Npoints,Ncolumns,Nlevels)	! temperature of ice cld
+      REAL(wp) :: tmpl(Npoints,Ncolumns,Nlevels)	! temperature of liquid cld
+      REAL(wp) :: tmpu(Npoints,Ncolumns,Nlevels)	! temperature of undef cld
+
+      REAL(wp) :: checktemp, ATBperp_tmp ! temporary variable
+      REAL(wp) :: checkcldlayerphase, checkcldlayerphase2 ! temporary variable
+      REAL(wp) :: sumlidarcldtemp(Npoints,Ntemp) ! temporary variable
+
+      REAL(wp) :: cldlayphase(Npoints,Ncolumns,Ncat,Nphase) ! subgrided low mid high phase cloud fraction
+      REAL(wp) :: cldlayerphasetmp(Npoints,Ncat) ! temporary variable
+      REAL(wp) :: cldlayerphasesum(Npoints,Ncat) ! temporary variable
+      REAL(wp) :: lidarcldtempind(Npoints,Ntemp) ! 3D Temperature indice
+      REAL(wp) :: lidarcldphasetmp(Npoints,Nlevels)  ! 3D sum of ice and liquid cloud occurences
+
+      REAL(wp) :: p1
+      REAL(wp) :: cldy(Npoints,Ncolumns,Nlevels)
+      REAL(wp) :: srok(Npoints,Ncolumns,Nlevels)
+      REAL(wp) :: cldlay(Npoints,Ncolumns,Ncat)
+      REAL(wp) :: nsublay(Npoints,Ncolumns,Ncat), nsublayer(Npoints,Ncat)
+      REAL(wp) :: nsub(Npoints,Nlevels)
+
+!CNam: commented out SYS_SX related stuff.
+!#ifdef SYS_SX
+!      REAL(wp) cldlay1(Npoints,Ncolumns)
+!      REAL(wp) cldlay2(Npoints,Ncolumns)
+!      REAL(wp) cldlay3(Npoints,Ncolumns)
+!      REAL(wp) nsublay1(Npoints,Ncolumns)
+!      REAL(wp) nsublay2(Npoints,Ncolumns)
+!      REAL(wp) nsublay3(Npoints,Ncolumns)
+!#endif
+
+! Output :
+      REAL(wp) :: lidarcldtemp(Npoints,Ntemp,5) ! 3D cloud fraction
+      REAL(wp) :: tempmod(Ntemp+1)     ! temperature bins
+      REAL(wp) :: lidarcldphase(Npoints,Nlevels,Nphase)    ! 3D cloud phase fraction, vertical flip
+      REAL(wp) :: cldlayerphase(Npoints,Ncat,Nphase) ! low, middle, high, total cloud fractions for ice liquid and undefine phase
+      REAL(wp) :: lidarcld(Npoints,Nlevels) ! 3D cloud fraction, vertical flip
+      REAL(wp) :: cldlayer(Npoints,Ncat)    ! low, middle, high, total cloud fractions
+      !CNam/Gustavo: vertical flip
+      REAL(wp) :: lidarcldphase_output(Npoints,Nlevels,Nphase)    ! 3D cloud phase fraction
+      REAL(wp) :: lidarcld_output(Npoints,Nlevels) ! 3D cloud fraction
 
 ! ---------------------------------------------------------------
 ! 1- initialization 
 ! ---------------------------------------------------------------
 
       IF ( Ncat .ne. 4 ) THEN
-         print *,'Error in lmd_ipsl_stats.cosp_cldfrac, Ncat must be 4, not',Ncat
+         print *,'Error in lmd_ipsl_stats. cosp_cldfrac, Ncat must be 4, not',Ncat
          stop
       ENDIF
 
-      lidarcld = 0.0_dp
-      nsub = 0.0_dp
-      cldlay = 0.0_dp
-      nsublay = 0.0_dp
+      !CNam/Gustavo: vertical flip
+      x(:,:,1:Nlevels) = x_input(:,:,Nlevels:1:-1)
+      tmp(:,1:Nlevels) = tmp_input(:,Nlevels:1:-1)
+      ATB(:,:,1:Nlevels)=ATB_input(:,:,Nlevels:1:-1)
+      ATBperp(:,:,1:Nlevels)=ATBperp_input(:,:,Nlevels:1:-1)
+      pplay(:,1:Nlevels)=pplay_input(:,Nlevels:1:-1)
+
+
+      lidarcld = 0.0_wp
+      nsub = 0.0_wp
+      cldlay = 0.0_wp
+      nsublay = 0.0_wp
+
+      ATBperp_tmp = 0._wp
+      lidarcldphase(:,:,:) = 0._wp
+      cldlayphase(:,:,:,:) = 0._wp
+      cldlayerphase(:,:,:) = 0._wp
+      tmpi(:,:,:) = 0._wp
+      tmpl(:,:,:) = 0._wp
+      tmpu(:,:,:) = 0._wp
+      cldlayerphasesum(:,:) = 0._wp
+      lidarcldtemp(:,:,:) = 0._wp
+      lidarcldtempind(:,:) = 0._wp
+      sumlidarcldtemp(:,:) = 0._wp
+      toplvlsat=0
+      lidarcldphasetmp(:,:) = 0._wp
+      cldy(:,:,:) = 0._wp
+
+! temperature bins
+      tempmod=(/-273.15_wp,-90._wp,-87._wp,-84._wp,-81._wp,-78._wp,-75._wp,-72._wp,-69._wp,-66._wp,-63._wp,-60._wp,-57._wp, &
+                -54._wp,-51._wp,-48._wp,-45._wp,-42._wp,-39._wp,-36._wp,-33._wp,-30._wp,-27._wp,-24._wp,-21._wp,-18._wp,  &
+                -15._wp,-12._wp,-9._wp,-6._wp,-3._wp,0._wp,3._wp,6._wp,9._wp,12._wp,15._wp,18._wp,21._wp,24._wp,200._wp /)
+	
+! convert C to K
+      tempmod=tempmod+273.15_wp
+
+! Polynomial coefficient of the phase discrimination line used to separate liquid from ice
+! (Cesana and Chepfer, JGR, 2013)
+! ATBperp = ATB^5*alpha50 + ATB^4*beta50 + ATB^3*gamma50 + ATB^2*delta50 + ATB*epsilon50 + zeta50
+      alpha50   = 9.0322e+15_wp
+      beta50    = -2.1358e+12_wp
+      gamma50   = 173.3963e06_wp
+      delta50   = -3.9514e03_wp
+      epsilon50 = 0.2559_wp
+      zeta50    = -9.4776e-07_wp
 
 ! ---------------------------------------------------------------
 ! 2- Cloud detection
 ! ---------------------------------------------------------------
-      DO k = 1, Nlevels
 
-! cloud detection at subgrid-scale:
+      DO k = 1, Nlevels
+         ! cloud detection at subgrid-scale:
          WHERE ( (x(:,:,k).gt.S_cld) .and. (x(:,:,k).ne. undef) )
-           cldy(:,:,k)=1.0_dp
+            cldy(:,:,k)=1.0_wp
          ELSEWHERE
-           cldy(:,:,k)=0.0_dp
+            cldy(:,:,k)=0.0_wp
          ENDWHERE
 
 ! number of usefull sub-columns:
          WHERE ( (x(:,:,k).gt.S_att) .and. (x(:,:,k).ne. undef)  ) 
-           srok(:,:,k)=1.0_dp
+           srok(:,:,k)=1.0_wp
          ELSEWHERE
-           srok(:,:,k)=0.0_dp
+           srok(:,:,k)=0.0_wp
          ENDWHERE
 
       ENDDO ! k
@@ -321,17 +443,100 @@ CONTAINS
 ! 3- grid-box 3D cloud fraction and layered cloud fractions (ISCCP pressure
 ! categories) :
 ! ---------------------------------------------------------------
+      lidarcld = 0.0_wp
+      nsub = 0.0_wp
+
+!CNam: commented out SYS_SX related stuff.
+!#ifdef SYS_SX
+!! Use cldlay[1-3] and nsublay[1-3] to avoid bank-conflicts.
+!      cldlay1 = 0.0_wp
+!      cldlay2 = 0.0_wp
+!      cldlay3 = 0.0_wp
+!      cldlay(:,:,4) = 0.0_wp ! Ncat == 4
+!      nsublay1 = 0.0_wp
+!      nsublay2 = 0.0_wp
+!      nsublay3 = 0.0_wp
+!      nsublay(:,:,4) = 0.0_wp
+!
+!      do k = Nlevels, 1, -1
+!       do ic = 1, Ncolumns
+!        do ip = 1, Npoints
+!
+!        if(srok(ip,ic,k).gt.0_wp.)then
+!           ! Computation of the cloud fraction as a function of the temperature
+!           ! instead of height, for ice,liquid and all clouds
+!           do itemp=1,Ntemp
+!             if( (tmp(ip,k).ge.tempmod(itemp)).and.(tmp(ip,k).lt.tempmod(itemp+1)) )then
+!               lidarcldtempind(ip,itemp)=lidarcldtempind(ip,itemp)+1._wp
+!             endif
+!           enddo
+!         endif
+!
+!         if (cldy(ip,ic,k).eq.1._wp) then
+!           do itemp=1,Ntemp
+!             if( (tmp(ip,k).ge.tempmod(itemp)).and.(tmp(ip,k).lt.tempmod(itemp+1)) )then
+!               lidarcldtemp(ip,itemp,1)=lidarcldtemp(ip,itemp,1)+1._wp
+!             endif
+!           enddo
+!         endif
+!
+!         p1 = pplay(ip,k)
+!
+!         if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then ! high clouds !CNam: Orig p1.gt.0._wp
+!            cldlay3(ip,ic) = MAX(cldlay3(ip,ic), cldy(ip,ic,k))
+!            nsublay3(ip,ic) = MAX(nsublay3(ip,ic), srok(ip,ic,k))
+!         else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then  ! mid clouds
+!            cldlay2(ip,ic) = MAX(cldlay2(ip,ic), cldy(ip,ic,k))
+!            nsublay2(ip,ic) = MAX(nsublay2(ip,ic), srok(ip,ic,k))
+!         else
+!            cldlay1(ip,ic) = MAX(cldlay1(ip,ic), cldy(ip,ic,k))
+!            nsublay1(ip,ic) = MAX(nsublay1(ip,ic), srok(ip,ic,k))
+!         endif
+!
+!         cldlay(ip,ic,4) = MAX(cldlay(ip,ic,4), cldy(ip,ic,k))
+!         lidarcld(ip,k)=lidarcld(ip,k) + cldy(ip,ic,k)
+!         nsublay(ip,ic,4) = MAX(nsublay(ip,ic,4),srok(ip,ic,k))
+!         nsub(ip,k)=nsub(ip,k) + srok(ip,ic,k)
+!        enddo
+!       enddo
+!      enddo
+!      cldlay(:,:,1) = cldlay1
+!      cldlay(:,:,2) = cldlay2
+!      cldlay(:,:,3) = cldlay3
+!      nsublay(:,:,1) = nsublay1
+!      nsublay(:,:,2) = nsublay2
+!      nsublay(:,:,3) = nsublay3
+! #else
+      cldlay = 0.0_wp
+      nsublay = 0.0_wp
+      do k = Nlevels,1,-1  
+       do ic = 1, Ncolumns
+        do ip = 1, Npoints
+
+          ! Computation of the cloud fraction as a function of the temperature
+          ! instead of height, for ice,liquid and all clouds
+         if(srok(ip,ic,k).gt. 0._wp)then
+          do itemp=1,Ntemp
+            if( (tmp(ip,k).ge.tempmod(itemp)).and.(tmp(ip,k).lt.tempmod(itemp+1)) )then
+              lidarcldtempind(ip,itemp)=lidarcldtempind(ip,itemp)+1._wp
+            endif
+          enddo
+         endif
+
+         if(cldy(ip,ic,k).eq.1._wp)then
+          do itemp=1,Ntemp
+            if( (tmp(ip,k).ge.tempmod(itemp)).and.(tmp(ip,k).lt.tempmod(itemp+1)) )then
+              lidarcldtemp(ip,itemp,1)=lidarcldtemp(ip,itemp,1)+1._wp
+            endif
+          enddo
+          endif
 
-      DO k = Nlevels, 1, -1
-       DO ic = 1, Ncolumns
-        DO ip = 1, Npoints
 
           iz=1
-          p1 = pplay(ip,k)
-!jq          if ( p1.gt.0. .and. p1.lt.(440.*100.)) then ! high clouds          
-          IF ( p1.ge.0._dp .and. p1.lt.(440._dp*100._dp)) THEN ! high clouds
+          p1 = pplay(ip,k)         
+          IF ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) THEN ! high clouds !CNam: Orig p1.gt.0._wp
             iz=3
-          ELSEIF (p1.ge.(440._dp*100._dp) .and. p1.lt.(680._dp*100._dp)) THEN  ! mid clouds
+          ELSEIF (p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) THEN  ! mid clouds
             iz=2
          ENDIF
 
@@ -346,10 +551,12 @@ CONTAINS
         ENDDO
        ENDDO
       ENDDO
+!#endif ! SYS_SX
+
 
 ! -- grid-box 3D cloud fraction
 
-      WHERE ( nsub(:,:).gt.0.0_dp )
+      WHERE ( nsub(:,:).gt. 0.0_wp )
          lidarcld(:,:) = lidarcld(:,:)/nsub(:,:)
       ELSEWHERE
          lidarcld(:,:) = undef
@@ -357,8 +564,8 @@ CONTAINS
 
 ! -- layered cloud fractions
 
-      cldlayer = 0.0_dp
-      nsublayer = 0.0_dp
+      cldlayer = 0.0_wp
+      nsublayer = 0.0_wp
 
       DO iz = 1, Ncat
        DO ic = 1, Ncolumns
@@ -367,13 +574,427 @@ CONTAINS
        ENDDO
       ENDDO
 
-      WHERE ( nsublayer(:,:).gt.0.0_dp )
+      WHERE ( nsublayer(:,:).gt. 0.0_wp )
          cldlayer(:,:) = cldlayer(:,:)/nsublayer(:,:)
       ELSEWHERE
          cldlayer(:,:) = undef
       ENDWHERE
 
-      END SUBROUTINE cosp_cldfrac
+
+! ---------------------------------------------------------------
+! 4- grid-box 3D cloud Phase :
+! ---------------------------------------------------------------
+! ---------------------------------------------------------------
+! 4.1 - For Cloudy pixels with 8.16km < z < 19.2km
+! ---------------------------------------------------------------
+  do ncol=1,Ncolumns
+  do i=1,Npoints
+         do nlev=Nlevels,18,-1 !from 19.2km until 8.16km
+         p1 = pplay(i,nlev)
+
+! Avoid zero values
+	if( (cldy(i,ncol,nlev).eq. 1._wp) .and. (ATBperp(i,ncol,nlev).gt. 0._wp) )then
+! Computation of the ATBperp along the phase discrimination line
+           ATBperp_tmp = (ATB(i,ncol,nlev)**5)*alpha50 + (ATB(i,ncol,nlev)**4)*beta50 + &
+                         (ATB(i,ncol,nlev)**3)*gamma50 + (ATB(i,ncol,nlev)**2)*delta50 + &
+                          ATB(i,ncol,nlev)*epsilon50 + zeta50
+
+!____________________________________________________________________________________________________
+!
+!4.1.a Ice: ATBperp above the phase discrimination line
+!____________________________________________________________________________________________________
+!
+           if( (ATBperp(i,ncol,nlev)-ATBperp_tmp).ge. 0._wp )then   ! Ice clouds
+             ! ICE with temperature above 273,15K = Liquid (false ice)
+            if(tmp(i,nlev).gt. 273.15_wp)then                ! Temperature above 273,15 K
+              ! Liquid: False ice corrected by the temperature to Liquid
+               lidarcldphase(i,nlev,2)=lidarcldphase(i,nlev,2)+1._wp   ! false ice detection ==> added to Liquid
+               tmpl(i,ncol,nlev)=tmp(i,nlev)
+               lidarcldphase(i,nlev,5)=lidarcldphase(i,nlev,5)+1._wp   ! keep the information "temperature criterium used"
+                                                    ! to classify the phase cloud
+         	   cldlayphase(i,ncol,4,2) = 1._wp                       ! tot cloud
+                if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+        	   cldlayphase(i,ncol,3,2) = 1._wp
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,2) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,2) = 1._wp
+                endif
+         	   cldlayphase(i,ncol,4,5) = 1._wp                       ! tot cloud
+         	if ( p1.ge.0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+        	   cldlayphase(i,ncol,3,5) = 1._wp
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,5) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,5) = 1._wp
+                endif
+
+             else
+             ! ICE with temperature below 273,15K
+              lidarcldphase(i,nlev,1)=lidarcldphase(i,nlev,1)+1._wp
+              tmpi(i,ncol,nlev)=tmp(i,nlev)
+         	   cldlayphase(i,ncol,4,1) = 1._wp                       ! tot cloud
+         	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+        	   cldlayphase(i,ncol,3,1) = 1._wp
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,1) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,1) = 1._wp
+                endif
+
+              endif
+
+!____________________________________________________________________________________________________
+!
+! 4.1.b Liquid: ATBperp below the phase discrimination line
+!____________________________________________________________________________________________________
+!
+             else                                        ! Liquid clouds
+              ! Liquid with temperature above 231,15K
+            if(tmp(i,nlev).gt. 231.15_wp)then 
+               lidarcldphase(i,nlev,2)=lidarcldphase(i,nlev,2)+1._wp
+               tmpl(i,ncol,nlev)=tmp(i,nlev)
+         	   cldlayphase(i,ncol,4,2) = 1._wp                       ! tot cloud
+         	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+         	   cldlayphase(i,ncol,3,2) = 1._wp  
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,2) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,2) = 1._wp
+	 	endif
+
+             else
+             ! Liquid with temperature below 231,15K = Ice (false liquid)
+               tmpi(i,ncol,nlev)=tmp(i,nlev)
+               lidarcldphase(i,nlev,1)=lidarcldphase(i,nlev,1)+1._wp   ! false liquid detection ==> added to ice
+               lidarcldphase(i,nlev,4)=lidarcldphase(i,nlev,4)+1._wp   ! keep the information "temperature criterium used"
+                                                    ! to classify the phase cloud
+         	   cldlayphase(i,ncol,4,4) = 1._wp                       ! tot cloud
+        	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+         	   cldlayphase(i,ncol,3,4) = 1._wp  
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,4) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,4) = 1._wp
+	 	endif
+         	   cldlayphase(i,ncol,4,1) = 1._wp                       ! tot cloud
+        	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+         	   cldlayphase(i,ncol,3,1) = 1._wp  
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,1) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,1) = 1._wp
+	 	endif
+
+             endif
+
+            endif  ! end of discrimination condition 
+	 endif  ! end of cloud condition
+      enddo ! end of altitude loop
+
+
+
+! ---------------------------------------------------------------
+! 4.2 - For Cloudy pixels with 0km < z < 8.16km
+! ---------------------------------------------------------------
+
+      toplvlsat = 0      
+      do nlev=17,1,-1    ! from 8.16km until 0km
+
+	if( (cldy(i,ncol,nlev).eq. 1._wp) .and. (ATBperp(i,ncol,nlev).gt. 0._wp) )then
+! Phase discrimination line : ATBperp = ATB^5*alpha50 + ATB^4*beta50 + ATB^3*gamma50 + ATB^2*delta50 
+!                                  + ATB*epsilon50 + zeta50
+! Computation of the ATBperp of the phase discrimination line
+           ATBperp_tmp = (ATB(i,ncol,nlev)**5)*alpha50 + (ATB(i,ncol,nlev)**4)*beta50 + &
+                         (ATB(i,ncol,nlev)**3)*gamma50 + (ATB(i,ncol,nlev)**2)*delta50 + &
+                          ATB(i,ncol,nlev)*epsilon50 + zeta50
+!____________________________________________________________________________________________________
+!
+! 4.2.a Ice: ATBperp above the phase discrimination line
+!____________________________________________________________________________________________________
+!
+            ! ICE with temperature above 273,15K = Liquid (false ice)
+          if( (ATBperp(i,ncol,nlev)-ATBperp_tmp).ge. 0._wp )then   ! Ice clouds
+            if(tmp(i,nlev).gt. 273.15_wp)then 
+               lidarcldphase(i,nlev,2)=lidarcldphase(i,nlev,2)+1._wp  ! false ice ==> liq
+               tmpl(i,ncol,nlev)=tmp(i,nlev)
+               lidarcldphase(i,nlev,5)=lidarcldphase(i,nlev,5)+1._wp
+
+         	   cldlayphase(i,ncol,4,2) = 1._wp                       ! tot cloud
+                if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then      ! high cloud !CNam: Orig p1.gt.0._wp
+        	   cldlayphase(i,ncol,3,2) = 1._wp
+         	elseif (p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,2) = 1._wp 
+	 	else                                                       ! low cloud
+         	   cldlayphase(i,ncol,1,2) = 1._wp
+                endif
+
+         	   cldlayphase(i,ncol,4,5) = 1._wp                       ! tot cloud
+        	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+        	   cldlayphase(i,ncol,3,5) = 1._wp
+         	elseif (p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,5) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,5) = 1._wp
+                endif
+
+             else
+              ! ICE with temperature below 273,15K
+              lidarcldphase(i,nlev,1)=lidarcldphase(i,nlev,1)+1._wp
+              tmpi(i,ncol,nlev)=tmp(i,nlev)
+
+          	   cldlayphase(i,ncol,4,1) = 1._wp                       ! tot cloud
+        	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+        	   cldlayphase(i,ncol,3,1) = 1._wp
+         	else if (p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,1) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,1) = 1._wp
+                endif
+
+              endif
+
+!____________________________________________________________________________________________________
+!
+! 4.2.b Liquid: ATBperp below the phase discrimination line
+!____________________________________________________________________________________________________
+!
+          else  
+             ! Liquid with temperature above 231,15K
+            if(tmp(i,nlev).gt. 231.15_wp)then 
+               lidarcldphase(i,nlev,2)=lidarcldphase(i,nlev,2)+1._wp
+               tmpl(i,ncol,nlev)=tmp(i,nlev)
+
+         	   cldlayphase(i,ncol,4,2) = 1._wp                       ! tot cloud
+         	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+         	   cldlayphase(i,ncol,3,2) = 1._wp  
+         	else if (p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,2) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,2) = 1._wp
+	 	endif
+
+             else
+             ! Liquid with temperature below 231,15K = Ice (false liquid)
+               tmpi(i,ncol,nlev)=tmp(i,nlev)
+               lidarcldphase(i,nlev,1)=lidarcldphase(i,nlev,1)+1._wp  ! false liq ==> ice
+               lidarcldphase(i,nlev,4)=lidarcldphase(i,nlev,4)+1._wp  ! false liq ==> ice
+
+         	   cldlayphase(i,ncol,4,4) = 1._wp                       ! tot cloud
+         	if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+         	   cldlayphase(i,ncol,3,4) = 1._wp  
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,4) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,4) = 1._wp
+	 	endif
+
+         	   cldlayphase(i,ncol,4,1) = 1._wp                       ! tot cloud
+        	if ( p1.ge.0._wp .and. p1.lt.(440._wp*100._wp)) then    ! high cloud !CNam: Orig p1.gt.0._wp
+         	   cldlayphase(i,ncol,3,1) = 1._wp  
+         	else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then ! mid cloud
+         	   cldlayphase(i,ncol,2,1) = 1._wp
+	 	else                                                    ! low cloud
+         	   cldlayphase(i,ncol,1,1) = 1._wp
+	 	endif
+
+             endif
+           endif  ! end of discrimination condition 
+
+       	    toplvlsat=0
+
+           ! Find the level of the highest cloud with SR>30
+	    if(x(i,ncol,nlev).gt.S_cld_att)then	 ! SR > 30.
+      		toplvlsat=nlev-1 
+       		goto 99 
+    	    endif
+
+	endif  ! end of cloud condition
+       enddo  ! end of altitude loop
+
+99 continue
+
+!____________________________________________________________________________________________________
+!
+! Undefined phase: For a cloud located below another cloud with SR>30 
+! see Cesana and Chepfer 2013 Sect.III.2
+!____________________________________________________________________________________________________
+!
+  if(toplvlsat.ne.0)then 
+      do nlev=toplvlsat,1,-1
+         p1 = pplay(i,nlev)
+	if(cldy(i,ncol,nlev).eq. 1._wp)then
+             lidarcldphase(i,nlev,3)=lidarcldphase(i,nlev,3)+1._wp
+             tmpu(i,ncol,nlev)=tmp(i,nlev)
+             cldlayphase(i,ncol,4,3) = 1._wp                        ! tot cloud
+          if ( p1.ge. 0._wp .and. p1.lt.(440._wp*100._wp)) then     ! high cloud !CNam: Orig p1.gt.0._wp
+             cldlayphase(i,ncol,3,3) = 1._wp
+          else if(p1.ge.(440._wp*100._wp) .and. p1.lt.(680._wp*100._wp)) then  ! mid cloud
+             cldlayphase(i,ncol,2,3) = 1._wp
+	  else                                                     ! low cloud
+             cldlayphase(i,ncol,1,3) = 1._wp
+	  endif
+
+        endif	
+      enddo
+  endif
+     
+      toplvlsat=0
+
+  enddo
+  enddo
+
+
+
+!____________________________________________________________________________________________________
+!
+! Computation of final cloud phase diagnosis
+!____________________________________________________________________________________________________
+!
+
+! Compute the Ice percentage in cloud = ice/(ice+liq) as a function
+! of the occurrences
+  lidarcldphasetmp(:,:)=lidarcldphase(:,:,1)+lidarcldphase(:,:,2);
+  WHERE (lidarcldphasetmp(:,:).gt. 0._wp)
+     lidarcldphase(:,:,6)=lidarcldphase(:,:,1)/lidarcldphasetmp(:,:)
+  ELSEWHERE
+     lidarcldphase(:,:,6) = undef
+  ENDWHERE
+
+! Compute Phase 3D Cloud Fraction
+     WHERE ( nsub(:,:).gt.0.0_wp )
+       lidarcldphase(:,:,1)=lidarcldphase(:,:,1)/nsub(:,:)
+       lidarcldphase(:,:,2)=lidarcldphase(:,:,2)/nsub(:,:)
+       lidarcldphase(:,:,3)=lidarcldphase(:,:,3)/nsub(:,:)
+       lidarcldphase(:,:,4)=lidarcldphase(:,:,4)/nsub(:,:)
+       lidarcldphase(:,:,5)=lidarcldphase(:,:,5)/nsub(:,:)
+     ELSEWHERE
+       lidarcldphase(:,:,1) = undef
+       lidarcldphase(:,:,2) = undef
+       lidarcldphase(:,:,3) = undef
+       lidarcldphase(:,:,4) = undef
+       lidarcldphase(:,:,5) = undef
+     ENDWHERE
+
+
+! Compute Phase low mid high cloud fractions
+    do iz = 1, Ncat
+       do i=1,Nphase-3
+       do ic = 1, Ncolumns
+          cldlayerphase(:,iz,i)=cldlayerphase(:,iz,i) + cldlayphase(:,ic,iz,i)
+          cldlayerphasesum(:,iz)=cldlayerphasesum(:,iz)+cldlayphase(:,ic,iz,i)
+       enddo
+      enddo
+    enddo
+
+    do iz = 1, Ncat
+       do i=4,5
+       do ic = 1, Ncolumns
+          cldlayerphase(:,iz,i)=cldlayerphase(:,iz,i) + cldlayphase(:,ic,iz,i)          
+       enddo
+       enddo
+    enddo
+    
+! Compute the Ice percentage in cloud = ice/(ice+liq)
+    cldlayerphasetmp(:,:)=cldlayerphase(:,:,1)+cldlayerphase(:,:,2)
+    WHERE (cldlayerphasetmp(:,:).gt. 0._wp)
+       cldlayerphase(:,:,6)=cldlayerphase(:,:,1)/cldlayerphasetmp(:,:)
+    ELSEWHERE
+       cldlayerphase(:,:,6) = undef
+    ENDWHERE
+
+    do i=1,Nphase-1
+      WHERE ( cldlayerphasesum(:,:).gt. 0.0_wp )
+         cldlayerphase(:,:,i) = (cldlayerphase(:,:,i)/cldlayerphasesum(:,:)) * cldlayer(:,:) 
+      ENDWHERE
+    enddo
+
+
+    do i=1,Npoints
+       do iz=1,Ncat
+          checkcldlayerphase=0._wp
+          checkcldlayerphase2=0._wp
+
+          if (cldlayerphasesum(i,iz).gt. 0.0_wp )then
+             do ic=1,Nphase-3
+                checkcldlayerphase=checkcldlayerphase+cldlayerphase(i,iz,ic)  
+             enddo
+             checkcldlayerphase2=cldlayer(i,iz)-checkcldlayerphase
+             if( (checkcldlayerphase2.gt. 0.01_wp).or.(checkcldlayerphase2.lt.-0.01_wp) ) print *, checkcldlayerphase,cldlayer(i,iz)
+
+          endif
+
+       enddo
+    enddo
+
+    do i=1,Nphase-1
+      WHERE ( nsublayer(:,:).eq. 0.0_wp )
+         cldlayerphase(:,:,i) = undef
+      ENDWHERE
+   enddo
+
+!____________________________________________________________________________________________________
+
+ 
+! Compute Phase 3D as a function of temperature
+  do nlev=1,Nlevels
+    do ncol=1,Ncolumns     
+      do i=1,Npoints
+        do itemp=1,Ntemp
+           if(tmpi(i,ncol,nlev).gt. 0._wp)then
+	      if( (tmpi(i,ncol,nlev).ge.tempmod(itemp)).and.(tmpi(i,ncol,nlev).lt.tempmod(itemp+1)) )then
+	        lidarcldtemp(i,itemp,2)=lidarcldtemp(i,itemp,2)+1._wp
+	      endif
+	   elseif(tmpl(i,ncol,nlev).gt. 0._wp)then
+	      if( (tmpl(i,ncol,nlev).ge.tempmod(itemp)).and.(tmpl(i,ncol,nlev).lt.tempmod(itemp+1)) )then
+	        lidarcldtemp(i,itemp,3)=lidarcldtemp(i,itemp,3)+1._wp
+	      endif
+	   elseif(tmpu(i,ncol,nlev).gt. 0._wp)then
+	      if( (tmpu(i,ncol,nlev).ge.tempmod(itemp)).and.(tmpu(i,ncol,nlev).lt.tempmod(itemp+1)) )then
+	        lidarcldtemp(i,itemp,4)=lidarcldtemp(i,itemp,4)+1._wp
+	      endif
+          endif
+        enddo
+      enddo
+    enddo
+  enddo
+
+! Check temperature cloud fraction
+  do i=1,Npoints
+     do itemp=1,Ntemp
+        checktemp=lidarcldtemp(i,itemp,2)+lidarcldtemp(i,itemp,3)+lidarcldtemp(i,itemp,4)
+
+	if(checktemp.NE.lidarcldtemp(i,itemp,1))then
+	  print *, "in lmd_ispl_stats.f90: checktemp.NE.lidarcldtemp ",i,itemp !CNam
+	endif
+
+     enddo
+  enddo
+
+! Compute the Ice percentage in cloud = ice/(ice+liq)
+!   sumlidarcldtemp=sum(lidarcldtemp(:,:,2:3),3)
+   sumlidarcldtemp(:,:)=lidarcldtemp(:,:,2)+lidarcldtemp(:,:,3)
+
+  WHERE(sumlidarcldtemp(:,:)>0._wp)
+    lidarcldtemp(:,:,5)=lidarcldtemp(:,:,2)/sumlidarcldtemp(:,:)
+  ELSEWHERE
+    lidarcldtemp(:,:,5)=undef
+  ENDWHERE
+
+  do i=1,4
+    WHERE(lidarcldtempind(:,:).gt.0._wp)
+       lidarcldtemp(:,:,i) = lidarcldtemp(:,:,i)/lidarcldtempind(:,:)
+    ELSEWHERE
+       lidarcldtemp(:,:,i) = undef
+    ENDWHERE
+  enddo
+
+  !CNam/Gustavo: vertical flip
+  lidarcldphase_output(:,1:Nlevels,:) = lidarcldphase(:,Nlevels:1:-1,:)
+  lidarcld_output(:,1:Nlevels) = lidarcld(:,Nlevels:1:-1)
+
+  RETURN
+  END SUBROUTINE cosp_cldfrac
 ! ---------------------------------------------------------------
 	  
 END MODULE mo_cosp_lmd_ipsl_stats
diff --git a/src/mo_cosp_offline.f90 b/src/mo_cosp_offline.f90
index 2f168b8..1567d0c 100644
--- a/src/mo_cosp_offline.f90
+++ b/src/mo_cosp_offline.f90
@@ -76,6 +76,8 @@ MODULE mo_cosp_offline
 
    IMPLICIT NONE
 
+   INCLUDE 'netcdf.inc'
+
    PRIVATE
 
 ! do cf3hr output?
@@ -101,7 +103,7 @@ MODULE mo_cosp_offline
 !-------------------------------------------------
 !  maximum number of profile variables from streams
 !   (not so nice, try linked list next time.) 
-   INTEGER, PARAMETER :: nvar_1d_max = 20
+   INTEGER, PARAMETER :: nvar_1d_max = 22
 !  
 !  actual number of profile variables 
 !  ( lower than nvar_1d_max only if not all streams/variables
@@ -195,19 +197,25 @@ MODULE mo_cosp_offline
 ! stream to collect extra vars
   TYPE (t_stream), PUBLIC, POINTER :: cospoffl
 
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_lsrain	! Flux large scale cloud rain [kg m^-2 s^-1]
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_lssnow	! Flux large scale cloud snow [kg m^-2 s^-1]
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_ccrain	! Flux convective cloud rain [kg m^-2 s^-1]
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_ccsnow	! Flux convective cloud snow [kg m^-2 s^-1]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_icnc ! in-cloud ICNC
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_cdnc ! in-cloud CDNC
+
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_lsrain ! Flux large scale cloud rain [kg m^-2 s^-1]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_lssnow ! Flux large scale cloud snow [kg m^-2 s^-1]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_ccrain ! Flux convective cloud rain [kg m^-2 s^-1]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_ccsnow ! Flux convective cloud snow [kg m^-2 s^-1]
 
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_reffl	! Liquid water droplet effective radius [um]
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_reffi	! Ice crystal effective radius [um]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_reffl  ! Liquid water droplet effective radius [um]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_reffi  ! Ice crystal effective radius [um]
 
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_geom1   ! geopotential height [m3 s-2]
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_geohm1  ! geopotential height at interfaces  [m3 s-2]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_geom1  ! geopotential height [m3 s-2]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_geohm1 ! geopotential height at interfaces  [m3 s-2]
 
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_p       ! pressure [Pa]
-  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_ph      ! pressure at interfaces  [Pa]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_p      ! pressure [Pa]
+  REAL(dp), PUBLIC, POINTER, DIMENSION(:,:,:) :: cospoffl_ph     ! pressure at interfaces  [Pa]
+
+  REAL(dp), PUBLIC,  POINTER, DIMENSION(:,:,:) :: offl_cisccp_cldtau3d  ! Cloud optical thickness
+  REAL(dp), PUBLIC,  POINTER, DIMENSION(:,:,:) :: offl_cisccp_cldemi3d  ! Cloud emissivity @ 10.5 m
 
   LOGICAL :: module_is_initialized
 
@@ -223,8 +231,7 @@ CONTAINS
  SUBROUTINE cosp_offline
 ! called  each timestep 
 
-  USE mo_exception,          ONLY: message, message_text, finish
-  USE mo_mpi,                ONLY: p_pe 
+  USE mo_exception,          ONLY: message, message_text
   USE mo_time_control,       ONLY: l_putrerun, lbreak, lstop, &
                                    next_date, get_date_components
 
@@ -304,26 +311,18 @@ call message('mo_cosp_offline ', message_text )
 !--------------------------------------------------
  SUBROUTINE cosp_offl_write(  cur, year, month, day, hour, minute, second )
 
-  USE mo_exception,        ONLY : message, message_text, finish
-  USE mo_control,          ONLY : nlev, nlevp1
-  USE mo_mpi,              ONLY : p_pe, p_parallel_io,  &
+  USE mo_control,          ONLY: nlev
+  USE mo_mpi,              ONLY: p_pe, p_parallel_io,  &
                                   p_nprocs, p_io
-  USE mo_netcdf,           ONLY : nf_check
 
   IMPLICIT NONE
 
-  INCLUDE 'netcdf.inc'
-
-      
   INTEGER, INTENT (IN ) :: year, month, day, hour, minute, second
   TYPE(curtain_type), INTENT (IN ), POINTER :: cur
 
 !local
 
-  REAL(dp) :: v1dt
-  INTEGER :: ivar, ncid, varid
-  INTEGER, DIMENSION(2) :: start2, count2, count2p1
-  REAL(dp) :: tlon, tlat
+  INTEGER :: ivar
 
   REAL(dp), ALLOCATABLE, DIMENSION(:)   :: cu1d
   REAL(dp), ALLOCATABLE, DIMENSION(:,:) :: cu2d
@@ -342,7 +341,6 @@ call message('mo_cosp_offline ', message_text )
 
   INTEGER :: isen_pe, is, ie
   INTEGER, DIMENSION( p_nprocs ) :: sending_PEs, istart, iend 
-  INTEGER :: i, ii
  
    ALLOCATE(cu1d(ofile%gmax))
    ALLOCATE(cu2d(nlev, ofile%gmax))
@@ -442,8 +440,8 @@ call message('mo_cosp_offline ', message_text )
                          sending_PEs, istart, iend )
 
 
-   USE mo_mpi,              ONLY : p_nprocs
-   USE mo_time_control,     ONLY : delta_time
+   USE mo_mpi,              ONLY: p_nprocs
+   USE mo_time_control,     ONLY: delta_time
 
    IMPLICIT NONE
 
@@ -499,11 +497,10 @@ call message('mo_cosp_offline ', message_text )
 ! collect points along curtain
 !  default: v2d(ivar), but also options for lat, lon, tm1
 
-  USE mo_exception,        ONLY : message, message_text, finish
-  USE mo_mpi,              ONLY : p_pe, p_parallel_io, p_global_comm, &
+  USE mo_mpi,              ONLY: p_pe, p_parallel_io, p_global_comm, &
                                   p_nprocs, p_io,  p_send, p_recv
-  USE mo_decomposition,    ONLY : gdc => global_decomposition
-  USE mo_geoloc,           ONLY : philon_2d, philat_2d
+  USE mo_decomposition,    ONLY: gdc => global_decomposition
+  USE mo_geoloc,           ONLY: philon_2d, philat_2d
 
 
   IMPLICIT NONE  
@@ -530,7 +527,6 @@ call message('mo_cosp_offline ', message_text )
 !local
    REAL(dp), ALLOCATABLE, DIMENSION(:) :: sendbuf1d, recvbuf1d
   
-   LOGICAL :: tm1
    INTEGER :: i, np ,nr, ie, is, je, pe
 
    CHARACTER(LEN=3) :: lopt
@@ -639,8 +635,8 @@ call message('mo_cosp_offline ', message_text )
                          sending_PEs, istart, iend )
 
 
-   USE mo_mpi,              ONLY : p_nprocs
-   USE mo_time_control,     ONLY : delta_time
+   USE mo_mpi,              ONLY: p_nprocs
+   USE mo_time_control,     ONLY: delta_time
 
    IMPLICIT NONE
 
@@ -700,11 +696,9 @@ call message('mo_cosp_offline ', message_text )
 ! collect points along curtain
 !  default: v2d(ivar), but also options for lat, lon, tm1
 
-  USE mo_exception,        ONLY : message, message_text, finish
-  USE mo_mpi,              ONLY : p_pe, p_parallel_io, p_global_comm, &
+  USE mo_mpi,              ONLY: p_pe, p_parallel_io, p_global_comm, &
                                   p_nprocs, p_io,  p_send, p_recv
-  USE mo_decomposition,    ONLY : gdc => global_decomposition
-  USE mo_geoloc,           ONLY : philon_2d, philat_2d
+  USE mo_decomposition,    ONLY: gdc => global_decomposition
 
 
   IMPLICIT NONE  
@@ -731,7 +725,6 @@ call message('mo_cosp_offline ', message_text )
 !local
    REAL(dp), ALLOCATABLE, DIMENSION(:,:) :: sendbuf2d, recvbuf2d
   
-   LOGICAL :: tm1
    INTEGER :: i, in,  n, np ,nr, ie, is, je, pe
 
    CHARACTER(LEN=3) :: lopt
@@ -847,7 +840,7 @@ call message('mo_cosp_offline ', message_text )
  SUBROUTINE cosp_offline_nml
 ! read namelist only, init_cosp_offline (below) is called from cosp_offline
   USE mo_mpi,         ONLY: p_parallel, p_parallel_io, p_bcast, p_io
-  USE mo_namelist,    ONLY: position_nml, POSITIONED, open_nml, close_nml
+  USE mo_namelist,    ONLY: position_nml, POSITIONED, open_nml
 
   IMPLICIT NONE 
 
@@ -876,9 +869,8 @@ call message('mo_cosp_offline ', message_text )
 
  SUBROUTINE init_cosp_offline
 
-   USE mo_decomposition, ONLY: ldc => local_decomposition
-   USE mo_cosp_simulator, ONLY: locosp, Lisccp_sim
-   USE mo_exception,      ONLY: message, message_text, finish
+   USE mo_cosp_echam, ONLY: locosp, Lisccp_sim
+   USE mo_exception,      ONLY: message_text, finish
    USE mo_time_control,   ONLY: next_date, get_date_components
 
    IMPLICIT NONE
@@ -933,14 +925,11 @@ call message('mo_cosp_offline ', message_text )
 
    USE mo_netcdf,           ONLY: nf_check
    USE mo_time_control,     ONLY: delta_time
-   USE mo_mpi,              ONLY: p_parallel, p_parallel_io, p_bcast, p_io, p_pe
+   USE mo_mpi,              ONLY: p_parallel, p_parallel_io, p_bcast, p_io
    USE mo_exception,        ONLY: message, message_text, finish
 
    IMPLICIT NONE
 
-   INCLUDE 'netcdf.inc'
-
-
    INTEGER, INTENT (IN ) :: year, month, day, hour, minute, second
 
 !local
@@ -955,9 +944,6 @@ call message('mo_cosp_offline ', message_text )
 
    REAL, ALLOCATABLE, DIMENSION(:) :: dsf ! seconds since last day of previous month orbit
 
-   ! maximum number of gid boxes to sample (overpassed) during one model timestep
-   INTEGER :: max_loc
-
    ! indices of orbit times closest to model time steps
    INTEGER, ALLOCATABLE, DIMENSION(:) :: indarr 
    
@@ -966,10 +952,10 @@ call message('mo_cosp_offline ', message_text )
    
    INTEGER :: nmax1, nmax, nlmax 
    INTEGER :: mdays
-   INTEGER :: ncid, varid, nloctot, nlength, dimid, i, j, n
-   INTEGER :: lonid, latid,  tfirst, tlen, mfirst, mlast, istart, iend
+   INTEGER :: ncid, varid, nloctot, nlength, dimid, i, j
+   INTEGER :: tfirst, tlen, mfirst, mlast
    INTEGER :: off, offs, offe
-   REAL(dp) :: d, dd, dist, r, s, dn
+   REAL(dp) :: d, dn
  
    INTEGER, DIMENSION(1) :: starta, counta
   
@@ -1231,8 +1217,6 @@ call message('mo_cosp_offline ', message_text )
 
     IMPLICIT NONE
 
-    INCLUDE 'netcdf.inc'
-
    IF ( p_parallel_io ) THEN
 
     CALL nf_check( NF_CLOSE(ofile%ncid))
@@ -1247,15 +1231,11 @@ call message('mo_cosp_offline ', message_text )
 !-------------------------------------
  SUBROUTINE init_svars
 
-  USE mo_exception,          ONLY : message, message_text, finish
-  USE mo_memory_gl,          ONLY : gl
-  USE mo_memory_g3b,         ONLY : g3b
-  USE mo_memory_g1a,         ONLY : g1a
-  USE mo_memory_g2a,         ONLY : g2a
-  USE mo_memory_cfdiag,      ONLY : cfdiag, locfdiag
-  USE mo_diag_tendency_new,  ONLY : tdiag_vars
-  USE mo_control,            ONLY : ltdiag
-  USE mo_cosp_simulator,     ONLY : scosp
+  USE mo_exception,          ONLY: finish
+  USE mo_memory_gl,          ONLY: gl
+  USE mo_memory_g3b,         ONLY: g3b
+  USE mo_memory_g1a,         ONLY: g1a
+  USE mo_cosp_echam,         ONLY: scosp
 
 
   IMPLICIT NONE
@@ -1352,23 +1332,33 @@ call message('mo_cosp_offline ', message_text )
      i=i+1
     v3d(i)%iname="cisccp_tau3d"
     v3d(i)%oname="dtau_s"
-    v3d(i)%stream => scosp
+    v3d(i)%stream => cospoffl
 
     i=i+1
     v3d(i)%iname="cisccp_emi3d"
     v3d(i)%oname="dem_s"
-    v3d(i)%stream => scosp
+    v3d(i)%stream => cospoffl
 
 
      i=i+1
     v3d(i)%iname="reffl"
     v3d(i)%oname="Reffl"
-    v3d(i)%stream => scosp
+    v3d(i)%stream => cospoffl
 
      i=i+1
     v3d(i)%iname="reffi"
     v3d(i)%oname="Reffi"
-    v3d(i)%stream => scosp
+    v3d(i)%stream => cospoffl
+
+     i=i+1
+    v3d(i)%iname="icnc"
+    v3d(i)%oname="icnc"
+    v3d(i)%stream => cospoffl
+
+     i=i+1
+    v3d(i)%iname="cdnc"
+    v3d(i)%oname="cdnc"
+    v3d(i)%stream => cospoffl
 
      i=i+1
     v3d(i)%iname="fl_lsrain"
@@ -1431,7 +1421,7 @@ call message('mo_cosp_offline ', message_text )
    USE mo_memory_g3b
    USE mo_memory_base,      ONLY: get_stream_element
    USE mo_memory_base,      ONLY: get_stream_element_info,  memory_info
-   USE mo_exception,        ONLY : message_text, finish
+   USE mo_exception,        ONLY: message_text, finish
    USE mo_control,          ONLY: nlev, nlevp1
 
 
@@ -1492,14 +1482,14 @@ call message('mo_cosp_offline ', message_text )
 ! called during initialization
 ! determine PE and coordinates (row, proma) along curtain 
 
-  USE mo_exception,     ONLY: message, message_text, finish
+  USE mo_exception,     ONLY: message, message_text
 
   USE mo_geoloc,        ONLY: philon_2d, philat_2d
   USE mo_decomposition, ONLY: ldc=>local_decomposition, &
                               gdc => global_decomposition
   USE mo_mpi,           ONLY: p_parallel, p_parallel_io, p_bcast, &
                               p_io, p_pe, p_nprocs, p_send, p_recv, &
-                              p_wait,  p_global_comm 
+                              p_global_comm 
 
 
   IMPLICIT NONE
@@ -1543,8 +1533,8 @@ call message('mo_cosp_offline ', message_text )
   REAL(dp), ALLOCATABLE, DIMENSION(: )   :: sendbuf
   INTEGER,  ALLOCATABLE, DIMENSION(: )   :: irecvbuf 
 
-  INTEGER :: id, i, n, jl, nproma, jrow, np, ngpblks, j
-  INTEGER :: nn, jl1, jr1, nlt, nlk, pe, isu, nlkeepmax1, nlstart1
+  INTEGER :: i, n, jl, nproma, jrow, np, ngpblks, j
+  INTEGER :: nn, jl1, jr1, nlk, pe, isu, nlkeepmax1, nlstart1
   REAL(dp) :: dl, dlt
 
   nlmax = SIZE(slat, 1)
@@ -1816,20 +1806,18 @@ call message('mo_cosp_offline ', message_text )
 !---------------------------------------------------------------------
  SUBROUTINE open_output_file
 
-   USE mo_exception,          ONLY: message, message_text,finish
+   USE mo_exception,          ONLY: message, message_text
    USE mo_netcdf,             ONLY: nf_check
-   USE mo_mpi,                ONLY: p_pe, p_parallel_io
-   USE mo_control,            ONLY: nlev, nlevp1
+   USE mo_mpi,                ONLY: p_parallel_io
+   USE mo_control,            ONLY: nlev
    USE mo_time_control,       ONLY: next_date, timelabel_type,  str_date
    USE mo_filename,           ONLY: out_expname
 
    IMPLICIT NONE
 
-   INCLUDE 'netcdf.inc'
-
 !local
 
-  INTEGER :: n, i, ncid, varid, year_varid, month_varid, day_varid 
+  INTEGER :: i, ncid, varid, year_varid, month_varid, day_varid 
   INTEGER :: hour_varid, minute_varid, second_varid, tim_varid
   INTEGER :: lev_dimid, point_dimid, hydro_dimid
   
@@ -1950,14 +1938,11 @@ call message('mo_cosp_offline ', message_text )
 !------------------------------------------------------------------
   SUBROUTINE nc_date_write( cur, year, month, day, hour, minute, second )
 
-    USE mo_mpi,              ONLY : p_parallel_io
-    USE mo_netcdf,           ONLY : nf_check
-    USE mo_exception,        ONLY: message, message_text, finish
+    USE mo_mpi,              ONLY: p_parallel_io
+    USE mo_netcdf,           ONLY: nf_check
 
    IMPLICIT NONE
  
-   INCLUDE 'netcdf.inc'
-
     INTEGER, INTENT (IN ) :: year, month, day, hour, minute, second
     TYPE(curtain_type), INTENT (IN ), POINTER :: cur
 
@@ -2054,14 +2039,12 @@ END FUNCTION curfillr1
 !------------------------------------------------------------------
  SUBROUTINE nc_write_cu1d(  varid, cu1d, gmax, gcmax )
 
-   USE mo_mpi,              ONLY : p_parallel_io
-   USE mo_netcdf,           ONLY : nf_check
+   USE mo_mpi,              ONLY: p_parallel_io
+   USE mo_netcdf,           ONLY: nf_check
 
 
    IMPLICIT NONE
 
-   INCLUDE 'netcdf.inc'
-
    INTEGER, INTENT(IN ) ::   varid, gmax, gcmax 
 
    REAL(dp), DIMENSION( gmax ) :: cu1d
@@ -2069,7 +2052,6 @@ END FUNCTION curfillr1
 
 
 ! local
-   LOGICAL :: lopt
    INTEGER :: ncid,  start1
    INTEGER, DIMENSION(1) :: start1d, count1d
 
@@ -2095,14 +2077,12 @@ END FUNCTION curfillr1
 !------------------------------------------------------------------
  SUBROUTINE nc_write_cu2d(  varid, cu2d, nlev, gmax, gcmax )
 
-   USE mo_mpi,              ONLY : p_parallel_io
-   USE mo_netcdf,           ONLY : nf_check
+   USE mo_mpi,              ONLY: p_parallel_io
+   USE mo_netcdf,           ONLY: nf_check
 
 
    IMPLICIT NONE
 
-   INCLUDE 'netcdf.inc'
-
    INTEGER, INTENT(IN ) ::   varid, nlev, gmax, gcmax 
 
    REAL(dp), DIMENSION( nlev, gmax ) :: cu2d
@@ -2110,7 +2090,6 @@ END FUNCTION curfillr1
 
 
 ! local
-   LOGICAL :: lopt
    INTEGER :: i, ncid,  start2
    INTEGER, DIMENSION(2) :: start2d, count2d
 
@@ -2141,8 +2120,8 @@ END FUNCTION curfillr1
   SUBROUTINE construct_stream_cospoffl
 
     USE mo_memory_base,   ONLY: new_stream, add_stream_element, &
-			      default_stream_setting 
-    USE mo_control,       ONLY : nlev
+                                default_stream_setting 
+    USE mo_control,       ONLY: nlev
     USE mo_time_event,    ONLY: io_time_event
 
     IMPLICIT NONE
@@ -2166,6 +2145,10 @@ END FUNCTION curfillr1
                                          laccu     = .FALSE.      )
 
 
+    CALL add_stream_element (cospoffl, 'icnc', cospoffl_icnc,  &
+                             longname='in-cloud ICNC', units='m-3')
+    CALL add_stream_element (cospoffl, 'cdnc', cospoffl_cdnc,  &
+                             longname='in-cloud CDNC', units='m-3')
     CALL add_stream_element (cospoffl, 'fl_lsrain', cospoffl_lsrain,  &
                              longname='Large-scale rain flux', units='kg m-2 s-1')
     CALL add_stream_element (cospoffl, 'fl_lssnow', cospoffl_lssnow,  &
@@ -2173,7 +2156,27 @@ END FUNCTION curfillr1
     CALL add_stream_element (cospoffl, 'fl_ccrain', cospoffl_ccrain,  &
                              longname='Convective rain flux', units='kg m-2 s-1')
     CALL add_stream_element (cospoffl, 'fl_ccsnow', cospoffl_ccsnow,  &
-                             longname='Convective snow flux', units='kg m-2 s-1')
+         longname='Convective snow flux', units='kg m-2 s-1')
+
+! added jkretzs
+    
+    CALL add_stream_element (cospoffl, 'reffl', cospoffl_reffl,   laccu     = .FALSE.,&
+         leveltype = HYBRID, &
+         longname='Liquid water droplet effective radius', units='um')
+    CALL add_stream_element (cospoffl, 'reffi', cospoffl_reffi,   laccu     = .FALSE.,&
+         leveltype = HYBRID, &
+         longname='Ice crystal effective radius', units='um')
+
+    CALL add_stream_element (cospoffl, 'cisccp_tau3d', offl_cisccp_cldtau3d, &
+                           leveltype = HYBRID,  &
+                           longname='COSP-ISCCP cloud optical thickness')
+    CALL add_stream_element (cospoffl, 'cisccp_emi3d', offl_cisccp_cldemi3d, &
+                           leveltype = HYBRID, &
+                           longname='COSP-ISCCP cloud optical thickness')
+
+
+! added jkretzs 
+
 
     CALL add_stream_element (cospoffl, 'geom1', cospoffl_geom1, &
          longname = 'geopotential height', &
@@ -2248,7 +2251,7 @@ END FUNCTION unit_info
 SUBROUTINE put_unit ( ncid, varid, unit, oname )
 
   USE mo_netcdf 
-  USE mo_exception,          ONLY: message, message_text,finish
+  USE mo_exception,          ONLY: message_text,finish
 
   INTEGER, INTENT (IN ) :: ncid, varid
   CHARACTER(LEN=150), INTENT(IN ) :: unit, oname
@@ -2267,7 +2270,7 @@ END SUBROUTINE put_unit
 !---------------------------------------------------------------------
 SUBROUTINE collect_arg_check(got_opt, got_ivar, lopt, rname)
 
- USE mo_exception,          ONLY: message, message_text, finish
+ USE mo_exception,          ONLY: message_text, finish
  
  IMPLICIT NONE
 
diff --git a/src/mo_cosp_stats.f90 b/src/mo_cosp_stats.f90
index 7b8ea8d..673d79b 100644
--- a/src/mo_cosp_stats.f90
+++ b/src/mo_cosp_stats.f90
@@ -1,21 +1,54 @@
-! (c) COPYRIGHT British Crown / Met Office 2008  
-! Please refer to Met_Office_license.txt for details. 
+!>
+!! @par Copyright
+!! This code is subject to the MPI-M-Software - License - Agreement in it's most recent form.
+!! Please see URL http://www.mpimet.mpg.de/en/science/models/model-distribution.html and the
+!! file COPYING in the root of the source tree for this code.
+!! Where software is supplied by third parties, it is indicated in the headers of the routines.
+!!
+! (c) British Crown Copyright 2008, the Met Office.
+! All rights reserved.
+! $Revision: 88 $, $Date: 2013-11-13 15:08:38 +0100 (Mi, 13. Nov 2013) $
+! $URL: http://cfmip-obs-sim.googlecode.com/svn/stable/v1.4.0/cosp_stats.F90 $
+!
+! Redistribution and use in source and binary forms, with or without modification, are permitted
+! provided that the following conditions are met:
+!
+!     * Redistributions of source code must retain the above copyright notice, this list
+!       of conditions and the following disclaimer.
+!     * Redistributions in binary form must reproduce the above copyright notice, this list
+!       of conditions and the following disclaimer in the documentation and/or other materials
+!       provided with the distribution.
+!     * Neither the name of the Met Office nor the names of its contributors may be used
+!       to endorse or promote products derived from this software without specific prior written
+!       permission.
+!
+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+! IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+! FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+! IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+! OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 !
 ! History:
 ! Jul 2007 - A. Bodas-Salcedo - Initial version
 ! Jul 2008 - A. Bodas-Salcedo - Added capability of producing outputs in standard grid
 ! Oct 2008 - J.-L. Dufresne   - Bug fixed. Assignment of Npoints,Nlevels,Nhydro,Ncolumns in COSP_STATS
 ! Oct 2008 - H. Chepfer       - Added PARASOL reflectance arguments
+! Jun 2010 - T. Yokohata, T. Nishimura and K. Ogochi - Added NEC SXs optimisations
+! Jan 2013 - G. Cesana        - Added betaperp and temperature arguments 
+!                             - Added phase 3D/3Dtemperature/Map output variables in diag_lidar 
+!
 !
-! 
-
-MODULE mo_cosp_stats
-
-  USE mo_kind,  ONLY: dp
-  USE mo_cosp_constants
-  USE mo_cosp_llnl_stats
-  USE mo_cosp_lmd_ipsl_stats
 
+MODULE MO_COSP_STATS
+  USE mo_kind,		ONLY: wp
+  USE MO_COSP_CONSTANTS
+  USE MO_COSP_TYPES
+  USE MO_COSP_LLNL_STATS
+  USE MO_COSP_LMD_IPSL_STATS
   IMPLICIT NONE
 
 CONTAINS
@@ -23,200 +56,260 @@ CONTAINS
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 !------------------- SUBROUTINE COSP_STATS ------------------------
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-SUBROUTINE cosp_stats(kbdim,Ncolumns,klev,           &
-                      Llidar_sim, Llidar_cfad,       &
-!gbx
-                      ph, zlev, zlev_half, land,     &
-!sglidar
-                      beta_mol, beta_tot, refl,      &
-                      srbval, cfad_sr, lidarcld,     &
-                      cldlayer, parasolrefl          )
-   ! Input arguments
-   INTEGER, INTENT(IN) :: kbdim,Ncolumns,klev
+SUBROUTINE COSP_STATS(gbx,sgx,cfg,sgradar,sglidar,vgrid,stradar,stlidar)
 
-   LOGICAL, INTENT(IN ) :: Llidar_sim, Llidar_cfad
 
-!gbx
-   REAL(dp), INTENT(INOUT) :: ph(kbdim,klev)
-   REAL(dp), INTENT(INOUT) :: zlev(kbdim,klev)
-   REAL(dp), INTENT(INOUT) :: zlev_half(kbdim,klev)
-   REAL(dp), INTENT(INOUT) :: land(kbdim)
+   ! Input arguments
+   type(cosp_gridbox),intent(in) :: gbx
+   type(cosp_subgrid),intent(in) :: sgx
+   type(cosp_config),intent(in)  :: cfg
+   type(cosp_sgradar),intent(in) :: sgradar
+   type(cosp_sglidar),intent(in) :: sglidar
+   type(cosp_vgrid),intent(in)   :: vgrid
 
-!sglidar
-   REAL(dp) :: beta_mol(kbdim,klev) 
-   REAL(dp) :: beta_tot(kbdim,Ncolumns,klev)
-   REAL(dp) :: refl(kbdim,Ncolumns,PARASOL_NREFL)
+   ! Output arguments
+   type(cosp_radarstats),intent(inout) :: stradar ! Summary statistics for radar
+   type(cosp_lidarstats),intent(inout) :: stlidar ! Summary statistics for lidar 
+   
+   ! Local variables 
+   integer :: Npoints  !# of grid points
+   integer :: Nlevels  !# of levels
+   integer :: Nhydro   !# of hydrometeors
+   integer :: Ncolumns !# of columns
+   integer :: Nlr
+   integer :: max_bin  !Copied from radar simulator  (CNam)
 
-! stlidar lidar stats
-   REAL(dp), INTENT(INOUT) :: srbval(SR_BINS)
-   REAL(dp), INTENT(INOUT) :: cfad_sr(kbdim,SR_BINS,Nlr) 
-   REAL(dp), INTENT(INOUT) :: lidarcld(kbdim,Nlr)
-   REAL(dp), INTENT(INOUT) :: cldlayer(kbdim,LIDAR_NCAT)
-   REAL(dp), INTENT(INOUT) :: parasolrefl(kbdim,PARASOL_NREFL)
+   logical :: ok_lidar_cfad = .false.
 
-   ! Local variables 
-   REAL(dp) :: betatot_out(kbdim,Ncolumns,Nlr)
-   REAL(dp) :: betamol_in(kbdim,1,klev)
-   REAL(dp) :: betamol_out(kbdim,1,Nlr)
-   REAL(dp) :: betamol_c(kbdim,Nlr)
-   REAL(dp) :: ph_in(kbdim,1,klev)
-   REAL(dp) :: ph_out(kbdim,1,Nlr)
-   REAL(dp) :: ph_c(kbdim,Nlr)
-
-! vgrid
-   REAL(dp) :: z(Nlr), zl(Nlr), zu(Nlr)
-   REAL(dp) :: zstep
-   
-   INTEGER :: i
+   real(wp),dimension(:,:,:),allocatable :: Ze_out,betatot_out,betamol_in,betamol_out,ph_in,ph_out
+   real(wp),dimension(:,:),allocatable :: ph_c,betamol_c
+   real(wp),dimension(:,:,:),allocatable :: betaperptot_out, temp_in, temp_out 
+   real(wp),dimension(:,:),allocatable :: temp_c
 
-   IF (use_vgrid) THEN ! Statistics in a different vertical grid
+   Npoints  = gbx%Npoints
+   Nlevels  = gbx%Nlevels
+   Nhydro   = gbx%Nhydro
+   Ncolumns = gbx%Ncolumns
+   Nlr      = vgrid%Nlvgrid
+   max_bin=25 
 
-       ! cloudsat grid
-        zstep = 480.0_dp
-      DO i=1,Nlr
-         zl(i) = REAL((i-1),dp)*zstep
-         zu(i) =  REAL(i,dp)*zstep
-      ENDDO
-       z = (zl + zu)/2.0_dp
+   if (cfg%LcfadLidarsr532) ok_lidar_cfad=.true.
 
-        betatot_out  = 0.0_dp
-        betamol_out= 0.0_dp
-        betamol_c  = 0.0_dp
-        ph_in(:,1,:)  = ph(:,:)
-        ph_out  = 0.0_dp
-        ph_c    = 0.0_dp
+   if (vgrid%use_vgrid) then ! Statistics in a different vertical grid
+        allocate(Ze_out(Npoints,Ncolumns,Nlr),betatot_out(Npoints,Ncolumns,Nlr), &
+                 betamol_in(Npoints,1,Nlevels),betamol_out(Npoints,1,Nlr),betamol_c(Npoints,Nlr), &
+                 ph_in(Npoints,1,Nlevels),ph_out(Npoints,1,Nlr),ph_c(Npoints,Nlr))
+        Ze_out = 0.0
+        betatot_out  = 0.0
+        betamol_out= 0.0
+        betamol_c  = 0.0
+        ph_in(:,1,:)  = gbx%ph(:,1:Nlevels) ! CNam orig: gbx%ph(:,:)
+        ph_out  = 0.0
+        ph_c    = 0.0
+        allocate(betaperptot_out(Npoints,Ncolumns,Nlr),temp_in(Npoints,1,Nlevels),temp_out(Npoints,1,Nlr), &
+                 temp_c(Npoints,Nlr))
+        betaperptot_out = 0.0
+        temp_in = 0.0
+        temp_out = 0.0
+        temp_c = 0.0
 
+        !++++++++++++ Radar CFAD ++++++++++++++++
+        if (cfg%Lradar_sim) then
+            call cosp_change_vertical_grid(Npoints,Ncolumns,Nlevels,gbx%zlev,gbx%zlev_half,sgradar%Ze_tot, &
+                                           Nlr,vgrid%zl,vgrid%zu,Ze_out,log_units=.true.)
+            stradar%cfad_ze = cosp_cfad(Npoints,Ncolumns,Nlr,DBZE_BINS,Ze_out, &
+                                        DBZE_MIN,DBZE_MAX,CFAD_ZE_MIN,CFAD_ZE_WIDTH)
+        endif
         !++++++++++++ Lidar CFAD ++++++++++++++++
-        IF (Llidar_sim) THEN
-            betamol_in(:,1,:) = beta_mol(:,:)
-            CALL cosp_change_vertical_grid(kbdim,1,klev,zlev,zlev_half,betamol_in, &
-                                           Nlr,zl,zu,betamol_out)
-            CALL cosp_change_vertical_grid(kbdim,Ncolumns,klev,zlev,zlev_half,beta_tot, &
-                                           Nlr,zl,zu,betatot_out)
-            CALL cosp_change_vertical_grid(kbdim,1,klev,zlev,zlev_half,ph_in, &
-                                           Nlr,zl,zu,ph_out)
+        if (cfg%Llidar_sim) then
+            betamol_in(:,1,:) = sglidar%beta_mol(:,:)
+            call cosp_change_vertical_grid(Npoints,1,Nlevels,gbx%zlev,gbx%zlev_half,betamol_in, &
+                                           Nlr,vgrid%zl,vgrid%zu,betamol_out)
+            call cosp_change_vertical_grid(Npoints,Ncolumns,Nlevels,gbx%zlev,gbx%zlev_half,sglidar%beta_tot, &
+                                           Nlr,vgrid%zl,vgrid%zu,betatot_out)
+
+            temp_in(:,1,:) = gbx%T(:,:)
+            call cosp_change_vertical_grid(Npoints,Ncolumns,Nlevels,gbx%zlev,gbx%zlev_half,sglidar%betaperp_tot, &
+                                           Nlr,vgrid%zl,vgrid%zu,betaperptot_out)
+            call cosp_change_vertical_grid(Npoints,1,Nlevels,gbx%zlev,gbx%zlev_half,temp_in, &
+                                           Nlr,vgrid%zl,vgrid%zu,temp_out)
+            temp_c(:,:) = temp_out(:,1,:)
+
+            call cosp_change_vertical_grid(Npoints,1,Nlevels,gbx%zlev,gbx%zlev_half,ph_in, &
+                                           Nlr,vgrid%zl,vgrid%zu,ph_out)
             ph_c(:,:) = ph_out(:,1,:)
             betamol_c(:,:) = betamol_out(:,1,:)
             ! Stats from lidar_stat_summary
-            CALL diag_lidar(kbdim,Ncolumns,Nlr,SR_BINS,PARASOL_NREFL &
-                            ,betatot_out,betamol_c,refl,land,ph_c &
-                            ,LIDAR_UNDEF,Llidar_cfad &
-                            ,cfad_sr,srbval &
-                            ,LIDAR_NCAT,lidarcld,cldlayer,parasolrefl)
-        ENDIF
-    
-   ELSE ! Statistics in model levels
-    !++++++++++++ Lidar CFAD ++++++++++++++++
-    ! Stats from lidar_stat_summary
-    IF (Llidar_sim) CALL diag_lidar(kbdim,Ncolumns,Nlr,SR_BINS,PARASOL_NREFL &
-                         ,beta_tot,beta_mol,refl,land,ph &
-                         ,LIDAR_UNDEF,Llidar_sim & 
-                         ,cfad_sr,srbval &
-                         ,LIDAR_NCAT,lidarcld,cldlayer,parasolrefl)
-    ENDIF
- ! Replace undef
-   WHERE (cfad_sr   == LIDAR_UNDEF) cfad_sr   = R_UNDEF 
-   WHERE (lidarcld  == LIDAR_UNDEF) lidarcld  = R_UNDEF 
-   WHERE (cldlayer  == LIDAR_UNDEF) cldlayer  = R_UNDEF 
-   WHERE (parasolrefl == LIDAR_UNDEF) parasolrefl = R_UNDEF 
+            call diag_lidar(Npoints,Ncolumns,Nlr,SR_BINS,PARASOL_NREFL &
+                            ,temp_c,betatot_out,betaperptot_out,betamol_c,sglidar%refl,gbx%land,ph_c &
+                            ,LIDAR_UNDEF,ok_lidar_cfad &
+                            ,stlidar%cfad_sr,stlidar%srbval &
+                            ,LIDAR_NCAT,stlidar%lidarcld,stlidar%lidarcldphase &
+                            ,stlidar%cldlayer,stlidar%cldlayerphase,stlidar%lidarcldtmp &
+                            ,stlidar%parasolrefl)
+        endif
+
+        !++++++++++++ Lidar-only cloud amount and lidar&radar total cloud mount ++++++++++++++++
+        if (cfg%Lradar_sim.and.cfg%Llidar_sim) call cosp_lidar_only_cloud(Npoints,Ncolumns,Nlr, &
+                                    temp_c,betatot_out,betaperptot_out,betamol_c,Ze_out, &
+                                    stradar%lidar_only_freq_cloud,stradar%radar_lidar_tcc)
+        deallocate(temp_out,temp_c,betaperptot_out)
+
+        ! Deallocate arrays at coarse resolution
+        deallocate(Ze_out,betatot_out,betamol_in,betamol_out,betamol_c,ph_in,ph_out,ph_c)
+
+   else ! Statistics in model levels
+
+	!++++++++++++ Radar CFAD ++++++++++++++++
+	if (cfg%Lradar_sim) stradar%cfad_ze = cosp_cfad(Npoints,Ncolumns,Nlr,DBZE_BINS,sgradar%Ze_tot, &
+	    DBZE_MIN,DBZE_MAX,CFAD_ZE_MIN,CFAD_ZE_WIDTH)
+
+	!++++++++++++ Lidar CFAD ++++++++++++++++
+	! Stats from lidar_stat_summary
+	if (cfg%Llidar_sim) call diag_lidar(Npoints,Ncolumns,Nlr,SR_BINS,PARASOL_NREFL &
+           ,sglidar%temp_tot,sglidar%beta_tot,sglidar%betaperp_tot,sglidar%beta_mol,sglidar%refl,gbx%land,gbx%ph &
+           ,LIDAR_UNDEF,ok_lidar_cfad &
+           ,stlidar%cfad_sr,stlidar%srbval &
+           ,LIDAR_NCAT,stlidar%lidarcld,stlidar%lidarcldphase,stlidar%cldlayer,stlidar%cldlayerphase &
+           ,stlidar%lidarcldtmp,stlidar%parasolrefl)
+
+	!++++++++++++ Lidar-only cloud amount and lidar&radar total cloud mount ++++++++++++++++
+	if (cfg%Lradar_sim .and. cfg%Llidar_sim) call cosp_lidar_only_cloud(Npoints,Ncolumns,Nlr, &
+           sglidar%temp_tot,sglidar%beta_tot,sglidar%betaperp_tot,sglidar%beta_mol,sgradar%Ze_tot, &
+           stradar%lidar_only_freq_cloud,stradar%radar_lidar_tcc)
+   
+   endif
    
-END SUBROUTINE cosp_stats
+   ! Replace undef
+   where (stlidar%cfad_sr   == LIDAR_UNDEF) stlidar%cfad_sr   = R_UNDEF
+   where (stlidar%lidarcld  == LIDAR_UNDEF) stlidar%lidarcld  = R_UNDEF
+   where (stlidar%cldlayer  == LIDAR_UNDEF) stlidar%cldlayer  = R_UNDEF
+   where (stlidar%parasolrefl == LIDAR_UNDEF) stlidar%parasolrefl = R_UNDEF
+   where (stlidar%cldlayerphase  == LIDAR_UNDEF) stlidar%cldlayerphase  = R_UNDEF
+   where (stlidar%lidarcldphase  == LIDAR_UNDEF) stlidar%lidarcldphase  = R_UNDEF
+   where (stlidar%lidarcldtmp  == LIDAR_UNDEF) stlidar%lidarcldtmp  = R_UNDEF
+
+END SUBROUTINE COSP_STATS
 
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 !---------- SUBROUTINE COSP_CHANGE_VERTICAL_GRID ----------------
 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-SUBROUTINE cosp_change_vertical_grid(Npoints,Ncolumns,Nlevels,zfull,zhalf,y,M,zl,zu,r,log_units)
-
-   IMPLICIT NONE
-
+SUBROUTINE COSP_CHANGE_VERTICAL_GRID(Npoints,Ncolumns,Nlevels,zfull,zhalf,y,Nglevels,newgrid_bot,newgrid_top,r,log_units)
+   implicit none
    ! Input arguments
-   INTEGER, INTENT(in) :: Npoints  !# of grid points
-   INTEGER, INTENT(in) :: Nlevels  !# of levels
-   INTEGER, INTENT(in) :: Ncolumns !# of columns
-   REAL(dp), DIMENSION(Npoints,Nlevels), INTENT(in) :: zfull ! Height at model levels [m] (Bottom of model layer)
-   REAL(dp), DIMENSION(Npoints,Nlevels), INTENT(in) :: zhalf ! Height at half model levels [m] (Bottom of model layer)
-   REAL(dp), DIMENSION(Npoints,Ncolumns,Nlevels), INTENT(in) :: y     ! Variable to be changed to a different grid
-   INTEGER, INTENT(in) :: M  !# levels in the new grid
-   REAL(dp), DIMENSION(M), INTENT(in) :: zl ! Lower boundary of new levels  [m]
-   REAL(dp), DIMENSION(M), INTENT(in) :: zu ! Upper boundary of new levels  [m]
-   LOGICAL, OPTIONAL, INTENT(in) :: log_units ! log units, need to convert to linear units
+   integer,intent(in) :: Npoints  !# of grid points
+   integer,intent(in) :: Nlevels  !# of levels
+   integer,intent(in) :: Ncolumns !# of columns
+   real(wp),dimension(Npoints,Nlevels),intent(in) :: zfull ! Height at model levels [m] (Bottom of model layer)
+   real(wp),dimension(Npoints,Nlevels),intent(in) :: zhalf ! Height at half model levels [m] (Bottom of model layer)
+   real(wp),dimension(Npoints,Ncolumns,Nlevels),intent(in) :: y     ! Variable to be changed to a different grid
+   integer,intent(in) :: Nglevels  !# levels in the new grid
+   real(wp),dimension(Nglevels),intent(in) :: newgrid_bot ! Lower boundary of new levels  [m]
+   real(wp),dimension(Nglevels),intent(in) :: newgrid_top ! Upper boundary of new levels  [m]
+   logical,optional,intent(in) :: log_units ! log units, need to convert to linear units
    ! Output
-   REAL(dp), DIMENSION(Npoints,Ncolumns,M), INTENT(out) :: r ! Variable on new grid
+   real(wp),dimension(Npoints,Ncolumns,Nglevels),intent(out) :: r ! Variable on new grid
 
    ! Local variables
-   INTEGER :: i,j,k
-   LOGICAL :: lunits
-
-   REAL(dp) :: ws
-   REAL(dp), DIMENSION(Nlevels) :: xl,xu ! Lower and upper boundaries of model grid
-   REAL(dp), DIMENSION(M) :: dz          ! Layer depth
-   REAL(dp), DIMENSION(Nlevels,M) :: w   ! Weights to do the mean at each point
-   REAL(dp), DIMENSION(Ncolumns,Nlevels) :: yp  ! Variable to be changed to a different grid.
-                                           ! Local copy at a particular point.
-                                           ! This allows for change of units.
+   integer :: i,j,k
+   logical :: lunits
+   integer :: l
+   real(wp):: w ! Weight
+   real(wp):: dbb, dtb, dbt, dtt ! Distances between edges of both grids
+   integer :: Nw  ! Number of weights
+   real(wp):: wt  ! Sum of weights
+   real(wp),dimension(Nlevels) :: oldgrid_bot,oldgrid_top ! Lower and upper boundaries of model grid
+   real(wp):: yp ! Local copy of y at a particular point.
+              ! This allows for change of units.
+
    lunits=.false.
-   IF (present(log_units)) lunits=log_units
-
-   r = R_UNDEF
-   DO i=1,Npoints
-     ! Vertical grid at that point
-     xl = zhalf(i,:)
-     xu(1:Nlevels-1) = xl(2:Nlevels)
-     xu(Nlevels) = zfull(i,Nlevels) +  zfull(i,Nlevels) - zhalf(i,Nlevels) ! Top level symmetric
-     dz = zu - zl
-     yp = y(i,:,:) ! Temporary variable to regrid
-     ! Find weights
-     w = 0.0_dp
-     DO k=1,M
-       DO j=1,Nlevels
-         IF ((xl(j) < zl(k)).and.(xu(j) > zl(k)).and.(xu(j) <= zu(k))) THEN
-           !xl(j)-----------------xu(j)
-           !      zl(k)------------------------------zu(k)
-           w(j,k) = xu(j) - zl(k)
-         ELSEIF ((xl(j) >= zl(k)).and.(xu(j) <= zu(k))) THEN
-           !           xl(j)-----------------xu(j)
-           !      zl(k)------------------------------zu(k)
-           w(j,k) = xu(j) - xl(j)
-         ELSEIF ((xl(j) >= zl(k)).and.(xl(j) < zu(k)).and.(xu(j) >= zu(k))) THEN
-           !                           xl(j)-----------------xu(j)
-           !      zl(k)------------------------------zu(k)
-           w(j,k) = zu(k) - xl(j)
-         ELSEIF ((xl(j) <= zl(k)).and.(xu(j) >= zu(k))) THEN
-           !  xl(j)---------------------------xu(j)
-           !        zl(k)--------------zu(k)
-           w(j,k) = dz(k)
-         ENDIF
-       ENDDO
-     ENDDO
-     ! Check for dBZ and change if necessary
-     IF (lunits) THEN
-        WHERE (yp /= R_UNDEF)
-          yp = 10.0_dp**(yp/10.0_dp)
-        ELSEWHERE
-          yp = 0.0_dp
-        ENDWHERE
-     ENDIF
-     ! Do the weighted mean
-     DO j=1,Ncolumns
-       DO k=1,M
-          IF (zu(k) <= zhalf(i,1)) THEN ! Level below model bottom level
-             r(i,j,k) = R_GROUND
-          ELSE
-            ws = sum(w(:,k))
-            IF ((ws > 0.0_dp).and.(r(i,j,k) /= R_GROUND)) r(i,j,k) = sum(w(:,k)*yp(j,:))/ws
-            ! Check for dBZ and change if necessary
-            IF ((lunits).and.(r(i,j,k) /= R_GROUND)) THEN
-                IF (r(i,j,k) <= 0.0_dp) THEN
-                    r(i,j,k) = R_UNDEF
-                ELSE
-                    r(i,j,k) = 10.0_dp*log10(r(i,j,k))
-                ENDIF
-            ENDIF
-          ENDIF
-       ENDDO
-     ENDDO
-   ENDDO
-
-END SUBROUTINE cosp_change_vertical_grid
-
-END MODULE mo_cosp_stats
+   if (present(log_units)) lunits=log_units
+
+   r = 0.0_wp
+
+   do i=1,Npoints
+     ! Calculate tops and bottoms of new and old grids
+     oldgrid_bot = zhalf(i,:)
+     oldgrid_top(1:Nlevels-1) = oldgrid_bot(2:Nlevels)
+     oldgrid_top(Nlevels) = zfull(i,Nlevels) +  zfull(i,Nlevels) - zhalf(i,Nlevels) ! Top level symmetric
+     l = 0 ! Index of level in the old grid
+     ! Loop over levels in the new grid
+     do k = 1,Nglevels
+       Nw = 0 ! Number of weigths
+       wt = 0.0_wp ! Sum of weights
+       ! Loop over levels in the old grid and accumulate total for weighted average
+       do
+         l = l + 1
+         w = 0.0_wp ! Initialise weight to 0
+         ! Distances between edges of both grids
+         dbb = oldgrid_bot(l) - newgrid_bot(k)
+         dtb = oldgrid_top(l) - newgrid_bot(k)
+         dbt = oldgrid_bot(l) - newgrid_top(k)
+         dtt = oldgrid_top(l) - newgrid_top(k)
+         if (dbt >= 0.0_wp) exit ! Do next level in the new grid
+         if (dtb > 0.0_wp) then
+           if (dbb <= 0.0_wp) then
+             if (dtt <= 0_wp) then
+               w = dtb
+             else
+               w = newgrid_top(k) - newgrid_bot(k)
+             endif
+           else
+             if (dtt <= 0) then
+               w = oldgrid_top(l) - oldgrid_bot(l)
+             else
+               w = -dbt
+             endif
+           endif
+           ! If layers overlap (w/=0), then accumulate
+           if (w /= 0.0_wp) then
+             Nw = Nw + 1
+             wt = wt + w
+             do j=1,Ncolumns
+               if (lunits) then
+                 if (y(i,j,l) /= R_UNDEF) then
+                   yp = 10.0_wp**(y(i,j,l)/10.0_wp)
+                 else
+                   yp = 0.0_wp
+                 endif
+               else
+                 yp = y(i,j,l)
+               endif
+               r(i,j,k) = r(i,j,k) + w*yp
+             enddo
+           endif
+         endif
+       enddo
+       l = l - 2
+       if (l < 1) l = 0
+       ! Calculate average in new grid
+       if (Nw > 0) then
+         do j=1,Ncolumns
+           r(i,j,k) = r(i,j,k)/wt
+         enddo
+       endif
+     enddo
+   enddo
+
+   ! Set points under surface to R_UNDEF, and change to dBZ if necessary
+   do k=1,Nglevels
+     do j=1,Ncolumns
+       do i=1,Npoints
+         if (newgrid_top(k) > zhalf(i,1)) then ! Level above model bottom level
+           if (lunits) then
+             if (r(i,j,k) <= 0.0_wp) then
+               r(i,j,k) = R_UNDEF
+             else
+               r(i,j,k) = 10.0_wp*log10(r(i,j,k))
+             endif
+           endif
+         else ! Level below surface
+           r(i,j,k) = R_GROUND
+         endif
+       enddo
+     enddo
+   enddo
+
+END SUBROUTINE COSP_CHANGE_VERTICAL_GRID
+
+END MODULE MO_COSP_STATS
diff --git a/src/mo_ham_m7.f90 b/src/mo_ham_m7.f90
index 2c6d2ed..65c722f 100644
--- a/src/mo_ham_m7.f90
+++ b/src/mo_ham_m7.f90
@@ -16,6 +16,8 @@
 !! and was adapted for ECHAM by P. Stier, Oxford. Other contributions include 
 !! D. O'Donnell, K. Zhang and others
 !!   -# M.G. Schultz (FZ Juelich) - new code structure for integration into echam6-hammoz (2009-09-24)
+!!P. Petersik (ppetersik) 
+!!   -#added stochastic parameterization of subgrid variability of clear-sky RH for computing hygroscopic growth
 !!
 !! \limitations
 !! None
@@ -131,6 +133,7 @@ SUBROUTINE m7_interface(kproma, kbdim, klev, krow, ktrac, &
   !>>dod timers
   USE mo_control,        ONLY: ltimer
   USE mo_hammoz_timer,   ONLY: timer_start, timer_stop, timer_ham_m7_main
+  USE mo_random_numbers  ONLY: random_uniform2 !ppetersik
   !<<dod
 
   IMPLICIT NONE 
@@ -212,7 +215,9 @@ SUBROUTINE m7_interface(kproma, kbdim, klev, krow, ktrac, &
   !>>dod from array
   LOGICAL :: labort
   !<<dod
-
+  
+  REAL(dp):: rand(kbdim)    !ppetersik
+  
   !--- 0) Initialisations: -----------------------------------------------------
   
   zmass_pre  = 0._dp
@@ -258,8 +263,8 @@ SUBROUTINE m7_interface(kproma, kbdim, klev, krow, ktrac, &
   zqfacn = 1.0_dp/zfacn
 
   !--- 2) Calculate ambient properties: ----------------------------------------
-  
-  DO jk = 1,klev
+    DO jk = 1,klev
+    CALL random_uniform2(rand) !ppetersik
     DO  jl = 1,kproma
       
       !--- 2.1) Calculate air density:
@@ -281,7 +286,9 @@ SUBROUTINE m7_interface(kproma, kbdim, klev, krow, ktrac, &
       zq_amb = MAX( 0.0_dp , (pq(jl,jk)-zqs*zaclc)/(1._dp-zaclc) )
       
       zrh(jl,jk) = zq_amb/zqs
-      
+     
+      CALL m7_stoch_disturbance(zrh(jl,jk),rand(jl),pap(jl,jk), paph(jl,klev+1)) !ppetersik
+     
       zrh(jl,jk) = MAX(0.0_dp,MIN(zrh(jl,jk),1.0_dp))
       
       !--- Air mass auxiliary variable:
@@ -601,6 +608,40 @@ END SUBROUTINE m7_interface
 
 ! ---------------------------------------------------------------------------
 
+SUBROUTINE m7_stoch_disturbance( zrh, rand, pap,paps )
+  !
+  !*******************************************************************************
+  ! author : ppetersik
+  
+  USE mo_kind,           ONLY: dp
+  USE mo_cloud,          ONLY : crt, crs, nex
+
+  IMPLICIT NONE
+  ! inout variables
+  REAL(dp), INTENT(INOUT) :: zrh       ! clear sky rel. humidity 
+  REAL(dp), INTENT(IN)    :: rand      ! random number in [0,1]
+  REAL(dp), INTENT(IN)    :: pap       ! pressure at full levels
+  REAL(dp), INTENT(IN)    :: paps      ! pressure at half levels, at the lowest level -> surface pressure
+  ! local variables
+  REAL(dp)                :: dr                 ! width of the probability density function applied on clear sky relative humidity
+  REAL(dp)                :: rcrit              ! critical relative humidity
+  
+  ! calculate crtical relative humidity as Quaas(2012) (Constants from Sundquivst(1989))
+  rcrit = crt+(crs-crt)*EXP(1._dp-(paps/pap)**nex)   ! equation copied from cover.f90 line 740
+  dr    = 1.0_dp - rcrit
+
+  ! if fractional cloud cover exists, just vary the relative humidity in the undersaturated
+  IF ((1.0_dp-zrh).lt. dr) THEN 
+     dr = 1.0_dp - zrh
+  END IF
+
+  ! draft the the random relative humidity by using the random number "rand" as  argument in the  the inversion of the cumulative distribution function
+  zrh = zrh + dr*(2.0_dp*rand-1.0_dp)
+  
+  END SUBROUTINE m7_stoch_disturbance
+    
+! ---------------------------------------------------------------------------
+    
 SUBROUTINE m7_cumulative_normal ( arg, presult, ccum )
   !
   !*******************************************************************************
diff --git a/src/mo_ham_streams.f90 b/src/mo_ham_streams.f90
index c8bf8bf..b28dc98 100644
--- a/src/mo_ham_streams.f90
+++ b/src/mo_ham_streams.f90
@@ -404,7 +404,7 @@ MODULE mo_ham_streams
   ! *new_stream_ham_rad* is called from *init_subm_memory*
   !                             in *mo_submodel_interface*
 
-  USE mo_memory_base,   ONLY: new_stream, add_stream_element, &
+  USE mo_memory_base,   ONLY: new_stream, add_stream_element, set_stream, &
                               default_stream_setting, add_stream_reference, AUTO
   USE mo_linked_list,   ONLY: t_stream, SURFACE, HYBRID
   USE mo_filename,      ONLY: trac_filetype
@@ -415,7 +415,7 @@ MODULE mo_ham_streams
   USE mo_ham_m7ctl,     ONLY: m7_naerospec, m7_aerospec
   USE mo_exception,     ONLY: finish
   USE mo_ham,           ONLY: nmod, nraddiag, m7mode
-
+  USE mo_time_event,  ONLY: io_time_event
 
   IMPLICIT NONE
 
@@ -425,6 +425,7 @@ MODULE mo_ham_streams
   CHARACTER(len=18) :: comp_str
 
   TYPE (t_stream),  POINTER :: rad
+  TYPE(io_time_event), SAVE     :: putrad
 
   !---executable procedure
 
@@ -435,7 +436,13 @@ MODULE mo_ham_streams
 
   !--- Create new stream:
 
+  putrad%counter      = 3
+  putrad%unit         = 'hours'
+  putrad%adjustment   = 'first'
+  putrad%offset       = 0
   CALL new_stream (rad ,'rad',filetype=trac_filetype)
+  call set_stream(rad, interval = putrad)
+
 
   !--- 1) Add standard fields for post-processing:
 
@@ -448,7 +455,7 @@ MODULE mo_ham_streams
 
   CALL default_stream_setting (rad, lrerun   = .TRUE.,   &
                                     laccu    = .FALSE.,  &
-                                    lpost    = .TRUE.,   &
+                                    lpost    = .FALSE.,   &
                                     table    = 200,      &
                                     code     = AUTO      )
   !<<dod
@@ -549,7 +556,7 @@ MODULE mo_ham_streams
         IF (nraddiagwv(jwv)>0) THEN
 
            CALL add_stream_element(rad, 'TAU_2D'//'_'//cwv,  tau_2d(jwv)%ptr,     units='1',  &
-                                   longname='Optical thickness - total '//cwv    )
+                lpost = .TRUE., longname='Optical thickness - total '//cwv    )
 
         END IF
 
@@ -594,7 +601,7 @@ MODULE mo_ham_streams
         cwv2=TRIM(ADJUSTL(cwv2))//'nm'
 
         CALL add_stream_element(rad, 'ANG_'//TRIM(ADJUSTL(cwv))//'_'//TRIM(ADJUSTL(cwv2)), ang, units='1', &
-                               longname='Angstroem parameter between '//TRIM(ADJUSTL(cwv))//' and '//TRIM(ADJUSTL(cwv2)) )
+             lpost = .TRUE., longname='Angstroem parameter between '//TRIM(ADJUSTL(cwv))//' and '//TRIM(ADJUSTL(cwv2)) )
 
      ELSE
         CALL finish('construct_stream_ham_rad:','Angstroem parameter between '//TRIM(ADJUSTL(cwv))  &
diff --git a/src/mo_machine.f90 b/src/mo_machine.f90
index 3db9790..e72871d 100644
--- a/src/mo_machine.f90
+++ b/src/mo_machine.f90
@@ -126,8 +126,12 @@ CONTAINS
     emax     = MAXEXPONENT (dd)
     rmax     = HUGE (dd)
 
-    CALL rounding
-
+    !cms CALL rounding
+    !cms++
+       lrnd=.TRUE.
+       lieee=.TRUE.    
+       CALL message('',' WARNING: set rounding to ieee, skipped test')
+    !cms--
     IF (lrnd) THEN
        epsi = (REAL(base,dp)**(1-mantissa))/2
     ELSE
diff --git a/src/mo_memory_g3b.f90 b/src/mo_memory_g3b.f90
index c29804f..251b497 100644
--- a/src/mo_memory_g3b.f90
+++ b/src/mo_memory_g3b.f90
@@ -3,8 +3,9 @@ MODULE mo_memory_g3b
   USE mo_kind,        ONLY: dp
   USE mo_linked_list, ONLY: t_stream
   USE mo_memory_base, ONLY: delete_stream, add => add_stream_element, &
-                            default_stream_setting,                   &
+                            default_stream_setting, set_stream,       &
                             HYBRID_H, HYBRID
+  USE mo_time_event,  ONLY: io_time_event ! for g3b_rain output interval
 
   IMPLICIT NONE
 
@@ -13,6 +14,7 @@ MODULE mo_memory_g3b
   PUBLIC :: construct_g3b ! routine to construct the g3b table
   PUBLIC :: destruct_g3b  ! routine to destruct  the g3b table
   PUBLIC :: g3b           ! the g3b table
+  PUBLIC :: g3b_rain      ! the g3b table
 
   ! declaration of predefined fields within this module
 
@@ -33,6 +35,11 @@ MODULE mo_memory_g3b
   REAL(dp), POINTER, PUBLIC :: aprl(:,:)
   REAL(dp), POINTER, PUBLIC :: aprc(:,:)
   REAL(dp), POINTER, PUBLIC :: aprs(:,:)
+  REAL(dp), POINTER, PUBLIC :: aprl_na(:,:)
+  REAL(dp), POINTER, PUBLIC :: aprc_na(:,:)
+  REAL(dp), POINTER, PUBLIC :: aprs_na(:,:)
+  REAL(dp), POINTER, PUBLIC :: aprcs_na(:,:)
+  REAL(dp), POINTER, PUBLIC :: clcpre(:,:)
   REAL(dp), POINTER, PUBLIC :: ustrgw(:,:)
   REAL(dp), POINTER, PUBLIC :: vstrgw(:,:)
   REAL(dp), POINTER, PUBLIC :: vdisgw(:,:)
@@ -93,6 +100,8 @@ MODULE mo_memory_g3b
   REAL(dp), POINTER, PUBLIC :: qvi(:,:)
   REAL(dp), POINTER, PUBLIC :: xlvi(:,:)
   REAL(dp), POINTER, PUBLIC :: xivi(:,:)
+  REAL(dp), POINTER, PUBLIC :: xlvi_na(:,:)
+  REAL(dp), POINTER, PUBLIC :: xivi_na(:,:)
   REAL(dp), POINTER, PUBLIC :: runlnd(:,:)
   REAL(dp), POINTER, PUBLIC :: rgcgn(:,:)
   REAL(dp), POINTER, PUBLIC :: sodif(:,:)
@@ -268,6 +277,9 @@ MODULE mo_memory_g3b
   ! declaration of table with 2d- and 3d-field entries
 
   TYPE (t_stream), POINTER     :: g3b
+  TYPE (t_stream), POINTER     :: g3b_rain
+
+  TYPE(io_time_event), SAVE     :: putrain
 
 CONTAINS
 
@@ -583,6 +595,23 @@ CONTAINS
     CALL add (g3b,'thvvar',   thvvar    ,lpost=.FALSE.,leveltype=HYBRID,         &
          longname='variance of virt pot temperature' ,units='K**2' )
 
+    CALL default_stream_setting (g3b_rain               &
+         ,lrerun=.TRUE.     &
+         ,lpost=.TRUE.      &
+         ,table=128 ,bits=16)
+    putrain%counter      = 3
+    putrain%unit         = 'hours'
+    putrain%adjustment   = 'first'
+    putrain%offset       = 0
+    call set_stream(g3b_rain, interval = putrain)
+    CALL add (g3b_rain,'aprl_na',      aprl_na      ,code=142,laccu=.FALSE. ,longname='large scale precipitation (not accu)'     ,bits=24,units='kg/m**2s')
+    CALL add (g3b_rain,'aprc_na',      aprc_na      ,code=143,laccu=.FALSE. ,longname='convective  precipitation (not accu)'     ,bits=24,units='kg/m**2s')
+    CALL add (g3b_rain,'aprs_na',      aprs_na      ,code=144,laccu=.FALSE. ,longname='large scale snow fall (not accu)'                     ,bits=24,units='kg/m**2s')
+    CALL add (g3b_rain,'aprcs_na',      aprcs_na      ,laccu=.FALSE. ,longname='convective snow fall (not accu)'                     ,bits=24,units='kg/m**2s')
+    CALL add (g3b_rain,'clcpre',      clcpre      ,laccu=.FALSE. ,longname='precipitating area fraction'                     ,bits=24,units='')
+    CALL add (g3b_rain,'xlvi_na',      xlvi_na      ,code=231,laccu=.FALSE. ,longname='vertically integrated cloud water'      ,units='kg/m**2')
+    CALL add (g3b_rain,'xivi_na',      xivi_na      ,code=150,laccu=.FALSE. ,longname='vertically integrated cloud ice'       ,units='kg/m**2' )
+
 
   END SUBROUTINE construct_g3b
 
diff --git a/src/mo_memory_gl.f90 b/src/mo_memory_gl.f90
index 389abbc..29cab99 100644
--- a/src/mo_memory_gl.f90
+++ b/src/mo_memory_gl.f90
@@ -7,11 +7,13 @@ MODULE mo_memory_gl
   USE mo_kind,        ONLY: dp
   USE mo_linked_list, ONLY: t_stream
   USE mo_memory_base, ONLY: new_stream, delete_stream, add_stream_element, &
-                            default_stream_setting, add_stream_reference
+                            default_stream_setting, add_stream_reference, set_stream
   USE mo_netCDF,      ONLY: max_dim_name
   USE mo_tracdef,     ONLY: trlist
   USE mo_filename,    ONLY: trac_filetype
 
+  USE mo_time_event,  ONLY: io_time_event ! for gl_rain output interval
+
   IMPLICIT NONE
 !------------------------------------------------------------------------------
   !
@@ -24,6 +26,7 @@ MODULE mo_memory_gl
   PUBLIC :: destruct_gl  ! destruct  the gl table
 
   PUBLIC :: gl           ! the gl table
+  PUBLIC :: gl_rain      ! the gl table
   PUBLIC :: tracer       ! the tracer table
 !------------------------------------------------------------------------------
 
@@ -37,11 +40,32 @@ MODULE mo_memory_gl
   REAL(dp), POINTER, PUBLIC :: phimp(:,:,:)
   REAL(dp), POINTER, PUBLIC :: sigmp(:,:,:)
 
+  ! fields that will go into a dedicated stream (gl_rain)
+  REAL(dp), POINTER, PUBLIC :: aprlv(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: aprlv_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: aprsv(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: aprsv_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: reffl_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: autoconv_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: acc1_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: acc2_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: xrl_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: xsl_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: xl_pre_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: xl_post_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: cdnc_pre_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: cdnc_post_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: reffl_pre_na(:,:,:)
+  REAL(dp), POINTER, PUBLIC :: reffl_post_na(:,:,:)
+
   ! declaration of table with 3d-field entries
 
   TYPE (t_stream), POINTER :: gl
+  TYPE (t_stream), POINTER :: gl_rain
   TYPE (t_stream), POINTER :: tracer
 
+  TYPE(io_time_event), SAVE     :: putrain
+
   ! private storage for tracer fields
 
   REAL(dp), POINTER :: pxt (:,:,:,:,:)
@@ -87,6 +111,47 @@ CONTAINS
     CALL add_stream_element (gl,'phimp',phimp,lpost=.FALSE., lrerun=.FALSE.) 
     CALL add_stream_element (gl,'sigmp',sigmp,lpost=.FALSE., lrerun=.FALSE.) 
 
+    CALL default_stream_setting (gl_rain               &
+         ,lrerun=.TRUE.     &
+         ,lpost=.TRUE.      &
+         ,table=128 ,bits=16)
+    putrain%counter      = 3
+    putrain%unit         = 'hours'
+    putrain%adjustment   = 'first'
+    putrain%offset       = 0
+    call set_stream(gl_rain, interval = putrain)
+
+    CALL add_stream_element (gl,'aprlv',     aprlv, lpost=.TRUE., lrerun = .FALSE., laccu=.TRUE. , &
+         longname='large scale rain (vertically resolved)',units='kg/m**2s')
+    CALL add_stream_element (gl_rain,'aprlv_na',     aprlv_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous large scale rain (vertically resolved)',units='kg/m**2s')
+    CALL add_stream_element (gl,'aprsv',     aprsv, lpost=.TRUE., lrerun = .FALSE., laccu=.TRUE. , &
+         longname='large scale snow (vertically resolved)',units='kg/m**2s')
+    CALL add_stream_element (gl_rain,'aprsv_na',     aprsv_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous large scale snow (vertically resolved)',units='kg/m**2s')
+    CALL add_stream_element (gl_rain,'reffl_pre_na',     reffl_pre_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='effective radius before autoconv/acc', units='um')
+    CALL add_stream_element (gl_rain,'reffl_post_na',   reffl_post_na,   lrerun = .FALSE., laccu = .FALSE., &
+         longname='effective radius before autoconv/acc', units='um')
+    CALL add_stream_element (gl_rain,'autoconv_na',     autoconv_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous autoconversion rate',units='kg kg**-2 s**-1')
+    CALL add_stream_element (gl_rain,'acc1_na',     acc1_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous acc1 rate',units='kg kg**-2 s**-1')
+    CALL add_stream_element (gl_rain,'acc2_na',     acc2_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous acc2 rate',units='kg kg**-2 s**-1')
+    CALL add_stream_element (gl_rain,'xrl_na',     xrl_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous large scale rain mixing ratio',units='kg/kg')
+    CALL add_stream_element (gl_rain,'xsl_na',     xsl_na, lpost=.TRUE., lrerun = .FALSE., laccu=.FALSE. , &
+         longname='instantaneous large scale snow mixing ratio',units='kg/kg')
+    CALL add_stream_element (gl_rain,'xl_pre_na',   xl_pre_na,   lrerun = .FALSE., laccu = .FALSE., &
+         longname='cloud water before autoconv/acc', units='kg/kg')
+    CALL add_stream_element (gl_rain,'xl_post_na',   xl_post_na,   lrerun = .FALSE., laccu = .FALSE., &
+         longname='cloud water after autoconv/acc', units='kg/kg')
+    CALL add_stream_element (gl_rain,'cdnc_pre_na',   cdnc_pre_na,   lrerun = .FALSE., laccu = .FALSE., &
+         longname='CDNC before autoconv/acc', units='m**-3')
+    CALL add_stream_element (gl_rain,'cdnc_post_na',   cdnc_post_na,   lrerun = .FALSE., laccu = .FALSE., &
+         longname='CDNC after autoconv/acc', units='m**-3')
+
     !
     ! Special handling for tracers
     !
diff --git a/src/mo_memory_streams.f90 b/src/mo_memory_streams.f90
index 166fabd..7cf42cf 100644
--- a/src/mo_memory_streams.f90
+++ b/src/mo_memory_streams.f90
@@ -20,14 +20,14 @@ MODULE mo_memory_streams
   USE mo_sub_nml,            ONLY: set_stream_element_nml, set_stream_nml
   USE mo_memory_sp,          ONLY: sp  ,construct_sp  ,destruct_sp
   USE mo_memory_ls,          ONLY: ls  ,construct_ls  ,destruct_ls
-  USE mo_memory_gl,          ONLY: gl  ,construct_gl  ,destruct_gl
+  USE mo_memory_gl,          ONLY: gl, gl_rain  ,construct_gl  ,destruct_gl
   USE mo_memory_f,           ONLY: f   ,construct_f   ,destruct_f
   USE mo_memory_g1a,         ONLY: g1a ,construct_g1a ,destruct_g1a
   USE mo_memory_g1b,         ONLY: g1b ,construct_g1b ,destruct_g1b
   USE mo_memory_g2a,         ONLY: g2a ,construct_g2a ,destruct_g2a
   USE mo_memory_g2b,         ONLY: g2b ,construct_g2b ,destruct_g2b
   USE mo_memory_g3a,         ONLY:      construct_g3a
-  USE mo_memory_g3b,         ONLY: g3b ,construct_g3b ,destruct_g3b
+  USE mo_memory_g3b,         ONLY: g3b, g3b_rain ,construct_g3b ,destruct_g3b
   USE mo_buffer_fft,         ONLY:      construct_fft ,destruct_fft
   USE mo_memory_cfdiag,      ONLY: locfdiag,construct_cfdiag,destruct_cfdiag
   USE mo_tracdef,            ONLY: ntrac
@@ -40,7 +40,7 @@ MODULE mo_memory_streams
   USE mo_port_test,          ONLY: init_port_test
   USE mo_surface_memory,     ONLY: surf, construct_surface, destruct_surface
   USE mo_submodel_interface, ONLY: init_subm_memory
-  USE mo_cosp_simulator,     ONLY: locosp, construct_stream_cosp
+  USE mo_cosp_echam,         ONLY: locosp, construct_stream_cosp
   USE mo_cosp_offline,       ONLY: locospoffl, construct_stream_cospoffl, &
                                    destruct_stream_cospoffl
   USE mo_diag_tendency_new,  ONLY: init_tdiag
@@ -72,11 +72,13 @@ CONTAINS
     CALL new_stream (ls   ,'ls'  ,ftyp,lrerun=.FALSE.,lpost=.FALSE.,post_suf='_echam')
     CALL new_stream (f    ,'f'   ,ftyp,lrerun=.FALSE.,lpost=.FALSE.,post_suf='_echam')
     CALL new_stream (gl   ,'gl'  ,ftyp,lrerun=.FALSE.,lpost=.TRUE. ,post_suf='_echam')
+    CALL new_stream (gl_rain,'gl_rain' ,ftyp,lrerun=.FALSE.,lpost=.TRUE. ,post_suf='_rain3d')
     CALL new_stream (g1a  ,'g1a' ,ftyp,lrerun=.FALSE.,lpost=.FALSE.,post_suf='_echam')
     CALL new_stream (g1b  ,'g1b' ,ftyp,lrerun=.FALSE.,lpost=.FALSE.,post_suf='_echam')
     CALL new_stream (g2a  ,'g2a' ,ftyp,lrerun=.FALSE.,lpost=.FALSE.,post_suf='_echam')
     CALL new_stream (g2b  ,'g2b' ,ftyp,lrerun=.FALSE.,lpost=.FALSE.,post_suf='_echam')
     CALL new_stream (g3b  ,'g3b' ,ftyp,lrerun=.FALSE.,lpost=.TRUE. ,post_suf='_echam')
+    CALL new_stream (g3b_rain  ,'g3b_rain' ,ftyp,lrerun=.FALSE.,lpost=.TRUE. ,post_suf='_rain2d')
     CALL new_stream (surf ,'surf',ftyp,lrerun=.FALSE.,lpost=.TRUE. ,post_suf='_surf')
 
     !-------------------------------------------------------------
diff --git a/src/mo_param_switches.f90 b/src/mo_param_switches.f90
index 8800a4a..445ccff 100644
--- a/src/mo_param_switches.f90
+++ b/src/mo_param_switches.f90
@@ -1,5 +1,7 @@
 MODULE mo_param_switches
 
+  USE mo_kind, ONLY: dp
+  
   IMPLICIT NONE
 
   ! M.A. Giorgetta, March 2000, lrad added
@@ -26,6 +28,9 @@ MODULE mo_param_switches
 
 !++mgs : new switches for interactive cloud scheme
   LOGICAL :: lcdnc_progn  !   true for prognostic cloud droplet activation
+  LOGICAL :: lcdnc_act_only  !   cloud droplets from activation only, no carry-over from previous time step
+  LOGICAL :: lcdnc_clim   !   constant cloud droplet number from climatology for the purposes of KK2000 autoconversion (switch)
+  REAL(dp):: cdnc_clim    !   constant cloud droplet number from climatology for the purposes of KK2000 autoconversion (value)
   INTEGER :: ncd_activ    !   type of cloud droplet activation scheme (see physctl.inc)
 !>>SF changed the former logical lice_supersat into an integer characterizing the cirrus scheme
   INTEGER :: nic_cirrus   !   type of cirrus scheme (see physctl.inc)
diff --git a/src/mo_radiation.f90 b/src/mo_radiation.f90
index e975afa..62a4013 100644
--- a/src/mo_radiation.f90
+++ b/src/mo_radiation.f90
@@ -97,9 +97,11 @@ MODULE mo_radiation
   USE mo_lrtm,            ONLY: lrtm
   USE mo_lrtm_setup,      ONLY: lrtm_setup
   USE mo_submodel,        ONLY: lanysubmodel, lco2
-  USE mo_cosp_simulator,  ONLY: cosp_reffl, cosp_reffi,  &
-                                locosp, cosp_f3d, Lisccp_sim,      &
+  USE mo_cosp_echam,      ONLY: cosp_reffl, cosp_reffi,       &
+                                locosp, cosp_f3d, Lisccp_sim, &
                                 cisccp_cldtau3d, cisccp_cldemi3d
+  USE mo_cosp_offline, ONLY: locospoffl, cospoffl_reffl, cospoffl_reffi, &
+                             offl_cisccp_cldtau3d, offl_cisccp_cldemi3d
   USE mo_memory_cfdiag,   ONLY: locfdiag, &
                               irlu, srsu, irld, srsd, irlucs, srsucs, irldcs, srsdcs
 
@@ -114,7 +116,8 @@ MODULE mo_radiation
                                      psct, psctm, ssi_factor,                     &
                                      flx_ratio_cur, flx_ratio_rad,                & 
                                      decl_sun_cur,solar_parameters
-  USE mo_radiation_forcing,ONLY: prepare_forcing
+  USE mo_radiation_forcing, ONLY: prepare_forcing, prepare_forcing_lwp, &
+       prepare_forcing_cdnc, prepare_forcing_cldfra, calculate_forcing_lwp_cdnc_cldfra
 
   IMPLICIT NONE
   
@@ -487,6 +490,70 @@ CONTAINS
                            ,krow             ,flx_dnlw_f        ,flx_dnsw_f    &
                            ,flx_dnlw_clr_f   ,flx_dnsw_clr_f    ,cos_mu0       )
     END IF
+    
+    IF (lradforcing(3)) THEN
+       ! call with 10% higher LWC
+       CALL rrtm_interface( &
+            & iaero           ,kproma          ,kbdim           ,klev            ,& 
+            & krow            ,ktrac           ,ktype           ,nb_sw           ,&
+            & loland          ,loglac          ,cemiss          ,diff            ,&
+            & cos_mu0         ,pgeom1          ,alb_vis         ,alb_nir         ,&
+            & alb_vis_dir     ,alb_nir_dir     ,alb_vis_dif     ,alb_nir_dif     ,&
+            & pp_fl           ,pp_hl           ,pp_sfc          ,tk_fl           ,&
+            & tk_hl           ,tk_sfc          ,xq_vap          ,xq_sat          ,&
+            & xq_liq * 1.1_wp ,xq_ice          ,cdnc            ,picnc           ,&
+            & cld_frc         ,cld_cvr         ,xm_o3           ,xm_co2          ,&
+            & xm_ch4          ,xm_n2o          ,xm_cfc          ,xm_o2           ,&
+            & pxtm1           ,flx_dnlw_f      ,flx_dnsw_f      ,flx_dnlw_clr_f  ,&
+            & flx_dnsw_clr_f  ,flx_uplw_sfc    ,flx_upsw_sfc    ,flx_uplw_clr_sfc,&
+            & flx_upsw_clr_sfc,emiss_sfc       ,toa_solar_irr   ,nir_sfc         ,&
+            & nir_dff_sfc     ,vis_sfc         ,vis_dff_sfc     ,dvis_sfc        ,&
+            & dpar_sfc        ,par_dff_sfc                                        )
+       CALL prepare_forcing_lwp(kproma           ,kbdim             ,klevp1        &
+            ,krow             ,flx_dnlw_f        ,flx_dnsw_f    &
+            ,flx_dnlw_clr_f   ,flx_dnsw_clr_f    ,cos_mu0       )
+       ! call with 10% higher CDNC
+       CALL rrtm_interface( &
+            & iaero           ,kproma          ,kbdim           ,klev            ,& 
+            & krow            ,ktrac           ,ktype           ,nb_sw           ,&
+            & loland          ,loglac          ,cemiss          ,diff            ,&
+            & cos_mu0         ,pgeom1          ,alb_vis         ,alb_nir         ,&
+            & alb_vis_dir     ,alb_nir_dir     ,alb_vis_dif     ,alb_nir_dif     ,&
+            & pp_fl           ,pp_hl           ,pp_sfc          ,tk_fl           ,&
+            & tk_hl           ,tk_sfc          ,xq_vap          ,xq_sat          ,&
+            & xq_liq          ,xq_ice          ,cdnc * 1.1_wp   ,picnc           ,&
+            & cld_frc         ,cld_cvr         ,xm_o3           ,xm_co2          ,&
+            & xm_ch4          ,xm_n2o          ,xm_cfc          ,xm_o2           ,&
+            & pxtm1           ,flx_dnlw_f      ,flx_dnsw_f      ,flx_dnlw_clr_f  ,&
+            & flx_dnsw_clr_f  ,flx_uplw_sfc    ,flx_upsw_sfc    ,flx_uplw_clr_sfc,&
+            & flx_upsw_clr_sfc,emiss_sfc       ,toa_solar_irr   ,nir_sfc         ,&
+            & nir_dff_sfc     ,vis_sfc         ,vis_dff_sfc     ,dvis_sfc        ,&
+            & dpar_sfc        ,par_dff_sfc                                        )
+       CALL prepare_forcing_cdnc(kproma           ,kbdim             ,klevp1        &
+            ,krow             ,flx_dnlw_f        ,flx_dnsw_f    &
+            ,flx_dnlw_clr_f   ,flx_dnsw_clr_f    ,cos_mu0       )
+       ! call with 10% lower cloud fraction (10% higher runs into a physcial boundary)
+       CALL rrtm_interface( &
+            & iaero           ,kproma          ,kbdim           ,klev            ,& 
+            & krow            ,ktrac           ,ktype           ,nb_sw           ,&
+            & loland          ,loglac          ,cemiss          ,diff            ,&
+            & cos_mu0         ,pgeom1          ,alb_vis         ,alb_nir         ,&
+            & alb_vis_dir     ,alb_nir_dir     ,alb_vis_dif     ,alb_nir_dif     ,&
+            & pp_fl           ,pp_hl           ,pp_sfc          ,tk_fl           ,&
+            & tk_hl           ,tk_sfc          ,xq_vap          ,xq_sat          ,&
+            & xq_liq          ,xq_ice          ,cdnc            ,picnc           ,&
+            & cld_frc * 0.9_wp,cld_cvr         ,xm_o3           ,xm_co2          ,&
+            & xm_ch4          ,xm_n2o          ,xm_cfc          ,xm_o2           ,&
+            & pxtm1           ,flx_dnlw_f      ,flx_dnsw_f      ,flx_dnlw_clr_f  ,&
+            & flx_dnsw_clr_f  ,flx_uplw_sfc    ,flx_upsw_sfc    ,flx_uplw_clr_sfc,&
+            & flx_upsw_clr_sfc,emiss_sfc       ,toa_solar_irr   ,nir_sfc         ,&
+            & nir_dff_sfc     ,vis_sfc         ,vis_dff_sfc     ,dvis_sfc        ,&
+            & dpar_sfc        ,par_dff_sfc                                        )
+       CALL prepare_forcing_cldfra(kproma           ,kbdim             ,klevp1        &
+            ,krow             ,flx_dnlw_f        ,flx_dnsw_f    &
+            ,flx_dnlw_clr_f   ,flx_dnsw_clr_f    ,cos_mu0       )
+    END IF
+
     CALL rrtm_interface( &
          & iaero           ,kproma          ,kbdim           ,klev            ,& 
          & krow            ,ktrac           ,ktype           ,nb_sw           ,&
@@ -503,6 +570,13 @@ CONTAINS
          & flx_upsw_clr_sfc,emiss_sfc       ,toa_solar_irr   ,nir_sfc         ,&
          & nir_dff_sfc     ,vis_sfc         ,vis_dff_sfc     ,dvis_sfc        ,&
          & dpar_sfc        ,par_dff_sfc                                        )
+
+    IF (lradforcing(3)) THEN
+       CALL calculate_forcing_lwp_cdnc_cldfra(kproma           ,kbdim             ,klevp1        &
+            ,krow             ,flx_dnlw        ,flx_dnsw    &
+            ,flx_dnlw_clr   ,flx_dnsw_clr    ,pp_hl, pp_fl, tk_fl, xq_liq, xq_ice, cdnc, cos_mu0, cld_frc       )
+    END IF
+
     !
     ! 3.0 Diagnostics
     ! --------------------------------
@@ -1014,6 +1088,49 @@ CONTAINS
      END IF
   END IF
 
+ ! added jkretz
+ ! get data into mo_cosp_offline
+  IF (locospoffl) THEN
+    DO jk=1,klev
+      jkb = klev+1-jk
+     DO jl=1,kproma
+        cospoffl_reffl(jl,jk,krow) = re_drop(jl,jkb)
+        cospoffl_reffi(jl,jk,krow) = re_cryst(jl,jkb)
+     END DO
+    END DO
+     IF ( Lisccp_sim ) THEN   
+        !don't really need vert. re-arrange ...
+      IF (l_newoptics .and. l_srtm) THEN
+        DO jk=1,klev
+          jkb = klev+1-jk
+          DO jl=1,kproma
+            offl_cisccp_cldtau3d(jl,jk,krow) = &
+               cld_tau_sw_vr(jl, 9  ,jkb)  ! band 9 is 625 - 778 nm, needed is 670 nm
+          END DO
+        END DO
+      ELSE
+        DO jk=1,klev
+          jkb = klev+1-jk
+          DO jl=1,kproma
+            offl_cisccp_cldtau3d(jl,jk,krow) = &
+               cld_tau_sw_vr(jl,  3 ,jkb)  ! band 3 is 440 - 690 nm, needed is 670 nm
+          END DO
+        END DO
+      END IF
+        DO jk=1,klev
+          jkb = klev+1-jk
+          DO jl=1,kproma
+           !this is ONLY o.k. as long as wp equals dp, else conversion needed
+             offl_cisccp_cldemi3d(jl,jk,krow) = &
+               1._wp - exp(-1._wp*cld_tau_lw_vr(jl,jkb,6)) ! band 6 is 820 - 980 cm-1, 
+                                                                   !  we need 10.5 m channel
+          END DO
+        END DO
+     END IF
+  END IF
+! 
+  
+
     !
     ! 3.5 Interface for submodels that provide aerosol and/or cloud radiative properties:
     ! -----------------------------------------------------------------------------------
diff --git a/src/mo_radiation_forcing.f90 b/src/mo_radiation_forcing.f90
index 938d880..88782e3 100644
--- a/src/mo_radiation_forcing.f90
+++ b/src/mo_radiation_forcing.f90
@@ -45,7 +45,9 @@ MODULE mo_radiation_forcing
   USE mo_radiation_parameters,ONLY: psctm, lradforcing, cemiss
   USE mo_time_control,        ONLY: zdtime=>delta_time
 
-  PUBLIC :: construct_forcing, prepare_forcing, calculate_forcing
+  PUBLIC :: construct_forcing, prepare_forcing, &
+       prepare_forcing_lwp, prepare_forcing_cdnc, prepare_forcing_cldfra, &
+       calculate_forcing, calculate_forcing_lwp_cdnc_cldfra
 
   PRIVATE
 
@@ -58,6 +60,11 @@ MODULE mo_radiation_forcing
   REAL(dp),  POINTER :: trsol_for(:,:,:)
   REAL(dp),  POINTER :: trsof_for(:,:,:)
 
+  REAL(dp),  POINTER :: emter_lwp(:,:,:)
+  REAL(dp),  POINTER :: emtef_lwp(:,:,:)
+  REAL(dp),  POINTER :: trsol_lwp(:,:,:)
+  REAL(dp),  POINTER :: trsof_lwp(:,:,:)
+
   !--- Forcing fields TOA, SUR:
 
   REAL(dp),  POINTER :: fsw_clear_top(:,:) !instantaneous sw forcing clear sky top of atmosphere
@@ -80,6 +87,27 @@ MODULE mo_radiation_forcing
   REAL(dp), POINTER  :: netht_lw(:,:,:)   !3d forcing of net lw heating rate (K/day) 
   REAL(dp), POINTER  :: netht_sw(:,:,:)   !3d forcing of net sw heating rate (K/day)
 
+  !--- LWP adjustment sensitivity:
+  REAL(dp),  POINTER :: d_aflx_sw_lwp(:,:,:)  !3d instantaneous sw LWP adjustment sensitivity all sky
+  REAL(dp),  POINTER :: d_aflx_swc_lwp(:,:,:) !3d instantaneous sw LWP adjustment sensitivity clear sky
+
+  REAL(dp),  POINTER :: fsw_total_top_lwp(:,:) !instantaneous sw LWP adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: fsw_total_top_cdnc(:,:) !instantaneous sw CDNC adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: fsw_total_top_cldfra(:,:) !instantaneous sw cloud fraction adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: fsw_total_top_unpert(:,:) !instantaneous sw LWP adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: fsw_clear_top_unpert(:,:) !instantaneous sw LWP adjustment sensitivity clear sky top of atmosphere
+  REAL(dp),  POINTER :: flw_total_top_lwp(:,:) !instantaneous lw LWP adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: flw_total_top_cdnc(:,:) !instantaneous lw CDNC adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: flw_total_top_cldfra(:,:) !instantaneous lw cloud fraction adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: flw_total_top_unpert(:,:) !instantaneous lw LWP adjustment sensitivity all sky top of atmosphere
+  REAL(dp),  POINTER :: flw_clear_top_unpert(:,:) !instantaneous lw LWP adjustment sensitivity clear sky top of atmosphere
+
+  REAL(dp),  POINTER :: xlvi(:,:) !instantaneous LWP
+  REAL(dp),  POINTER :: cos_mu0(:,:) !instantaneous cos(zenith angle)
+  REAL(dp),  POINTER :: cdnc(:,:) !instantaneous LWP
+  REAL(dp),  POINTER :: cldfra(:,:) !instantaneous cloud fraction
+  REAL(dp),  POINTER :: cldfra_liq(:,:) !instantaneous liquid-only cloud fraction
+
 CONTAINS
 
 !-----------------------------------------------------------------------------
@@ -92,21 +120,28 @@ CONTAINS
 !-----------------------------------------------------------------------------
 SUBROUTINE construct_forcing
     USE mo_memory_base,           ONLY: new_stream, add_stream_element, &
-                                        default_stream_setting, &
+                                        default_stream_setting, set_stream, &
                                         add_stream_reference, AUTO
     USE mo_linked_list,           ONLY: SURFACE, HYBRID, HYBRID_H
+    USE mo_time_event,            ONLY: io_time_event
 
     IMPLICIT NONE
 
     LOGICAL :: lpost, lrerun
+    TYPE(io_time_event), SAVE     :: putforcing
 
 
     !--- Create new stream:
 
-    lpost=lradforcing(1).OR.lradforcing(2)
+    lpost=lradforcing(1).OR.lradforcing(2).OR.lradforcing(3)
     lrerun=lpost
 
     CALL new_stream (forcing ,'forcing', lpost=lpost, lrerun=lrerun, lcontnorest=.TRUE.)
+    putforcing%counter      = 3
+    putforcing%unit         = 'hours'
+    putforcing%adjustment   = 'first'
+    putforcing%offset       = 0
+    call set_stream(forcing, interval = putforcing)
 
     !--- 1) Add standard fields for post-processing:
 
@@ -126,6 +161,11 @@ SUBROUTINE construct_forcing
     CALL add_stream_element(forcing,  'trsol_for',  trsol_for, leveltype=HYBRID_H, units='W m-2')
     CALL add_stream_element(forcing,  'trsof_for',  trsof_for, leveltype=HYBRID_H, units='W m-2')
 
+    CALL add_stream_element(forcing,  'emter_lwp',  emter_lwp, leveltype=HYBRID_H, units='W m-2')
+    CALL add_stream_element(forcing,  'emtef_lwp',  emtef_lwp, leveltype=HYBRID_H, units='W m-2')
+    CALL add_stream_element(forcing,  'trsol_lwp',  trsol_lwp, leveltype=HYBRID_H, units='W m-2')
+    CALL add_stream_element(forcing,  'trsof_lwp',  trsof_lwp, leveltype=HYBRID_H, units='W m-2')
+
     !--- 3) Add forcing stream elements:
 
     CALL default_stream_setting (forcing, lrerun    = .TRUE.,   &
@@ -197,6 +237,58 @@ SUBROUTINE construct_forcing
                                 code=27                                                                  )
 
     END IF
+    
+    IF (lradforcing(3)) THEN
+       
+       !--- Forcing fields TOA, SUR:
+       CALL default_stream_setting (forcing, leveltype = SURFACE )
+       CALL add_stream_element(forcing,  'COS_MU0',  cos_mu0,     units='',             &
+            longname='Cosine of instantaneous zenith angle',   &
+            laccu = .FALSE., code=10                                                                   )
+       CALL add_stream_element(forcing,  'FSW_TOTAL_TOP_UNPERT',  fsw_total_top_unpert,     units='W m-2',             &
+            longname='Instantaneous unperturbed all sky TOA SW flux',   &
+            laccu = .FALSE., code=11                                                                   )
+       CALL add_stream_element(forcing,  'FLW_TOTAL_TOP_UNPERT',  flw_total_top_unpert,     units='W m-2',             &
+            longname='Instantaneous unperturbed all sky TOA LW flux',   &
+            laccu = .FALSE., code=11                                                                   )
+       CALL add_stream_element(forcing,  'FSW_CLEAR_TOP_UNPERT',  fsw_clear_top_unpert,     units='W m-2',             &
+            longname='Instantaneous unperturbed clear sky TOA SW flux',   &
+            laccu = .FALSE., code=11                                                                   )
+       CALL add_stream_element(forcing,  'FLW_CLEAR_TOP_UNPERT',  flw_clear_top_unpert,     units='W m-2',             &
+            longname='Instantaneous unperturbed clear sky TOA LW flux',   &
+            laccu = .FALSE., code=11                                                                   )
+       CALL add_stream_element(forcing,  'FSW_TOTAL_TOP_LWP',  fsw_total_top_lwp,     units='W m-2',             &
+                               longname='Instantaneous SW TOA LWP perturbation',   &
+                               laccu = .FALSE., code=12                                                                   )
+       CALL add_stream_element(forcing,  'FSW_TOTAL_TOP_CDNC',  fsw_total_top_cdnc,     units='W m-2',             &
+                               longname='Instantaneous SW TOA CDNC perturbation',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'FSW_TOTAL_TOP_CLDFRA',  fsw_total_top_cldfra,     units='W m-2',             &
+                               longname='Instantaneous SW TOA cloud fraction perturbation',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'FLW_TOTAL_TOP_LWP',  flw_total_top_lwp,     units='W m-2',             &
+                               longname='Instantaneous LW TOA LWP perturbation',   &
+                               laccu = .FALSE., code=12                                                                   )
+       CALL add_stream_element(forcing,  'FLW_TOTAL_TOP_CDNC',  flw_total_top_cdnc,     units='W m-2',             &
+                               longname='Instantaneous LW TOA CDNC perturbation',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'FLW_TOTAL_TOP_CLDFRA',  flw_total_top_cldfra,     units='W m-2',             &
+                               longname='Instantaneous LW TOA cloud fraction perturbation',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'XLVI',  xlvi,     units='kg m-2',             &
+                               longname='Instantaneous LWP',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'CDNC',  cdnc,     units='m-3',             &
+                               longname='Instantaneous CDNC vertically averaged over liquid-only clouds',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'CLDFRA',  cldfra,     units='',             &
+                               longname='Instantaneous cloud fraction',   &
+                               laccu = .FALSE., code=13                                                                   )
+       CALL add_stream_element(forcing,  'CLDFRA_LIQ',  cldfra_liq,     units='',             &
+                               longname='Instantaneous cloud fraction (liquid-only clouds)',   &
+                               laccu = .FALSE., code=13                                                                   )
+    END IF
+
 END SUBROUTINE construct_forcing
 !-----------------------------------------------------------------------------
 !>
@@ -227,6 +319,57 @@ SUBROUTINE prepare_forcing(kproma           ,kbdim             ,klevp1        &
          &                     SPREAD(z1(1:kproma),2,klevp1)
 
 END SUBROUTINE prepare_forcing
+
+SUBROUTINE prepare_forcing_lwp(kproma           ,kbdim             ,klevp1        &
+     & ,krow             ,pflx_dnlw         ,pflx_dnsw     &
+     & ,pflx_dnlw_clr    ,pflx_dnsw_clr     ,cos_mu0       )
+  INTEGER, INTENT(in)     :: kproma, kbdim, klevp1, krow
+  REAL(dp), INTENT(in)    :: &
+         pflx_dnlw(kbdim,klevp1),    & !< Net dwnwrd LW flux [Wm2]
+         pflx_dnsw(kbdim,klevp1),    & !< Net dwnwrd SW flux [Wm2] for forcing
+         pflx_dnlw_clr(kbdim,klevp1),& !< Net dn LW flux (clear sky) [Wm2]
+         pflx_dnsw_clr(kbdim,klevp1),& !< Net dn SW flux (clear sky) [Wm2]
+         cos_mu0(kbdim)                !< Cos of local zenith angle
+
+  ! remember TOA SW and LW fluxes with perturbed LWP
+  fsw_total_top_lwp(1:kproma,krow)=pflx_dnsw(1:kproma,1)
+  flw_total_top_lwp(1:kproma,krow)=pflx_dnlw(1:kproma,1)
+
+END SUBROUTINE prepare_forcing_lwp
+
+SUBROUTINE prepare_forcing_cdnc(kproma           ,kbdim             ,klevp1        &
+     & ,krow             ,pflx_dnlw         ,pflx_dnsw     &
+     & ,pflx_dnlw_clr    ,pflx_dnsw_clr     ,cos_mu0       )
+  INTEGER, INTENT(in)     :: kproma, kbdim, klevp1, krow
+  REAL(dp), INTENT(in)    :: &
+         pflx_dnlw(kbdim,klevp1),    & !< Net dwnwrd LW flux [Wm2]
+         pflx_dnsw(kbdim,klevp1),    & !< Net dwnwrd SW flux [Wm2] for forcing
+         pflx_dnlw_clr(kbdim,klevp1),& !< Net dn LW flux (clear sky) [Wm2]
+         pflx_dnsw_clr(kbdim,klevp1),& !< Net dn SW flux (clear sky) [Wm2]
+         cos_mu0(kbdim)                !< Cos of local zenith angle
+
+  ! remember TOA SW and LW fluxes with perturbed CDNC
+  fsw_total_top_cdnc(1:kproma,krow)=pflx_dnsw(1:kproma,1)
+  flw_total_top_cdnc(1:kproma,krow)=pflx_dnlw(1:kproma,1)
+
+END SUBROUTINE prepare_forcing_cdnc
+
+SUBROUTINE prepare_forcing_cldfra(kproma           ,kbdim             ,klevp1        &
+     & ,krow             ,pflx_dnlw         ,pflx_dnsw     &
+     & ,pflx_dnlw_clr    ,pflx_dnsw_clr     ,cos_mu0       )
+  INTEGER, INTENT(in)     :: kproma, kbdim, klevp1, krow
+  REAL(dp), INTENT(in)    :: &
+         pflx_dnlw(kbdim,klevp1),    & !< Net dwnwrd LW flux [Wm2]
+         pflx_dnsw(kbdim,klevp1),    & !< Net dwnwrd SW flux [Wm2] for forcing
+         pflx_dnlw_clr(kbdim,klevp1),& !< Net dn LW flux (clear sky) [Wm2]
+         pflx_dnsw_clr(kbdim,klevp1),& !< Net dn SW flux (clear sky) [Wm2]
+         cos_mu0(kbdim)                !< Cos of local zenith angle
+
+  ! remember TOA SW and LW fluxes with perturbed CDNC
+  fsw_total_top_cldfra(1:kproma,krow)=pflx_dnsw(1:kproma,1)
+  flw_total_top_cldfra(1:kproma,krow)=pflx_dnlw(1:kproma,1)
+
+END SUBROUTINE prepare_forcing_cldfra
 !-----------------------------------------------------------------------------
 !>
 !! calculate_forcing: calculate radiative forcing 
@@ -256,6 +399,10 @@ SUBROUTINE calculate_forcing( &
                                  zflxs_clear_for(kbdim,klevp1), &
                                  zflxt_all_for(kbdim,klevp1), &
                                  zflxt_clear_for(kbdim,klevp1)
+  REAL(dp)                    :: zflxs_all_lwp(kbdim,klevp1), &
+                                 zflxs_clear_lwp(kbdim,klevp1), &
+                                 zflxt_all_lwp(kbdim,klevp1), &
+                                 zflxt_clear_lwp(kbdim,klevp1)
   REAL(dp)                    :: zdtdt_sw, zdtdt_all_for_sw, &
                                  zdtdt_lw, zdtdt_all_for_lw
 
@@ -320,5 +467,95 @@ SUBROUTINE calculate_forcing( &
      flw_clear_top(1:kproma,krow) = d_aflx_lwc(1:kproma,1,krow)
      flw_clear_sur(1:kproma,krow) = d_aflx_lwc(1:kproma,klevp1,krow)
   END IF
+
 END SUBROUTINE calculate_forcing
+
+SUBROUTINE calculate_forcing_lwp_cdnc_cldfra( &
+     & kproma           ,kbdim             ,klevp1        &
+     & ,krow             ,pflx_dnlw         ,pflx_dnsw     &
+     & ,pflx_dnlw_clr    ,pflx_dnsw_clr     &
+     & ,pp_hl, pp_fl, tk_fl, xq_liq, xq_ice, pcdnc, pcos_mu0, cld_frc       )
+  
+  USE mo_constants, ONLY: g, rd
+  
+  INTEGER, INTENT(in)     :: kproma, kbdim, klevp1, krow
+  REAL(dp), INTENT(in)    :: &
+       pflx_dnlw(kbdim,klevp1),    & !< Net dwnwrd LW flux [Wm2]
+       pflx_dnsw(kbdim,klevp1),    & !< Net dwnwrd SW flux [Wm2] for forcing
+       pflx_dnlw_clr(kbdim,klevp1),& !< Net dn LW flux (clear sky) [Wm2]
+       pflx_dnsw_clr(kbdim,klevp1),& !< Net dn SW flux (clear sky) [Wm2]
+       pp_hl(kbdim,klevp1),        & !< Pressure on half levels [Pa]
+       pp_fl(kbdim,klevp1),        & !< Pressure on full levels [Pa]
+       tk_fl(kbdim,klevp1 - 1),    & !< Temperature on full levels [Pa]
+       xq_liq(kbdim,klevp1 - 1),   & !< Liquid water mixing ratio [kg kg-1]
+       xq_ice(kbdim,klevp1 - 1),   & !< Liquid water mixing ratio [kg kg-1]
+       pcdnc(kbdim,klevp1 - 1),   & !< Liquid water mixing ratio [kg kg-1]
+       pcos_mu0(kbdim),            & !< Liquid water mixing ratio [kg kg-1]
+       cld_frc(kbdim,klevp1 - 1)    !< Liquid water mixing ratio [kg kg-1]
+
+  INTEGER                     :: jk, jl, klev
+  REAL(dp)                    :: ppd_hl(kbdim,klevp1 - 1), &
+       dz(kbdim,klevp1 - 1), &
+       z_liq(kbdim), &
+       cld_frc_liq(kbdim,klevp1 - 1), &
+       dpg(kbdim,klevp1 - 1)
+
+  klev=klevp1-1
+
+  IF (lradforcing(3)) THEN
+     fsw_total_top_unpert(1:kproma,krow) = pflx_dnsw(1:kproma,1)
+     flw_total_top_unpert(1:kproma,krow) = pflx_dnlw(1:kproma,1)
+     fsw_clear_top_unpert(1:kproma,krow) = pflx_dnsw_clr(1:kproma,1)
+     flw_clear_top_unpert(1:kproma,krow) = pflx_dnlw_clr(1:kproma,1)
+     cos_mu0(1:kproma,krow) = pcos_mu0(1:kproma)
+
+     ! calculate LWP and CDNC burden of liquid-only clouds
+     xlvi(1:kproma,krow) = 0.0_dp
+     ppd_hl(1:kproma,:) = pp_hl(1:kproma,2:klev+1)-pp_hl(1:kproma,1:klev)
+     dpg(:,:) = ppd_hl(:,:) / g
+     DO jk = 1,klev
+        xlvi(1:kproma,krow) = xlvi(1:kproma,krow) + xq_liq(1:kproma,jk)*dpg(1:kproma,jk) 
+     END DO
+
+     dz(:,:) = rd * tk_fl(:,:) * dpg / pp_fl(:,:)
+     z_liq(:) = 0.0_dp
+     cdnc(1:kproma,krow) = 0.0_dp
+     DO jk = 1,klev
+        DO jl = 1, kproma
+           IF (xq_ice(jl,jk) < 1e-7_dp .and. xq_liq(jl,jk) > 1e-7_dp) THEN
+              ! increment CDNC burden of liquid-only clouds
+              cdnc(jl,krow) = cdnc(jl,krow) + pcdnc(jl,jk)*dz(jl,jk)
+              ! also keep track of total thickness of liquid-only clouds
+              z_liq(jl) = z_liq(jl) + dz(jl,jk)
+           END IF
+        END DO
+     END DO
+
+     ! normalize CDNC burden by geometric thickness of liquid-only clouds to get average CDNC
+     WHERE (z_liq > 0.0_dp)
+        cdnc(1:kproma,krow) = cdnc(1:kproma,krow) / z_liq(1:kproma)
+     END WHERE
+
+     ! calculate cloud fractions
+     cldfra(1:kproma,krow) = 1.0_dp - cld_frc(1:kproma,1)
+     DO jk = 2, klev
+        cldfra(1:kproma,krow) = cldfra(1:kproma,krow)                                    &
+             &        *(1.0_dp-MAX(cld_frc(1:kproma,jk),cld_frc(1:kproma,jk-1))) &
+             &        /(1.0_dp-MIN(cld_frc(1:kproma,jk-1),1.0_dp-EPSILON(1.0_dp)))
+     END DO
+     cldfra(1:kproma,krow) = 1.0_dp-cldfra(1:kproma,krow)
+
+     cld_frc_liq = cld_frc
+     where (xq_ice > 1e-7_dp) cld_frc_liq = 0.0_dp
+     cldfra_liq(1:kproma,krow) = 1.0_dp - cld_frc_liq(1:kproma,1)
+     DO jk = 2, klev
+        cldfra_liq(1:kproma,krow) = cldfra_liq(1:kproma,krow)                                    &
+             &        *(1.0_dp-MAX(cld_frc_liq(1:kproma,jk),cld_frc_liq(1:kproma,jk-1))) &
+             &        /(1.0_dp-MIN(cld_frc_liq(1:kproma,jk-1),1.0_dp-EPSILON(1.0_dp)))
+     END DO
+     cldfra_liq(1:kproma,krow) = 1.0_dp-cldfra_liq(1:kproma,krow)
+  END IF
+ 
+END SUBROUTINE calculate_forcing_lwp_cdnc_cldfra
+
 END MODULE mo_radiation_forcing
diff --git a/src/mo_radiation_parameters.f90 b/src/mo_radiation_parameters.f90
index b2c2670..1a1bb2c 100644
--- a/src/mo_radiation_parameters.f90
+++ b/src/mo_radiation_parameters.f90
@@ -63,9 +63,10 @@ IMPLICIT NONE
   LOGICAL :: l_lrtm      = .TRUE.  !< USE New (V4) LRTM Model (else ECHAM5 RRTM)
   LOGICAL :: l_newoptics = .TRUE.  !< USE New (V4) LRTM Model (else ECHAM5 RRTM)
   LOGICAL :: ldiur       = .TRUE.  !< diurnal cycle
-  LOGICAL :: lradforcing(2) = (/.FALSE.,.FALSE./) !< &! switch on/off diagnostic 
+  LOGICAL :: lradforcing(3) = (/.FALSE.,.FALSE.,.FALSE./) !< &! switch on/off diagnostic 
              !of instantaneous aerosol solar (lradforcing(1)) and 
-             !thermal (lradforcing(2)) radiation forcing
+             !thermal (lradforcing(2)) radiation forcing and
+             !LWP (lradforcing(3)) RFaci adjustment
   LOGICAL :: lyr_perp    = .FALSE. !< switch to specify perpetual vsop87 year
   INTEGER :: yr_perp     = -99999  !< year if (lyr_perp == .TRUE.)
   INTEGER :: nmonth      =  0      !< 0=annual cycle; 1-12 for perpetual month
diff --git a/src/physc.f90 b/src/physc.f90
index 006cb19..135354d 100644
--- a/src/physc.f90
+++ b/src/physc.f90
@@ -105,9 +105,12 @@ USE mo_nmi,               ONLY: nmi_phase, NMI_ACCU, NMI_USE_AVG,              &
                                 lnmi_run, lnmi_cloud
 USE mo_diag_amip2,        ONLY: collect_amip2_diag 
 USE mo_tropopause,        ONLY: WMO_tropopause
-USE mo_cosp_simulator,    ONLY: locosp, call_cospsimulator
+
+USE mo_cosp_echam,        ONLY: locosp, echam_cospsimulator
 USE mo_cosp_offline,      ONLY: locospoffl, cospoffl_geom1, cospoffl_geohm1, &
-                                      cospoffl_p, cospoffl_ph
+       cospoffl_p, cospoffl_ph
+
+
 ! JSBACH interface add-ons
 USE mo_surface_memory,    ONLY: jrsfl, jrsfc, jssfl, jssfc, ztrfli,            &
                                 zsofli,                                        &
@@ -1657,19 +1660,19 @@ EXTERNAL :: geopot, pres, presf, vdiff, cloud, cucall, radheat, collect
                      zfri,                  loland,                  xtm1(:,:,:,krow), &
                      xtte(:,:,:,krow))   
  ENDIF
-!
-! cosp simulator diagnostics
-!
-  IF (locosp ) THEN
-    CALL call_cospsimulator  &
-        (nproma,                   nlev,                           krow,                     &
+ !
+
+   IF (locosp ) THEN
+    CALL echam_cospsimulator  &
+         (nproma,                   nlev,                           krow,                     &
          app1(1:nproma,:),         aphp1(1:nproma,:),              geom1(1:nproma,:),        &
-         geospm(1:nproma,krow),    slm(1:nproma,krow),             tm1(1:nproma,:,krow),     &
-         qm1(1:nproma,:,krow),     relhum(1:nproma,:,krow),        xlm1(1:nproma,:,krow),    &
+         geospm(1:nproma,krow),    slf(1:nproma,krow),             tm1(1:nproma,:,krow),     &
+         qm1(1:nproma,:,krow),     relhum(:,:,krow),               xlm1(1:nproma,:,krow),    &
          xim1(1:nproma,:,krow),    zfrl(1:nproma),                 zfrw(1:nproma),           &
          zfri(1:nproma),           tslm1(1:nproma,krow),           tsw(1:nproma,krow),       &
          tsi(1:nproma,krow)                                                                  )
   END IF
+
 !
 ! collect data for high frequency output at individual locations (cfSites)
 !
@@ -1677,7 +1680,7 @@ EXTERNAL :: geopot, pres, presf, vdiff, cloud, cucall, radheat, collect
     CALL  collect_station_diag(nproma,nbdim,nlev,nlevp1,krow   &
             ,geom1 ) !!, vervel(:,:,krow) ) !!, geom1    )  
  
-  END IF
+ END IF
   IF ( locospoffl ) THEN
     IF ( .NOT. lanysubmodel) THEN
       alpha0 = 0._dp
@@ -1687,7 +1690,7 @@ EXTERNAL :: geopot, pres, presf, vdiff, cloud, cucall, radheat, collect
     cospoffl_geom1(1:nproma,:,krow) = geom1(1:nproma,:)
     cospoffl_geohm1(1:nproma,:,krow) = geohm1(1:nproma,:)
     cospoffl_p(1:nproma,:,krow) = app1(1:nproma,:)
-    cospoffl_ph(1:nproma,:,krow) = aphp1(1:nproma,:)	
+    cospoffl_ph(1:nproma,:,krow) = aphp1(1:nproma,:)
   END IF
 
 !
diff --git a/src/radheat.f90 b/src/radheat.f90
index e994a9d..13940d9 100644
--- a/src/radheat.f90
+++ b/src/radheat.f90
@@ -89,7 +89,7 @@ USE mo_vphysc,            ONLY: vphysc
 USE mo_submodel,          ONLY: lanysubmodel
 USE mo_radiation_forcing, ONLY: calculate_forcing
 USE mo_diag_tendency_new, ONLY: tdiag_vars, set_tendency
-USE mo_cosp_simulator,    ONLY: locosp, cosp_sunlit
+USE mo_cosp_echam,        ONLY: locosp, cosp_sunlit
 
 #ifdef _PROFILE
 USE mo_profile,           ONLY: trace_start, trace_stop
diff --git a/src/scan1.f90 b/src/scan1.f90
index ee96125..6c64701 100644
--- a/src/scan1.f90
+++ b/src/scan1.f90
@@ -107,6 +107,9 @@ SUBROUTINE scan1
 !>>>mgs
   USE mo_submodel,        ONLY: lanysubmodel
   USE mo_submodel_interface,  ONLY: scan1_subm
+  USE mo_cosp_offline,       ONLY: locospoffl, cosp_offline
+  USE mo_station_diag,       ONLY: lostation, station_diag
+
 !<<<mgs
 
   IMPLICIT NONE
@@ -579,6 +582,18 @@ SUBROUTINE scan1
 
   CALL maxwind
 
+
+  ! added cosp_offine from stepon.f90
+  !Store variables at station locations of previous time step
+  !The real winds are calculated inside station_diag for the station
+  IF (lostation) THEN
+     CALL station_diag
+  END IF
+  IF (locospoffl) THEN
+     CALL cosp_offline
+  END IF
+  
+
   IF (.NOT. lcolumn) THEN
     IF (l_diagdyn) CALL print_diag_dynamics
     IF (ldiagamip) CALL amip2_global_diag
diff --git a/src/setphys.f90 b/src/setphys.f90
index 70702da..365da3b 100644
--- a/src/setphys.f90
+++ b/src/setphys.f90
@@ -22,11 +22,14 @@ SUBROUTINE setphys
   USE mo_control,        ONLY: nn, l_volc, ngl
   USE mo_param_switches, ONLY: lphys, lrad, lvdiff, lcond, lsurf, lcover,   &
                                lconv, lgwdrag, lice, lconvmassfix, iconv,   &
-                               lcdnc_progn, ncd_activ, nic_cirrus, lsecprod, &
+                               lcdnc_progn, lcdnc_act_only, &
+                               lcdnc_clim, cdnc_clim, &
+                               ncd_activ, nic_cirrus, lsecprod, &
                                nauto, ncvmicro, lorocirrus                           
   USE mo_cumulus_flux,   ONLY: lmfpen, lmfscv, lmfmid, lmfdd, lmfdudv
   USE mo_convect_tables, ONLY: init_convect_tables  
-  USE mo_cloud,          ONLY: rbetak, cbeta_pq_max, cbeta_pq, nbetax, nbetaq, cbetaqs, tbetai,tbetai0,tbetai1
+  USE mo_cloud,          ONLY: rbetak, cbeta_pq_max, cbeta_pq, nbetax, nbetaq, cbetaqs, tbetai,tbetai0,tbetai1, &
+                               ccraut, ccraut_override, ccauloc, creth, cautalpha, cautbeta
   USE mo_namelist,       ONLY: open_nml, position_nml, POSITIONED
   USE mo_exception,      ONLY: finish, message, message_text, em_error, em_warn, em_param, em_info
   USE mo_volc_data,      ONLY: jpd, aod, reff, extrat, ssa, asym, init_volc_tables, read_volc_data
@@ -38,6 +41,7 @@ SUBROUTINE setphys
   INCLUDE 'physctl.inc'
 
   REAL(dp) :: zq, zx
+  REAL(dp) :: tmp_ccraut
 
   INTEGER :: it, iq
   INTEGER :: ierr, inml, iunit   ! error return value from position_nml
@@ -75,12 +79,19 @@ SUBROUTINE setphys
   lice          = .TRUE.
   lconvmassfix  = .TRUE.
   lcdnc_progn   = .FALSE.
+  lcdnc_act_only = .FALSE.
+  lcdnc_clim = .FALSE.
+  cdnc_clim = 60e6_dp
   ncd_activ     = 1        ! default scheme for cdnc activation (will be 0 if lcdnc_progn=false)
   nic_cirrus    = 2        ! default scheme for cirrus scheme   (will be 0 if lcdnc_progn=false)
   nauto         = 1        ! default scheme for autoconversion  (will be 0 if lcdnc_progn=false)
   ncvmicro      = 0        ! default scheme for convective cloud microphysics 
   lsecprod      = .FALSE.  ! switch for computing secondary ice production !SF #251
   lorocirrus    = .FALSE.  ! switch for gravity waves updraft velocity for icnc (orographic cirrus clouds)
+  ccauloc = 1._dp
+  creth = -1._dp           ! negative creth means no effective-radius threshold in
+  cautalpha = 2.47_dp      ! autoconversion exponent for q_l
+  cautbeta = -1.79_dp      ! autoconversion exponent for CDNC
   !
   !
   !*         1.3     Initialise lookup tables for CUADJTQ
@@ -145,6 +156,8 @@ SUBROUTINE setphys
   !
 200 CONTINUE
   !
+  ccraut = -999.0
+  ccraut_override = -999.0 ! only set to values other than -999.0 if requested in the namelist
   IF (p_parallel_io) THEN
     inml = open_nml('namelist.echam')
      iunit = position_nml ('PHYSCTL', inml, status=ierr)
@@ -167,13 +180,23 @@ SUBROUTINE setphys
      CALL p_bcast (lice, p_io)
      CALL p_bcast (lconvmassfix, p_io)
      CALL p_bcast (lcdnc_progn, p_io)
+     CALL p_bcast (lcdnc_clim, p_io)
+     CALL p_bcast (cdnc_clim, p_io)
+     CALL p_bcast (lcdnc_act_only, p_io)
      CALL p_bcast (ncd_activ, p_io)
      CALL p_bcast (nic_cirrus, p_io)
      CALL p_bcast (lsecprod, p_io)
      CALL p_bcast (lorocirrus, p_io)
      CALL p_bcast (nauto, p_io)
      CALL p_bcast (ncvmicro, p_io)
+     CALL p_bcast (ccraut, p_io)
+     CALL p_bcast (ccauloc, p_io)
+     CALL p_bcast (creth, p_io)
+     CALL p_bcast (cautalpha, p_io)
+     CALL p_bcast (cautbeta, p_io)
   ENDIF
+  tmp_ccraut = ccraut
+  ccraut_override = ccraut
 !
 !     ------------------------------------------------------------
 !
@@ -338,7 +361,15 @@ SUBROUTINE setphys
 320 CONTINUE
 !
   CALL iniphy
+  !
+
+!
 !
+!*        3.3      restore ccraut
+!
+330 CONTINUE
+  if (tmp_ccraut /= -999.0) ccraut = tmp_ccraut
+  
 END SUBROUTINE setphys
 
 !-----------------------------------------------------------------------
diff --git a/src/stepon.f90 b/src/stepon.f90
index 4ba38be..e972207 100644
--- a/src/stepon.f90
+++ b/src/stepon.f90
@@ -121,8 +121,8 @@ SUBROUTINE stepon
   USE mo_submodel,           ONLY: lanysubmodel
   USE mo_submodel_interface, ONLY: stepon_subm
   USE mo_jsbach_interface,   ONLY: stepon_jsbach
-  USE mo_station_diag,       ONLY: lostation, station_diag  
-  USE mo_cosp_offline,       ONLY: locospoffl, cosp_offline
+  ! USE mo_station_diag,       ONLY: lostation, station_diag
+  !  USE mo_cosp_offline,       ONLY: locospoffl, cosp_offline
   USE mo_memory_cfdiag,      ONLY: locfdiag, calc_avps
 
 #ifdef FAST_AND_DIRTY
@@ -332,15 +332,15 @@ SUBROUTINE stepon
      END IF
 
 !cms++     
-     IF ( lostation ) THEN
-        CALL station_diag
-     END IF
-     IF ( locospoffl ) THEN
-        CALL cosp_offline
-     END IF
-     IF ( locfdiag ) THEN
-        CALL calc_avps
-     END IF   
+     ! IF ( lostation ) THEN
+     !    CALL station_diag
+     ! END IF
+     ! IF ( locospoffl ) THEN
+     !    CALL cosp_offline
+     ! END IF
+     ! IF ( locfdiag ) THEN
+     !    CALL calc_avps
+     ! END IF   
 !cms--
 
 
-- 
2.25.0

